$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$IFDEF F90
$BLOCK COMMENT -file M_units.3m_units.man
NAME
   M_units(3fm) - [M_units::INTRO] convert between various physical units
   (LICENSE:MIT)

SYNOPSIS

   procedure definitions:

      elemental real function c2f(celsius)
      elemental real function f2c(fahrenheit)

      elemental real|double function r2d(radians)
      elemental real|double function d2r(degrees)

      elemental real function feet_to_meters(feet)
      elemental real function meters_to_feet(meters)

      elemental real function sind(angle_in_degrees)
      elemental real function cosd(angle_in_degrees)
      elemental real function tand(angle_in_degrees)
      elemental real function asind(x)
      elemental real function acosd(x)
      elemental real function atand(x)
      elemental real function atan2d(x,y)

      elemental double function norm_angle_rad(radians)
      elemental real|double function norm_angle_deg(radians)

      subroutine cartesian_to_spherical(x,y,z,radius,inclination,azimuth)
      subroutine spherical_to_cartesian(radius,inclination,azimuth,x,y,z)
      subroutine cartesian_to_polar(x,y,radius,inclination)
      subroutine polar_to_cartesian(radius,inclination,x,y)

CONSTANTS SYNOPSIS

      function nan()
      function inf()
      function is_nan()
      function is_even()

  Simple constants:

    e,gamma,euler,golden_ratio,pi
    deg_per_rad, rad_per_deg
    c__m_per_sec, c__ft_per_sec

DESCRIPTION

   M_units(3fm) is a Fortran module that collects together basic
   procedures that are used to convert between various physical units
   and common named constants.

   The input values may be any standard scalar value supported by
   the anyscalar_to_real(3f) function (real,integer,doubleprecision) within
   the range allowed by the function.

PROCEDURES

   Angular Units

    o d2r:  Convert degrees to radians
    o r2d:  Convert radians to degrees

   Temperature

    o c2f:  Convert Celsius to Fahrenheit
    o f2c:  Convert Fahrenheit to Celsius

   Distance

    o feet_to_meters:  Convert feet to meters
    o meters_to_feet:  Convert meters to feet

   REAL trig functions where input is in angular degrees instead of radians

    o elemental real function sind(angle_in_degrees)
    o elemental real function cosd(angle_in_degrees)
    o elemental real function tand(angle_in_degrees)
    o elemental real function asind(x)
    o elemental real function acosd(x)
    o elemental real function atand(x)
    o elemental real function atan2d(x,y)

   Normalize angles into specific ranges

    o elemental double function norm_angle_rad(angle_in_radians)
    o elemental real|double function norm_angle_deg(angle_in_degrees)

   Coordinates

    o cartesian_to_spherical:  Convert cartesian coordinates to spherical
    o spherical:  Convert spherical coordinates to cartesian
    o cartesian_to_polar:  Convert cartesian coordinates to polar
    o polar:  Convert polar coordinates to cartesian

  Note that your compiler is less likely to inline small procedures in a
  module than it would statement functions or CONTAINED functions.

CONSTANTS

  "c__m_per_sec"   Speed of light in a vacuum
  "c__ft_per_sec"  Speed of light in a vacuum
  "deg_per_rad"
  "rad_per_deg"
  "e"              The base of the natural logarithm system. "e"
                   was named in honor of Euler, but is known as Napier's constant.
  "euler"
  "gamma"          The Euler-Mascheroni constant is often denoted by
                   a lower-case Gamma.
  "golden_ratio"

  "pi"             The ratio of the circumference of a circle to the diameter of the circle

NOTES

  Gamma is defined as

   Gamma = limit ( M -> Infinity ) ( Sum ( 1 <= N <= M ) 1 / N ) - Log ( M )

EXAMPLES
  Simple usage example:

   program demo_M_units
   use M_units, only : r2d, d2r
   use M_units, only : f2c, c2f
   use M_units, only : sind, cosd, tand
   use M_units, only : asind, acosd, atand, atan2d
   !!
   use M_units, only : pi8=>pi
   use M_units, only : e,euler,golden_ratio,deg_per_rad,rad_per_deg
   use M_units, only : c__m_per_sec, c__ft_per_sec
   !!
   implicit none
   real pi
   pi=pi8
   write(*,*)r2d([0.0,PI/4.0,PI/2.0,3.0*PI/2.0,PI])
   write(*,*)d2r([0.0,45.0,90.0,135.0,180.0])
   write(*,*)f2c([-40.0,32.0,212.0])
   write(*,*)c2f([-40.0,0.0,100.0])
   write(*,*)PI
   write(*,*)E
   !!
   write(*,101) "Napier's constant (e) is about ",e
   write(*,101) "The Euler-Mascheroni constant (euler or gamma) is about ",euler
   write(*,101) "pi (pi) is about ",pi8
   write(*,101) "The Golden Ratio (golden_ratio) is about ",golden_ratio
   write(*,101) "Deg_Per_Rad is about ",Deg_Per_Rad
   write(*,101) "Rad_Per_Deg is about ",Rad_Per_Deg
   !!
   write(*,101) "Speed of light in a vacuum (m/sec)       ", c__m_per_sec
   write(*,101) "Speed of light in a vacuum (ft/sec)      ", c__ft_per_sec
   !!
   101 format(a,t57,g0)
   !!
   end program demo_M_units

  Results:

   >   0.00000000       45.0000000       90.0000000       270.000000       180.000000
   >   0.00000000      0.785398185       1.57079637       2.35619450       3.14159274
   >  -40.0000000       0.00000000       100.000000
   >  -40.0000000       32.0000000       212.000000
   >   3.14159274
   >   2.7182818284590451
   >Napier's constant (e) is about                          2.7182818284590451
   >The Euler-Mascheroni constant (euler or gamma) is about 0.57721566490153287
   >pi (pi) is about                                        3.1415926535897931
   >The Golden Ratio (golden_ratio) is about                1.6180339887498949
   >Deg_Per_Rad is about                                    57.295779513082323
   >Rad_Per_Deg is about                                    0.17453292519943295E-001
   >Speed of light in a vacuum (m/sec)                      299792458.00000000
   >Speed of light in a vacuum (ft/sec)                     983571056.00000000

$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_units
use M_anything,only : anyscalar_to_real, anyscalar_to_double
implicit none                        ! require all variables to be declared
private
!  common trigonometric functions using degrees instead of radians for units
      public sind
      public cosd
      public tand
      public asind
      public acosd
      public atand
      public atan2d
!  normalize angles
      public norm_angle_rad
      public norm_angle_deg
!  convert between degrees and radians
      public d2r
      public r2d
!  distance
      public feet_to_meters
      public meters_to_feet
!  weight
      public pounds_to_kilograms
!  convert between Celsius and Fahrenheit
      public f2c
      public c2f
!  convert between coordinate systems
      public cartesian_to_spherical
      public spherical_to_cartesian
      public cartesian_to_polar
      public polar_to_cartesian
!  tables
      public symbol2atomnum ! return atomic number given element symbol name
      public atomnum2symbol ! return element symbol given atomic number

      public test_suite_M_units
!===================================================================================================================================
      public is_even
      public is_nan
      public inf
      interface inf
         module procedure inf32, inf64, inf128
      end interface inf

      public nan
      interface nan
         module procedure nan32, nan64, nan128
      end interface nan
!===================================================================================================================================
!  constants

doubleprecision, parameter, private :: eighth_circle_rad_d  = atan(1.0d0)            ! pi/4
doubleprecision, parameter, private :: quarter_circle_rad_d = 2*eighth_circle_rad_d  ! pi/2
doubleprecision, parameter, private :: half_circle_rad_d    = 4*eighth_circle_rad_d  ! pi
doubleprecision, parameter, private :: circle_rad_d         = 8*eighth_circle_rad_d  ! 2pi

real, parameter, private :: eighth_circle_rad_r  = atan(1.0)              ! pi/4
real, parameter, private :: quarter_circle_rad_r = 2*eighth_circle_rad_r  ! pi/2
real, parameter, private :: half_circle_rad_r    = 4*eighth_circle_rad_r  ! pi
real, parameter, private :: circle_rad_r         = 8*eighth_circle_rad_r  ! 2pi

!===================================================================================================================================
integer, public, parameter :: DP = selected_real_kind(15)
real(kind=DP), public, parameter ::              &
!---------------------!------------------------------------------------------------
                      ! velocity of light in a vacuum
   c__m_per_sec       = 2.99792458d+8,                                            & ! m/sec
   c__ft_per_sec      = 9.83571056d+8,                                            & ! ft/sec
!---------------------!------------------------------------------------------------
                      ! "e" is the base of the natural logarithm system.
                      ! "e" was named in honor of Euler, but is known as Napier's constant.
   e                  = 2.71828182845904523536028747135266249775724709369995d+00, &
!---------------------!------------------------------------------------------------
   euler              = 0.577215664901532860606512090082402431042d+00,            &
!---------------------!------------------------------------------------------------
                      ! The Euler-Mascheroni constant is often denoted by a lower-case Gamma.  Gamma is defined as
                      ! Gamma = limit ( M -> Infinity ) ( Sum ( 1 <= N <= M ) 1 / N ) - Log ( M )
   gamma              = 0.577215664901532860606512090082402431042d+00,            &
!---------------------!------------------------------------------------------------
   pi                 = 3.14159265358979323846264338327950288419716939937510d0,   &
!---------------------!------------------------------------------------------------
                      ! for two values A+B is to A as A is to B
   Golden_Ratio       = 1.6180339887498948482045868_DP,                           &
!---------------------!------------------------------------------------------------
   Deg_Per_Rad        = 57.2957795130823208767981548_DP,                          &
   Rad_Per_Deg        = 0.01745329251994329576923691_DP,                          &
   degrees_to_radians = PI / 180.0D+00,                                           &
!---------------------!------------------------------------------------------------
   end=99999    ! END OF CONSTANTS
!===================================================================================================================================

   interface norm_angle_deg                                  ! a Generic Interface in a module with PRIVATE specific procedures
      module procedure norm_angle_deg_real, norm_angle_deg_double
      module procedure norm_angle_deg_integer
   end interface

   interface r2d
      module procedure r2d_d, r2d_r, r2d_i
   end interface

   interface d2r
      module procedure d2r_d
      module procedure d2r_r
      module procedure d2r_i
   end interface

contains
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file c2f.3m_units.man
NAME
   c2f(3f) - [M_units:TEMPERATURE] convert Celsius to Fahrenheit
   (LICENSE:PD)
SYNOPSIS
   elemental real function c2f(celsius)

    class(*),intent(in) :: celsius
DESCRIPTION
   Converts Celsius temperatures to Fahrenheit using the formula:

    fahrenheit=(celsius+40.0)*9.0/5.0 - 40.0
OPTIONS
   celsius    any standard scalar value supported by anyscalar_to_real(3f).
EXAMPLE
  Sample program

   program demo_c2f
   use M_units, only : c2f
   implicit none
      write(*,*)'With REAL array input    ', c2f([ -40.0, 0.0, 100.0 ])
      write(*,*)'With INTEGER array input ', c2f([ -40,   0,   100   ])
      write(*,*)'With DOUBLEPRECISION     ', c2f(-40.0d0),c2f(0.0d0),c2f(100.0d0)
   end program demo_c2f

  Results

   With REAL array input      -40.0000000       32.0000000       212.000000
   With INTEGER array input   -40.0000000       32.0000000       212.000000
   With DOUBLEPRECISION       -40.0000000       32.0000000       212.000000
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function c2f(celsius)
$@(#) M_units::c2f(3f): Convert celsius to fahrenheit
class(*),intent(in)           :: celsius        ! celsius value to convert to fahrenheit
   real                       :: celsius_local
   celsius_local=anyscalar_to_real(celsius)
   c2f=(celsius_local+40.0)*9.0/5.0 - 40.0         ! do the conversion
end function c2f
!***********************************************************************************************************************************
$BLOCK COMMENT -file f2c.3m_units.man
NAME
   f2c(3f) - [M_units:TEMPERATURE] convert Fahrenheit to Celsius
   (LICENSE:PD)
SYNOPSIS
   elemental real function f2c(fahrenheit)

    class(*),intent(in) :: fahrenheit
DESCRIPTION
   Converts Fahrenheit temperatures to Celsius using the formula:

    celsius=(fahrenheit+40.0)*5.0/9.0 - 40.0
OPTIONS
   fahrenheit    any standard scalar value supported by anyscalar_to_real(3f).
EXAMPLE
  Sample program

   program demo_f2c
   use M_units, only :  f2c
   implicit none
      write(*,*)'With REAL array input    ', f2c([ -40.0,32.0, 212.0 ])
      write(*,*)'With INTEGER array input ', f2c([ -40,  32,   212   ])
      write(*,*)'With DOUBLEPRECISION     ', f2c(-40.0d0),f2c(32.0d0),f2c(212.0d0)
   end program demo_f2c

  Results

   With REAL array input      -40.0000000       0.00000000       100.000000
   With INTEGER array input   -40.0000000       0.00000000       100.000000
   With DOUBLEPRECISION       -40.0000000       0.00000000       100.000000

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function f2c(fahrenheit)
$@(#) M_units::f2c(3f): Convert fahrenheit to celsius
class(*),intent(in)           :: fahrenheit     ! input fahrenheit to convert to celsius
   real                       :: fahrenheit_local
   fahrenheit_local=anyscalar_to_real(fahrenheit)
   f2c=(fahrenheit_local+40.0)*5.0/9.0 - 40.0      ! do the conversion
end function f2c
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file r2d.3m_units.man
NAME
   r2d(3f) - [M_units:TRIGONOMETRY] convert radians to degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function r2d(radians)

    class(*),intent(in) :: degrees
DESCRIPTION
   Converts radians to degrees using the formula:

    degrees=real(radians * 180.d0 / acos(-1.0d0))
OPTIONS
   radians    any standard scalar value supported by anyscalar_to_real(3f).
EXAMPLE
  Sample program

   program demo_r2d
   use M_units, only :  r2d
   use M_units, only : pi8=>pi
   implicit none
   real :: pi=real(pi8)
      write(*,*)'With REAL array input    ', r2d([ 0.0, PI/4.0, PI/2.0, 3.0*PI/2.0, PI ])
      write(*,*)'With INTEGER array input ', r2d([0,1,2,3,4])
      write(*,*)'With DOUBLEPRECISION     ', r2d(0.0d0),r2d(PI/4.0d0),r2d(PI/2.0d0),r2d(3.0d0*PI/2.0d0),r2d(PI)
   end program demo_r2d

  Results

    With REAL array input       0.00000000       45.0000000       90.0000000       270.000000       180.000000
    With INTEGER array input    0.00000000       57.2957802       114.591560       171.887344       229.183121
    With DOUBLEPRECISION        0.00000000       45.0000000       90.0000000       270.000000       180.000000
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental doubleprecision function r2d_i(iradians)

$@(#) M_units::r2d_i(3f): Convert radians to degrees

doubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians
integer,intent(in)           :: iradians        ! input radians to convert to degrees
   r2d_i=dble(iradians)/DEGREE ! do the conversion
end function r2d_i
!-----------------------------------------------------------------------------------------------------------------------------------
elemental doubleprecision function r2d_d(radians)

$@(#) M_units::r2d_d(3f): Convert radians to degrees

doubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians
doubleprecision,intent(in)           :: radians        ! input radians to convert to degrees
   r2d_d=radians / DEGREE ! do the conversion
end function r2d_d
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function r2d_r(radians)

$@(#) M_units::r2d_r(3f): Convert radians to degrees

doubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians
real,intent(in)           :: radians        ! input radians to convert to degrees
   r2d_r=radians / DEGREE ! do the conversion
end function r2d_r
!***********************************************************************************************************************************
$BLOCK COMMENT -file d2r.3m_units.man
NAME
   d2r(3f) - [M_units:TRIGONOMETRY] convert degrees to radians
   (LICENSE:PD)
SYNOPSIS
   elemental real function d2r(degrees)

    class(*),intent(in) :: radians
DESCRIPTION
   Converts degrees to radians using the formula:

    radians=real(degrees*acos(-1.0d0)/180.d0)
OPTIONS
   degrees    any standard scalar value supported by anyscalar_to_real(3f).
              This includes REAL, INTEGER, DOUBLEPRECISION, ... .
EXAMPLE
  Sample program

   program demo_d2r
   use M_units, only :  d2r
   implicit none
      write(*,*)'With REAL array input    ', d2r([0.0,45.0,90.0,135.0,180.0])
      write(*,*)'With INTEGER array input ', d2r([0,  45,  90,  135,  180  ])
      write(*,*)'With DOUBLEPRECISION     ', &
      & d2r(0.0d0),d2r(45.0d0),d2r(90.0d0),d2r(135.0d0),d2r(180.0d0)
   end program demo_d2r

  Results

   With REAL array input    0.00000 0.785398185 1.57079637 2.35619450 3.14159274
   With INTEGER array input 0.00000 0.785398185 1.57079637 2.35619450 3.14159274
   With DOUBLEPRECISION     0.00000 0.785398185 1.57079637 2.35619450 3.14159274

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function d2r_r(degrees)

$@(#) M_units::d2r_r(3f): Convert degrees to radians

real,intent(in)           :: degrees                ! input degrees to convert to radians
   d2r_r=dble(degrees)/Deg_Per_Rad                       ! do the unit conversion

end function d2r_r
!-----------------------------------------------------------------------------------------------------------------------------------
elemental doubleprecision function d2r_d(degrees)

$@(#) M_units::d2r_d(3f): Convert degrees to radians

doubleprecision,intent(in) :: degrees               ! input degrees to convert to radians
   d2r_d=degrees/Deg_Per_Rad                             ! do the unit conversion
end function d2r_d
!-----------------------------------------------------------------------------------------------------------------------------------
elemental doubleprecision function d2r_i(idegrees)

$@(#) M_units::d2r_i(3f): Convert degrees to radians

integer,intent(in) :: idegrees                      ! input degrees to convert to radians
   d2r_i=dble(idegrees)/Deg_Per_Rad                      ! do the unit conversion
end function d2r_i
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file sind.3m_units.man
NAME
   sind(3f) - [M_units:TRIGONOMETRY] calculate sine of value in degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function sind(degrees)

    class(*),intent(in) :: degrees
DESCRIPTION
   Calculate sine of input value in degrees

OPTIONS
   degrees    any standard scalar value supported by anyscalar_to_double(3f)

EXAMPLE
  Sample program

   program demo_sind
   use M_units, only :  sind
   implicit none
      write(*,*)'With REAL array input    ', sind([ 0.0, 15.0, 30.0, 45.0, &
                                           & 60.0, 75.0, 90.0, 180.0, 270.0 ])
      write(*,*)'With INTEGER array input ', sind([0,15,30,45,60,75,90,180,270])
      write(*,*)'With DOUBLEPRECISION     ',           &
         & sind(0.0d0),sind(15.0d0),sind(90.0/3.0d0),  &
         & sind(90.0/2.0d0),sind(60.0d0),sind(75.0d0), &
         & sind(90.0d0),sind(180.0d0),sind(270.0d0)
   end program demo_sind

  Results

   With REAL array input      0.00000000      0.258819044      0.500000000
                              0.707106829     0.866025448      0.965925813
                              1.00000000     -8.74227766E-08  -1.00000000
   With INTEGER array input   0.00000000      0.258819044      0.500000000
                              0.707106829     0.866025448      0.965925813
                              1.00000000      -8.74227766E-08  -1.00000000
   With DOUBLEPRECISION       0.00000000      0.258819044      0.500000000
                              0.707106829     0.866025448      0.965925813
                              1.00000000      -8.74227766E-08  -1.00000000

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function sind(angle_in_degrees)

$@(#) M_units::sind(3f): sin(3f) with degrees as input instead of radians

class(*),intent(in)  :: angle_in_degrees
real                 :: angle_in_degrees_local
   angle_in_degrees_local=anyscalar_to_double(angle_in_degrees)
   sind=sin(angle_in_degrees_local*degrees_to_radians)
end function sind
!***********************************************************************************************************************************
$BLOCK COMMENT -file cosd.3m_units.man
NAME
   cosd(3f) - [M_units:TRIGONOMETRY] calculate cosine of value in degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function cosd(degrees)

    class(*),intent(in) :: degrees
DESCRIPTION
   Calculate cosine of input value in degrees

OPTIONS
   degrees    any standard scalar value supported by anyscalar_to_double(3f).
EXAMPLE
  Sample program

   program demo_cosd
   use M_units, only :  cosd
   implicit none
      write(*,*)'With REAL array input    ', &
      & cosd([ 0.0, 15.0, 30.0, 45.0, 60.0, 75.0, 90.0, 180.0, 270.0 ])
      write(*,*)'With INTEGER array input ',  &
      & cosd([0,15,30,45,60,75,90,180,270])
      write(*,*)'With DOUBLEPRECISION     ',        &
      & cosd(0.0d0),cosd(15.0d0),cosd(90.0/3.0d0),  &
      & cosd(90.0/2.0d0),cosd(60.0d0),cosd(75.0d0), &
      & cosd(90.0d0),cosd(180.0d0),cosd(270.0d0)
   end program demo_cosd

  Results

    With REAL array input      1.00000000       0.965925813   0.866025448
                               0.707106769      0.499999970   0.258819073
                              -4.37113883E-08  -1.00000000    1.19248806E-08
    With INTEGER array input   1.00000000       0.965925813   0.866025448
                               0.707106769      0.499999970   0.258819073
                              -4.37113883E-08  -1.00000000    1.19248806E-08
    With DOUBLEPRECISION       1.00000000       0.965925813   0.866025448
                               0.707106769      0.499999970   0.258819073
                              -4.37113883E-08  -1.00000000    1.19248806E-08

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function cosd(angle_in_degrees)

$@(#) M_units::cosd(3f): cos(3f) with degrees as input instead of radians

class(*),intent(in) :: angle_in_degrees
real                :: angle_in_degrees_local
   angle_in_degrees_local=anyscalar_to_double(angle_in_degrees)
   cosd=cos(angle_in_degrees_local*degrees_to_radians)
end function cosd
!***********************************************************************************************************************************
$BLOCK COMMENT -file tand.3m_units.man
NAME
   tand(3f) - [M_units:TRIGONOMETRY] calculate tangent of value in degrees
   (LICENSE:PD)
SYNOPSIS
elemental real function tand(degrees)

    class(*),intent(in) :: degrees
DESCRIPTION
   Calculate tangent of input value in degrees

OPTIONS
   degrees    any standard scalar value supported by anyscalar_to_double(3f).
EXAMPLE
  Sample program

   program demo_tand
   use M_units, only :  tand
   implicit none
      write(*,*)'With REAL array input    ', &
        & tand([ 0.0, 15.0, 30.0, 45.0, 60.0, 75.0, 90.0, 180.0, 270.0 ])
      write(*,*)'With INTEGER array input ', &
        & tand([0,15,30,45,60,75,90,180,270])
      write(*,*)'With DOUBLEPRECISION     ', &
        & tand(0.0d0),tand(15.0d0),tand(90.0/3.0d0),tand(90.0/2.0d0),&
        & tand(60.0d0),tand(75.0d0),&
        & tand(90.0d0),tand(180.0d0),tand(270.0d0)
   end program demo_tand
  Results:

   With REAL array input    0.00000000   0.267949194   0.577350259
   1.00000000    1.73205078    3.73205090    1.63312395E+16
   -1.22464685E-16  5.44374649E+15
   With INTEGER array input  0.00000000   0.267949194   0.577350259
   1.00000000    1.73205078    3.73205090    1.63312395E+16
   -1.22464685E-16  5.44374649E+15
   With DOUBLEPRECISION    0.00000000   0.267949194   0.577350259
   1.00000000    1.73205078    3.73205090    1.63312395E+16
   -1.22464685E-16  5.44374649E+15

  Results

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function tand(angle_in_degrees)

$@(#) M_units::tand(3f): tan(3f) with degrees as input instead of radians

class(*),intent(in) :: angle_in_degrees
real                :: angle_in_degrees_local
   angle_in_degrees_local=anyscalar_to_double(angle_in_degrees)
   tand=tan(angle_in_degrees_local*degrees_to_radians)
end function tand
!***********************************************************************************************************************************
$BLOCK COMMENT -file asind.3m_units.man
NAME
   asind(3f) - [M_units:TRIGONOMETRY] calculate arcsine of value in degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function asind(value)

    class(*),intent(in) :: value
DESCRIPTION
   Calculate arcsine of input value in degrees. It converts the input
   value to radians from degrees and calls asin(3f).

OPTIONS
   value    any standard scalar value supported by anyscalar_to_double(3f)

EXAMPLE
  Sample program

   program demo_asind
   use M_units, only :  asind
   implicit none
      write(*, *)asind([ 0.0, 0.258819044, 0.5, 0.707106829, 0.866025448,  &
                      & 0.965925813, 1.0, -8.74227766E-08, -1.0 ])
   end program demo_asind

  Results

      0.0 15.0  30.0 45.0000038  60.00 75.0 90.0 -5.00895612E-06  -90.0

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function asind(x)

$@(#) M_units::asind(3f): asin(3f) with degrees as output instead of radians

class(*),intent(in) :: x
real                :: x_local
   x_local=anyscalar_to_double(x)
   asind=asin(x_local)/degrees_to_radians
end function asind
!***********************************************************************************************************************************
$BLOCK COMMENT -file acosd.3m_units.man
NAME
   acosd(3f) - [M_units:TRIGONOMETRY] calculate arccosine of value in degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function acosd(value)

    class(*),intent(in) :: value
DESCRIPTION
   Calculate arcsine of input value in degrees. It converts the input value
   from degrees to radians and calls acos(3f).

OPTIONS
   value    any standard scalar value supported by anyscalar_to_double(3f)

EXAMPLE
  Sample program

   program demo_acosd
   use M_units, only :  acosd, cosd
   implicit none
      write(*, *)       cosd(0.0),cosd(45.0),cosd(120.0),cosd(180.0),cosd(720.0)
      write(*, *)acosd([cosd(0.0),cosd(45.0),cosd(120.0),cosd(180.0),cosd(720.0) ])
   end program demo_acosd

  Results

      1.00000000      0.707106769     -0.500000000      -1.00000000       1.00000000
      0.00000000       45.0000000       120.000000       180.000000       0.00000000

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function acosd(x)

$@(#) M_units::acosd(3f): calculate arc-cos of angle in degrees

class(*),intent(in) :: x
real                :: x_local
   x_local=anyscalar_to_double(x)
   acosd=acos(x_local)/degrees_to_radians
end function acosd
!***********************************************************************************************************************************
$BLOCK COMMENT -file atand.3m_units.man
NAME
   atand(3f) - [M_units:TRIGONOMETRY] calculate arctangent of value in degrees
   (LICENSE:PD)
SYNOPSIS
   elemental real function atand(value)

    class(*),intent(in) :: value
DESCRIPTION
   Calculate arctangent of input value in degrees. It calls atan(3f) and
   converts the output to degrees from radians.

OPTIONS
   value    any standard scalar value supported by anyscalar_to_double(3f)

EXAMPLE

  Sample program:

   program demo_atand
   use M_units, only :  atand, tand
   implicit none
      write(*, *)       tand(0.0),tand(45.0),tand(120.0),tand(180.0),tand(720.0)
      write(*, *)atand([tand(0.0),tand(45.0),tand(120.0),tand(180.0),tand(720.0) ])
   end program demo_atand

  Results:

      0.00000000       1.00000000      -1.73205078      -1.22464685E-16  -4.89858741E-16
      0.00000000       45.0000000      -60.0000000      -7.01670955E-15  -2.80668382E-14

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function atand(x)

$@(#) M_units::atand(3f): result is arc-tangent of angle in degrees

class(*),intent(in) :: x
real                :: x_local
   x_local=anyscalar_to_double(x)
   atand=atan(x_local)/degrees_to_radians
end function atand
!***********************************************************************************************************************************
$BLOCK COMMENT -file atan2d.3m_units.man
NAME
   atan2d(3f) - [M_units:TRIGONOMETRY] calculate arctangent of the complex number X + i Y
   (LICENSE:PD)
SYNOPSIS
   elemental real function atan2d(x,y)

    class(*),intent(in) :: x
    class(*),intent(in) :: y
DESCRIPTION
   Calculate arctangent of arctangent of the complex number

      X + i Y.

   in degrees. It calls atan2(3f) and converts the output from radians to degrees.

OPTIONS
   X    any standard scalar value supported by anyscalar_to_double(3f)
   Y    any standard scalar value supported by anyscalar_to_double(3f)

EXAMPLE
       Sample program:

          program demo_atan2d
          use M_units, only : atan2d
          real(4) :: x = 1.e0_4, y = 0.5e0_4
            write(*,*)atan2d(y,x)
          end program demo_atan2d
  Results:

      26.5650501

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
elemental real function atan2d(x,y)

$@(#) M_units::atan2d(3f): calculate arc-tangent of angle in degrees

class(*),intent(in) :: x
class(*),intent(in) :: y
real                :: x_local
real                :: y_local
   x_local=anyscalar_to_double(x)
   y_local=anyscalar_to_double(y)
   atan2d=atan2(x_local,y_local)/degrees_to_radians
end function atan2d
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file feet_to_meters.3m_units.man
NAME
   feet_to_meters(3f) - [M_units:LENGTH] converts a measurement in feet to meters
   (LICENSE:PD)
SYNOPSIS
   elemental doubleprecision function feet_to_meters(feet)

    class(*),intent(in) :: feet
DESCRIPTION
   Converts feet to meters using the formula:

    meters = 0.0254 * 12.0 * feet
OPTIONS
   feet   any standard scalar value supported by anyscalar_to_real(3f).
          This at least includes REAL, INTEGER, and DOUBLEPRECISION.
EXAMPLE
  Sample program

   program demo_feet_to_meters
   use M_units, only : feet_to_meters
   implicit none
      write(*,*)'With REAL array input    ', &
              & feet_to_meters([ -1.0, 0.0, 1.0 ,1.0/12.0])
      write(*,*)'With INTEGER array input ', &
              & feet_to_meters([ -1,   0,   1   ])
      write(*,*)'With DOUBLEPRECISION     ', &
              & feet_to_meters(-1.0d0), &
              & feet_to_meters(0.0d0), &
              & feet_to_meters(1.0d0)
   end program demo_feet_to_meters

  Results

    With REAL array input     -0.304800004   0.00000000  0.304800004  2.54000016E-02
    With INTEGER array input  -0.304800004   0.00000000  0.304800004
    With DOUBLEPRECISION      -0.304800004   0.00000000  0.304800004

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
elemental function feet_to_meters(feet)
$@(#) M_units::feet_to_meters(3f): converts a measurement in feet to meters
class(*),intent(in)           :: feet                           ! the input length in feet.
doubleprecision               :: feet_to_meters                 ! OUTPUT, the corresponding length in meters.
doubleprecision               :: feet_local
   feet_local=anyscalar_to_double(feet)
   !!feet_to_meters = 0.0254 * 12.0 * feet_local
   feet_to_meters = 0.3048d0 * feet_local

end function feet_to_meters
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file meters_to_feet.3m_units.man
NAME
   meters_to_feet(3f) - [M_units:LENGTH] converts a measurement in meters to feet
   (LICENSE:PD)
SYNOPSIS
   elemental real function meters_to_feet(meters)

    class(*),intent(in) :: meters
DESCRIPTION
   Converts feet to meters using the formula:

    feet= meters/12.0/0.0254
OPTIONS
   feet   any standard scalar value supported by anyscalar_to_real(3f).
          This at least includes REAL, INTEGER, and DOUBLEPRECISION.
EXAMPLE
  Sample program

   program demo_meters_to_feet
   use M_units, only : meters_to_feet
   implicit none
      write(*,*)'With REAL array input    ', meters_to_feet([ -1.0, 0.0, 1.0 ])
      write(*,*)'With INTEGER array input ', meters_to_feet([ -1,   0,   1   ])
      write(*,*)'With DOUBLEPRECISION     ', meters_to_feet(-1.0d0),meters_to_feet(0.0d0),meters_to_feet(1.0d0)
   end program demo_meters_to_feet

  Results

    With REAL array input      -3.28083992       0.00000000       3.28083992
    With INTEGER array input   -3.28083992       0.00000000       3.28083992
    With DOUBLEPRECISION       -3.28083992       0.00000000       3.28083992

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
elemental function meters_to_feet(meters)
$@(#) M_units::meters_to_feet(3f): converts a measurement in meters to feet
class(*),intent(in)           :: meters                         ! the input length in meters.
doubleprecision               :: meters_to_feet                 ! OUTPUT, the corresponding length in feet.
   doubleprecision            :: meters_local
   meters_local=anyscalar_to_double(meters)
   meters_to_feet = meters_local/12.0d0/0.0254d0
end function meters_to_feet
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file cartesian_to_spherical.3m_units.man
NAME
    cartesian_to_spherical(3f) - [M_units:TRIGONOMETRY] convert Cartesian coordinates to ISO polar coordinates
    (LICENSE:PD)
SYNOPSIS
   subroutine cartesian_to_spherical(x,y,z,radius,inclination,azimuth)

    real,intent(in)  :: x,y,z
    real,intent(out) :: radius,inclination,azimuth

DESCRIPTION

    Convert a cartesian point <X,Y,Z> to ISO 8000-2:2009 polar coordinates <radius,
    inclination, azimuth> with angles in radians using the formulas

      radius=sqrt(x**2+y**2+z**2)
      inclination=acos(z/radius)
      azimuth=atan2(y,x)

OPTIONS
   X  The distance along the x-axis
   Y  The distance along the y-axis
   Z  The distance along the z-axis

RESULTS

   RADIUS       The radial distance from the origin (O) to the point (P)
   INCLINATION  The zenith angle in radians between the zenith reference direction
                (z-axis) and the line OP
   AZIMUTH      The azimuth angle in radians between the azimuth reference direction
                (x-axis) and the orthogonal projection of the line OP of the
                reference plane (x-y plane).

EXAMPLES
  examples of usage

   program demo_cartesian_to_spherical
   use M_units, only : cartesian_to_spherical
   implicit none
   real    :: x,y,z
   real    :: r,i,a
   integer :: ios
   INFINITE: do
      read(*,*,iostat=ios) x, y, z
      if(ios.ne.0)exit INFINITE
      call cartesian_to_spherical(x,y,z,r,i,a)
      write(*,*)'x=',x,' y=',y,' z=',z,'radius=',r,'inclination=',i,'azimuth=',a
   enddo INFINITE
   end program demo_cartesian_to_spherical
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
subroutine cartesian_to_spherical(x,y,z,radius,inclination,azimuth)
implicit none
$@(#) M_units::cartesian_to_spherical(3f): convert Cartesian coordinates to ISO polar coordinates
real,intent(in)  :: x,y,z
real,intent(out) :: radius,inclination,azimuth
   radius=sqrt(x**2+y**2+z**2)
   if(radius.eq.0)then
      inclination=0.0
      azimuth=0.0
   else
      inclination=acos(z/radius)
      azimuth=atan2(y,x)
   endif
end subroutine cartesian_to_spherical
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file spherical_to_cartesian.3m_units.man
NAME
    spherical_to_cartesian(3f) - [M_units:TRIGONOMETRY] convert ISO polar coordinates to Cartesian coordinates
    (LICENSE:PD)
SYNOPSIS
   subroutine spherical_to_cartesian(radius,inclination,azimuth,x,y,z)

    real,intent(in) :: radius,inclination,azimuth
    real,intent(out)  :: x,y,z

DESCRIPTION

    Convert ISO 8000-2:2009 polar coordinate <radius, inclination, azimuth> with
    angles in radians to cartesian point <X,Y,Z> using the formulas

      x=radius*sin(inclination)*cos(azimuth)
      y=radius*sin(inclination)*sin(azimuth)
      z=radius*cos(inclination)

OPTIONS

   RADIUS       The radial distance from the origin (O) to the point (P)
   INCLINATION  The zenith angle in radians between the zenith reference direction
                (z-axis) and the line OP
   AZIMUTH      The azimuth angle in radians between the azimuth reference direction
                (x-axis) and the orthogonal projection of the line OP of the
                reference plane (x-y plane).

RESULTS

   X  The distance along the x-axis
   Y  The distance along the y-axis
   Z  The distance along the z-axis

EXAMPLES
  examples of usage

   program demo_spherical_to_cartesian
   use M_units, only : spherical_to_cartesian
   implicit none
   real    :: x,y,z
   real    :: r,i,a
   integer :: ios
   INFINITE: do
      read(*,*,iostat=ios) x, y, z
      if(ios.ne.0)exit INFINITE
      call spherical_to_cartesian(r,i,a,x,y,z)
      write(*,*)'x=',x,' y=',y,' z=',z,'radius=',r,'inclination=',i,'azimuth=',a
   enddo INFINITE
   end program demo_spherical_to_cartesian
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
subroutine spherical_to_cartesian(radius,inclination,azimuth,x,y,z)
implicit none
$@(#) M_units::spherical_to_cartesian(3f): convert spherical coordinates to cartesian coordinates
real,intent(in) :: radius,inclination,azimuth
real,intent(out)  :: x,y,z
   if(radius.eq.0)then
      x=0.0
      y=0.0
      z=0.0
   else
      x=radius*sin(inclination)*cos(azimuth)
      y=radius*sin(inclination)*sin(azimuth)
      z=radius*cos(inclination)
   endif
end subroutine spherical_to_cartesian
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file cartesian_to_polar.3m_units.man
NAME
    cartesian_to_polar(3f) - [M_units:TRIGONOMETRY] convert Cartesian coordinates to polar coordinates
    (LICENSE:PD)
SYNOPSIS
   subroutine cartesian_to_polar(x,y,radius,inclination)

    real,intent(in)  :: y,z
    real,intent(out) :: radius,inclination

DESCRIPTION

    Convert a cartesian point <X,Y,Z> to polar coordinates <radius,
    inclination> with angles in radians using the formulas

      radius=sqrt(x**2+y**2)
      inclination=atan2(y,x)

OPTIONS
   X  The distance along the x-axis
   Y  The distance along the y-axis

RESULTS

   RADIUS       The radial distance from the origin (O) to the point (P)
   INCLINATION  The inclination angle in radians between the inclination reference direction
                (x-axis) and the orthogonal projection of the line OP of the
                reference plane (x-y plane).

EXAMPLES
  examples of usage

   program demo_cartesian_to_polar
   use M_units, only : cartesian_to_polar
   implicit none
   real    :: x,y
   real    :: r,i
   integer :: ios
   INFINITE: do
      read(*,*,iostat=ios) x, y
      if(ios.ne.0)exit INFINITE
      call cartesian_to_polar(x,y,r,i)
      write(*,*)'x=',x,' y=',y,'radius=',r,'inclination=',i
   enddo INFINITE
   end program demo_cartesian_to_polar
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
subroutine cartesian_to_polar(x,y,radius,inclination)
implicit none
$@(#) M_units::cartesian_to_polar(3f): convert Cartesian coordinates to polar coordinates
real,intent(in)  :: x,y
real,intent(out) :: radius,inclination
   radius=sqrt(x**2+y**2)
   if(radius.eq.0)then
      inclination=0.0
   else
      inclination=atan2(y,x)
   endif
end subroutine cartesian_to_polar
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file polar_to_cartesian.3m_units.man
NAME
    polar_to_cartesian(3f) - [M_units:TRIGONOMETRY] convert polar coordinates to Cartesian coordinates
    (LICENSE:PD)
SYNOPSIS
   subroutine polar_to_cartesian(radius,inclination,x,y)

    real,intent(in) :: radius,inclination
    real,intent(out)  :: x,y

DESCRIPTION

    Convert polar coordinate <radius, inclination > with
    angles in radians to cartesian point <X,Y> using the formulas

      x=radius*cos(inclination)
      y=radius*sin(inclination)

OPTIONS

   RADIUS       The radial distance from the origin (O) to the point (P)
   INCLINATION  The INCLINATION angle in radians between the inclination reference direction
                (x-axis) and the orthogonal projection of the line OP of the
                reference plane (x-y plane).

RESULTS

   X  The distance along the x-axis
   Y  The distance along the y-axis

EXAMPLES
  examples of usage

   program demo_polar_to_cartesian
   use M_units, only : polar_to_cartesian
   implicit none
   real    :: x,y
   real    :: r,i
   integer :: ios
   INFINITE: do
      write(*,'(g0)',advance='no')'Enter radius and inclination(in radians):'
      read(*,*,iostat=ios) r, i
      if(ios.ne.0)exit INFINITE
      call polar_to_cartesian(r,i,x,y)
      write(*,*)'x=',x,' y=',y,'radius=',r,'inclination=',i
   enddo INFINITE
   end program demo_polar_to_cartesian
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!----------------------------------------------------------------------------------------------------------------------------------
subroutine polar_to_cartesian(radius,inclination,x,y)
implicit none
$@(#) M_units::polar_to_cartesian(3f): convert polar coordinates to cartesian coordinates
real,intent(in) :: radius,inclination
real,intent(out)  :: x,y
   if(radius.eq.0)then
      x=0.0
      y=0.0
   else
      x=radius*cos(inclination)
      y=radius*sin(inclination)
   endif
end subroutine polar_to_cartesian
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file atomnum2symbol.3m_units.man
NAME
   atomnum2symbol(3f) - [M_units:SYMBOLS] return element symbol given atomic number
   (LICENSE:PD)
SYNOPSIS
  subroutine atomnum2symbol(atomnum,symbol)

   integer,intent(in)           :: atomnum
   character(len=2),intent(out) :: symbol

DESCRIPTION
   Given an atomic number in the range of 1 to 109 return the corresponding element symbol name

OPTIONS
   atomnum    an atomic number from 1 to 109

RETURNS
   symbol     two-character symbol name corresponding to atomic number ATOMNUM

EXAMPLE
  Sample program

   program demo_atomnum2symbol
   use M_units, only :  atomnum2symbol
   implicit none
   character(len=2)  :: name
   integer           :: i
   do i=1,109
      call atomnum2symbol(i,name)
      write(*,*)i,name
   enddo
   end program demo_atomnum2symbol

  Results:

       >   1 H
       >   2 He
       >   3 Li
       >   4 Be
       >   5 B
       >   6 C
       >   7 N
       >   8 O
       >   9 F
       >  10 Ne
       >  11 Na
       >  12 Mg
       >  13 Al
       >  14 Si
       >  15 P
       >  16 S
       >  17 Cl
       >  18 Ar
       >  19 K
       >  20 Ca
       >  21 Sc
       >  22 Ti
       >  23 V
       >  24 Cr
       >  25 Mn
       >  26 Fe
       >  27 Co
       >  28 Ni
       >  29 Cu
       >  30 Zn
       >  31 Ga
       >  32 Ge
       >  33 As
       >  34 Se
       >  35 Br
       >  36 Kr
       >  37 Rb
       >  38 Sr
       >  39 Y
       >  40 Zr
       >  41 Nb
       >  42 Mo
       >  43 Tc
       >  44 Ru
       >  45 Rh
       >  46 Pd
       >  47 Ag
       >  48 Cd
       >  49 In
       >  50 Sn
       >  51 Sb
       >  52 Te
       >  53 I
       >  54 Xe
       >  55 Cs
       >  56 Ba
       >  57 La
       >  58 Ce
       >  59 Pr
       >  60 Nd
       >  61 Pm
       >  62 Sm
       >  63 Eu
       >  64 Gd
       >  65 Tb
       >  66 Dy
       >  67 Ho
       >  68 Er
       >  69 Tm
       >  70 Yb
       >  71 Lu
       >  72 Hf
       >  73 Ta
       >  74 W
       >  75 Re
       >  76 Os
       >  77 Ir
       >  78 Pt
       >  79 Au
       >  80 Hg
       >  81 Tl
       >  82 Pb
       >  83 Bi
       >  84 Po
       >  85 At
       >  86 Rn
       >  87 Fr
       >  88 Ra
       >  89 Ac
       >  90 Th
       >  91 Pa
       >  92 U
       >  93 Np
       >  94 Pu
       >  95 Am
       >  96 Cm
       >  97 Bk
       >  98 Cf
       >  99 Es
       > 100 Fm
       > 101 Md
       > 102 No
       > 103 Lr
       > 104 Rf
       > 105 Db
       > 106 Sg
       > 107 Bh
       > 108 Hs
       > 109 Mt

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine atomnum2symbol(atomnum,symbol)
implicit none
$@(#) M_units::atomnum2symbol(3f): return element symbol given atomic number
integer,intent(in)           :: atomnum
character(len=2),intent(out) :: symbol
integer,parameter            :: nelements=109
character(len=2),save        :: symbols(nelements)

data symbols/                                                 &
& 'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ', 'F ', 'Ne', &
& 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl', 'Ar', 'K ', 'Ca', &
& 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', &
& 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y ', 'Zr', &
& 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', &
& 'Sb', 'Te', 'I ', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', &
& 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', &
& 'Lu', 'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', &
& 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', &
& 'Pa', 'U ', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', &
& 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt'/

   if(atomnum.lt.1.or.atomnum.gt.nelements)then
      write(*,*)'*atomnum2symbol* atomic number out of range (1 to 109) ',atomnum
      symbol='  '
   else
      symbol=symbols(atomnum)
   endif
end subroutine atomnum2symbol
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file symbol2atomnum.3m_units.man
NAME
   symbol2atomnum(3f) - [M_units:SYMBOLS] return atomic number given element symbol name
   (LICENSE:PD)
SYNOPSIS
  subroutine symbol2atomnum(symbol,atomnum)

   character(len=2),intent(in) :: symbol
   integer,intent(out)         :: atomnum

DESCRIPTION
   Given a two-character element symbol name return the corresponding atomic number

OPTIONS
   symbol     two-character symbol name corresponding to atomic number ATOMNUM

RETURNS
   atomnum    an atomic number from 1 to 109

EXAMPLE
  Sample program

   program demo_symbol2atomnum
   use M_units, only :  symbol2atomnum
   implicit none
   integer           :: atomnum
   character(len=2)  :: name
   name='Ne'
   call symbol2atomnum(name,atomnum)
   write(*,*)atomnum,name
   end program demo_symbol2atomnum

  Results:

   10 Ne

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine symbol2atomnum(symbol,atomnum)
implicit none
$@(#) M_units::symbol2atomnum(3f): return atomic number given element symbol name
character(len=2),intent(in) :: symbol
integer,intent(out)         :: atomnum
integer,parameter           :: nelements=109
integer                     :: i
character(len=2),save       :: symbols(nelements)

data symbols/                                                 &
& 'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ', 'F ', 'Ne', &
& 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl', 'Ar', 'K ', 'Ca', &
& 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', &
& 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y ', 'Zr', &
& 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', &
& 'Sb', 'Te', 'I ', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', &
& 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', &
& 'Lu', 'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', &
& 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', &
& 'Pa', 'U ', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', &
& 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt'/

FINDIT: block
   do i = 1,nelements
      if ( (symbol(1:1) .eq. symbols(i)(1:1)) .and. (symbol(2:2) .eq. symbols(i)(2:2)) )then
         atomnum=i
         exit FINDIT
      endif
   enddo
   write(*,*)'*symbol2atomnum* error: symbol not found :',symbol
   atomnum=0
endblock FINDIT
end subroutine symbol2atomnum
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$BLOCK COMMENT -file pounds_to_kilograms.3m_units.man
NAME
   pounds_to_kilograms(3f) - [M_units:MASS] - converts a measurement in pounds-mass to kilograms.
   (LICENSE:PD)

SYNOPSIS
   elemental function pounds_to_kilograms ( pounds )

    class(*),intent(in) ::  pounds
    doubleprecision     :: pounds_to_kilograms

DESCRIPTION
   Converts pounds-mass to kilograms using the formula:

      kilograms = 0.45359237 * pounds

   The pound (or more properly pound-mass) is a unit of mass used in the
   Imperial, United States Customary, and other systems of measurement. A
   number of different definitions have been used; the most common today
   is the international avoirdupois pound, which is legally defined as
   exactly 0.45359237 kilograms. The international standard symbol for
   the avoirdupois pound is lb (from the Roman "libra"); an alternative
   symbol is lbm).

OPTIONS
   POUNDS  The weight in pounds.
           POUNDS may be any standard scalar value supported by anyscalar_to_double(3f).
           This at least includes REAL, INTEGER, and DOUBLEPRECISION.
RETURN
   POUNDS_TO_KILOGRAMS   the corresponding weight in kilograms.
EXAMPLE
  Sample program

   program demo_pounds_to_kilograms
   use M_units, only : pounds_to_kilograms
   implicit none
      write(*,*)'REAL            ', pounds_to_kilograms(1.0)
      write(*,*)'INTEGER array   ', pounds_to_kilograms([ 0, 1, 100, 200 ])
      write(*,*)'DOUBLEPRECISION ', pounds_to_kilograms(1.0d0)
   end program demo_pounds_to_kilograms

  Typical Results

    REAL              0.45359237000000002
    INTEGER array     0.0000000000000000    0.45359237000000002
                     45.359237000000000    90.718474000000001
    DOUBLEPRECISION   0.45359237000000002

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental function pounds_to_kilograms ( pounds )
$@(#) M_units::pounds_to_kilograms(3f): converts a measurement in pounds to kilograms.
class(*),intent(in) :: pounds
   doubleprecision  :: pounds_to_kilograms
   doubleprecision  :: pounds_local
   pounds_local=anyscalar_to_double(pounds)
   pounds_to_kilograms = 0.45359237d0 * pounds_local
end function pounds_to_kilograms
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file norm_angle_rad.3m_units.man
NAME
   norm_angle_rad(3f) - [M_units:TRIGONOMETRY] Return input angle given in radians as angle between 0 and 2pi
   (LICENSE:PD)
SYNOPSIS
   elemental function norm_angle_rad(ang) result(rev)

   class(*), intent(in) :: ang
   doubleprecision      :: rev
DESCRIPTION
   Given an input angle specified in radians, normalize the value to fall in the
   range 0 to 2*pi radians.
OPTIONS
   ang  Input angle (radians). May be INTEGER, REAL, or DOUBLEPRECISION
RESULTS
   rev  Return input angle (radians) normalized to range 0>= REV <=2*pi radians
EXAMPLE
  Sample program:

   program demo_norm_angle_rad
   use M_units, only : norm_angle_rad
   implicit none
   real,parameter :: PI=4*atan(1.0)
   real           :: val
   integer        :: i
   do i=-2,2
      val=i*2*pi;   write(*,*)val,norm_angle_rad(val)
      val=i*pi;     write(*,*)val,norm_angle_rad(val)
      write(*,*)
   enddo
   write(*,*)norm_angle_rad([-PI/8.0,-PI/4.0,-PI/2.0,-PI,-0.0,PI/8.0,PI/4.0,PI/2.0,PI,0.0])
   end program demo_norm_angle_rad

  Results:

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental function norm_angle_rad(ang)

$@(#) M_units::norm_angle_rad(3fp): Return input angle (given in radians) as doubleprecision angle between 0 and 2pi radians
class(*), intent(in) :: ang
doubleprecision      :: ang_local
doubleprecision      :: norm_angle_rad
   ang_local=anyscalar_to_double(ang)
   norm_angle_rad = ang_local - dble(floor(ang_local/circle_rad_d)) * circle_rad_d
end function norm_angle_rad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$BLOCK COMMENT -file norm_angle_deg.3m_units.man
NAME
   norm_angle_deg(3f) - [M_units:TRIGONOMETRY] Return input angle given in degrees as angle between 0 and 360
   (LICENSE:PD)

SYNOPSIS
   elemental function norm_angle_deg(ang) result(rev)

    doubleprecision, intent(in) :: ang
    doubleprecision             :: rev
       or
    real, intent(in) :: ang
    real             :: rev
       or
    integer, intent(in) :: ang
    integer             :: rev

DESCRIPTION
   Given an input angle in degrees, normalize the value to fall in the
   range 0 to 360 degrees.

OPTIONS
   ang  Input angle (degrees)

RESULTS
   rev  Return input angle (degrees) normalized to range 0 to 360 degrees

EXAMPLE
  Sample program:

   program demo_norm_angle_deg
   use M_units, only : norm_angle_deg
   implicit none
   real,parameter :: PI=360
   real           :: val
   integer        :: i
   do i=-2,2
      val=i*2*pi;   write(*,*)val,norm_angle_deg(val)
      val=i*pi;     write(*,*)val,norm_angle_deg(val)
      val=i*pi/2;   write(*,*)val,norm_angle_deg(val)
      write(*,*)
   enddo
   end program demo_norm_angle_deg

  Results:

     -1440.00000       0.00000000
     -720.000000       0.00000000
     -360.000000       0.00000000

     -720.000000       0.00000000
     -360.000000       0.00000000
     -180.000000       180.000000

      0.00000000       0.00000000
      0.00000000       0.00000000
      0.00000000       0.00000000

      720.000000       0.00000000
      360.000000       0.00000000
      180.000000       180.000000

      1440.00000       0.00000000
      720.000000       0.00000000
      360.000000       0.00000000

LICENSE
   MIT License
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental function norm_angle_deg_class(ang)

$@(#) M_units:: norm_angle_deg_class(3fp): Returns angle in degrees between 0 and 360

class(*),intent(in) :: ang
doubleprecision     :: ang_local
doubleprecision     :: norm_angle_deg_class
ang_local=anyscalar_to_double(ang)
   norm_angle_deg_class = ang_local - dble(floor(ang_local/360.d0)) * 360.d0
end function norm_angle_deg_class
!===================================================================================================================================
elemental function norm_angle_deg_double(ang)

$@(#) M_units:: norm_angle_deg_double(3fp): Returns angle in degrees between 0 and 360

doubleprecision,intent(in) :: ang
doubleprecision            :: norm_angle_deg_double
   norm_angle_deg_double = norm_angle_deg_class(ang)
end function norm_angle_deg_double
!===================================================================================================================================
elemental function norm_angle_deg_real(ang)

$@(#) M_units:: norm_angle_deg_real(3fp): Returns angle in degrees between 0 and 360

real,intent(in) :: ang
real            :: norm_angle_deg_real
   norm_angle_deg_real = norm_angle_deg_class(ang)
end function norm_angle_deg_real
!===================================================================================================================================
elemental function norm_angle_deg_integer(ang)

$@(#) M_units:: norm_angle_deg_integer(3fp): Returns angle in degrees between 0 and 360

integer,intent(in) :: ang
integer            :: norm_angle_deg_integer
   norm_angle_deg_integer = norm_angle_deg_class(ang)
end function norm_angle_deg_integer
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$BLOCK COMMENT -file inf.3m_units.man
NAME
   inf(3f) - [M_units] return an inf (Infinity)
   (LICENSE:PD)
SYNOPSIS
   function inf(value)
   use,intrinsic :: iso_fortran_env, only: real32, real64, real128
   real(kind=real32|real64|real128) :: inf
   real(kind=real32|real64|real128) :: value
DESCRIPTION
   Return an inf (Infinity) value. The type returned will be the same
   kind as the passed value.
OPTIONS
   value  A real value whose kind is used to define the kind of the
          returned value.
RETURNS
   inf    returns an inf value ("Infinity") on platforms that support
          inf values. The kind is determined by the kind of the input
          value.
EXAMPLE
   Sample program

     program demo_inf
     use,intrinsic :: iso_fortran_env, only: real32, real64, real128
     use M_units, only : inf
     implicit none
     real(kind=real32)  :: r32
     real(kind=real64)  :: r64
     real(kind=real128) :: r128
     character(len=256) :: message
     integer            :: ios
        r32=inf(0.0_real32)
        r64=inf(0.0_real64)
        r128=inf(0.0_real128)
        write(*,*,iomsg=message,iostat=ios)r32,r64,r128
        if(ios.ne.0)write(*,*)trim(message)
        write(*,'(z0)',iomsg=message,iostat=ios)r32,r64,r128
        if(ios.ne.0)write(*,*)trim(message)
        write(*,'(g0)',iomsg=message,iostat=ios)r32,r64,r128
        if(ios.ne.0)write(*,*)trim(message)
        write(*,'(f3.1)',iomsg=message,iostat=ios)r32,r64,r128
        if(ios.ne.0)write(*,*)trim(message)
        write(*,'(f2.1)',iomsg=message,iostat=ios)r32,r64,r128
        if(ios.ne.0)write(*,*)trim(message)
     end program demo_inf
  Results:

    Infinity Infinity Infinity
   7F800000
   7FF0000000000000
   7FFF0000000000000000000000000000
   Inf
   Inf
   Inf
   Inf
   Inf
   Inf
   **
   **
   **

AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function inf32(value)
use,intrinsic :: iso_fortran_env, only: real32
implicit none

$@(#) M_units:: inf32(3fp): Returns an inf (Infinity) of type real32

character(len=3),save :: STRING='inf'
real(kind=real32) :: inf32,value
   read(STRING,*)inf32
end function inf32
!===================================================================================================================================
function inf64(value)
use,intrinsic :: iso_fortran_env, only: real64
implicit none

$@(#) M_units:: inf64(3fp): Returns an inf (Infinity) of type real64

character(len=3),save :: STRING='inf'
real(kind=real64) :: inf64,value
   read(STRING,*)inf64
end function inf64
!===================================================================================================================================
function inf128(value)
use,intrinsic :: iso_fortran_env, only: real128
implicit none

$@(#) M_units:: inf128(3fp): Returns an inf (Infinity) of type real128

character(len=3),save :: STRING='inf'
real(kind=real128) :: inf128,value
   read(STRING,*)inf128
end function inf128
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
program demo_inf
use ieee_arithmetic ! If your compiler supports ISO TR 15580 IEEE Arithmetic !use procedures from ieee_* modules.
implicit none
real,parameter :: inf = 1.0/0.0
   write(*,*)inf
   write(*,*)inf/huge(0.0)
   write(*,*)inf/inf
   write(*,*)2*inf/inf
   write(*,*)0.0/inf
   write(*,*)inf/0.0
   write(*,*)inf.eq.inf
   write(*,*)inf_ieee()
   write(*,*)inf_by_equivalence()
   write(*,*)inf_by_read()
   write(*,*)inf_divide_by_zero()
   write(*,*)inf_huge()
   write(*,*)inf_log()
contains
!===================================================================================================================================
real function inf_ieee()
   if (ieee_support_inf(0.0)) then
      inf_ieee = ieee_value(0.0,ieee_negative_inf)
   else
      inf_ieee=inf_by_read()
   endif
end function inf_ieee
!===================================================================================================================================
real function inf_by_equivalence()
integer,save :: infi
real,save    :: inf
equivalence (inf,infi) !stores two variable at the same address
data inf/z'7f800000'/ !Hex for +Infinity
   inf_by_equivalence=inf
end function inf_by_equivalence
!===================================================================================================================================
real function inf_by_read()
character(len=8),save :: infinity='infinity'
   read(infinity,*)inf_by_read
end function inf_by_read
!===================================================================================================================================
real function inf_divide_by_zero()
   inf_divide_by_zero=1.0/0.0
end function inf_divide_by_zero
!===================================================================================================================================
real function inf_huge()
real :: x
   x = huge(1.0)
   inf_huge = x + x
 end function inf_huge
!===================================================================================================================================
real function inf_log()
real :: x
! a nice mathematical way of reaching infinity as -log(0) that works nicely for complex variables
! It will work on IEEE compliant machines, if you do not enable FPE trapping. But if you work with infinities, it would be silly
! to do so.
   x=0.0
   inf_log=-log(x)
end function inf_log
!===================================================================================================================================
end program demo_inf
!===================================================================================================================================
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$BLOCK NULL
===========================================================================================
NOTE: The IEEE functions are not implemented as described in gfortran at this time. Revisit
===========================================================================================
Initialize a real array with NaNs

Fri, 08/28/2009 - 07:01

I have a subroutine which initializes an array of real numbers. At the end
of this subroutine, I want to make sure that all elements of the array
have been initialized. All real values are admissible initial values
(including signed infinity numbers, etc).

Is is possible to force all values of my array to be NaNs at the beginning
of the subroutine; then check at the end if there are any NaNs left
(using is_nan(3f)). How can I conveniently set my array elements to be NaNs?

   use, intrinsic :: IEEE_ARITHMETIC
   array = IEEE_VALUE(IEEE_QUIET_NAN)

   You can then use IEEE_IS_NAN to do the test.

PROGRAM TEST_NAN
USE,INTRINSIC :: IEEE_ARITHMETIC
IMPLICIT NONE
INTEGER,PARAMETER :: DP = SELECTED_REAL_KIND(10,100)
REAL(KIND=DP) R
R = IEEE_VALUE(IEEE_QUIET_NAN)
WRITE(*,*) R
END PROGRAM TEST_NAN

If your compiler doesn't support IEEE_ARITHMETIC, this makes a good
case for an upgrade.  For earlier compilers, you could generate a NaN
by TRANSFERing a z'....' constant, or by calling a function (as quick
and dirty as could be imagined) such as
function rnan(x)
!dir$ optimize:0
rnan = (x-x)/(x-x)
return

Fri, 08/28/2009 - 12:58

Quoting - tim18

Steve Lionel (Intel)

Fri, 08/28/2009 - 13:15

Version 10.1 included the module as a stub.

I do not recommend using the method here - the compiler is free to
optimize that into something unexpected. Use this instead:

! Quiet NAN, double precision.
REAL(8), PARAMETER :: D_QNAN = &
 TRANSFER((/ Z'00000000', Z'7FF80000' /),1.0_8)

Retired 12/31/2016

Olivier

program test_nan
use,intrinsic :: ieee_arithmetic, only : ieee_value, ieee_quiet_nan
implicit none
integer,parameter :: dp = selected_real_kind(10,100)
real(kind=dp) r
write(*,*)ieee_quiet_nan
   r = ieee_value(ieee_quiet_nan)
   write(*,*) r
end program test_nan

================================================================================

Stop program when NaN encountered

program main
implicit none
real :: x,y=4.5
if (.false.) x = 2.1 ! without this line g95 detects that x is not set
print*,"x = ",x
print*,"y = ",y
end program main

with g95     -Wall -Wextra -freal=nan xuninit.f90
and gfortran -Wall -finit-real=nan test_nan.f90

and running gives output

 x =  NaN
 y =  4.5



See the -ffpe-trap= option - that seems the appropriate one. However, when I tried it with "invalid", the program didn't stop, even when I changed "print y" into "print y+x". It does produce an error with x = sqrt(-y) for instance.

Don't know about g95.  But with gfortran, can you use IEEE arithmetic?  If yes, it is possible to check IEEE flags using IEEE_GET_FLAG procedure from IEEE_EXCEPTIONS intrinsic module and see if any are signalling:

-- begin code --
program p
   implicit none
   real :: x
   print *, " x = ", x
   stop
end program p
-- end code --

Compiled with -finit-real=snan option with GCC 6.0 development trunk, the above gives upon execution:

-- output --
  x =               NaN
Note: The following floating-point exceptions are signalling: IEEE_INVALID_FLAG

-- end output --

So one can then incorporate suitable checks in one's procedures to see if exceptions are raised or flags are signaling and take appropriate corrective action.

FortranFan

1/6/16

- show quoted text -

Forgot to add: I assume the need here is beyond the uninitialized variable issue.  For uninitialized variables, -Wuninitialized option will be the first thing to go using gfortran instead of -finit-real=snan.

Richard Maine

1/6/16

Jean-Baptiste Faure <j...@no-email-on-usenet.fr> wrote:

That is compiler and optimizer dependent. Compilers whose optimizers are
not particularly IEEE-aware are likely to get that wrong, depending on
optimization level. If you want to do an explicit test like that, I'd
generally recommend using something like IEEE_IS_NAN. AT the very least,
if you want to accomodate compilers that don't support the IEEE
intrinsics, and want to use a test like the one you mention, be sure to
isolate the test to a separate procedure. That facilitates changing the
procedure as needed for different environments. In some environments,
you could even have it invoke the IEEE intrinsic or a suitable compiler
dependent one (is_nan used to be a common extension). With it in a
separate procedure, you can also do things like turn off optimization
for just that procedure if that helps.

However, my impression was that Beliavsky was looking for something more
automated, which would throw an exception without him having to put
explicit checks all over the code. Otherwise, I'd have suggested
IEEE_IS_NAN to him. There is also IEEE_SET_HALTING_MODE, but that's more
for catching operations that might otherwise result in NAN; it doesn't
do much for things like NANs from initialization.

--
Richard Maine
email: last name at domain . net
dimnain: summer-triangle

$BLOCK END
!===================================================================================================================================
$BLOCK COMMENT -file nan.3m_units.man
NAME
   nan(3f) - [M_units] return a NaN (Not a number)
   (LICENSE:PD)
SYNOPSIS
   function nan(value)
   use,intrinsic :: iso_fortran_env, only: real32, real64, real128
   real(kind=real32|real64|real128) :: nan
   real(kind=real32|real64|real128) :: value
DESCRIPTION
   Return a NaN (Not a number) value. The type returned will be the same
   kind as the passed value.

   At some point, the IEEE interface should work, with something like

    use,intrinsic :: ieee_arithmetic, only : ieee_value, ieee_quiet_nan
    use,intrinsic :: ieee_arithmetic, only : ieee_support_nan

    if(IEEE_SUPPORT_NAN(x))then        ! Are IEEE NaNs supported?
       x=IEEE_VALUE(x,ieee_quiet_nan)  ! Generate an IEEE value.
    endif

OPTIONS
   value  A real value whose kind is used to define the kind of the
          returned value.
RETURNS
   nan    returns a Nan value ("Not a number") on platforms that support
          NaN values. The kind is determined by the kind of the input
          value.
EXAMPLE
  Sample program

   program demo_nan
   use,intrinsic :: iso_fortran_env, only: real32, real64, real128
   use M_units, only : nan
   implicit none
   real(kind=real32)  :: r32
   real(kind=real64)  :: r64
   real(kind=real128) :: r128
   character(len=256) :: message
   integer            :: ios

      r32=nan(0.0_real32)
      r64=nan(0.0_real64)
      r128=nan(0.0_real128)

      ! examples printing the NaN values
      ! list directed format
      write(*,*,iomsg=message,iostat=ios)r32,r64,r128
      if(ios.ne.0)write(*,*)trim(message)
      ! hexadecimal format to show different kinds
      write(*,'(*(z0,1x))',iomsg=message,iostat=ios)r32,r64,r128
      if(ios.ne.0)write(*,*)trim(message)
      ! G0 format
      write(*,'(*(g0,1x))',iomsg=message,iostat=ios)r32,r64,r128
      if(ios.ne.0)write(*,*)trim(message)
      ! if a specific numeric field is used
      write(*,'(*(f3.1,1x))',iomsg=message,iostat=ios)r32,r64,r128
      if(ios.ne.0)write(*,*)trim(message)
      ! if format is less than three characters
      write(*,'(*(f2.1,1x))',iomsg=message,iostat=ios)r32,r64,r128
      if(ios.ne.0)write(*,*)trim(message)

      ! an option to terminate a program when a NaN is encountered
      ! (if X is NaN the comparison with 0. is always false.)
      if (.not.(r32<=0.0) .and. .not.(r32>=0.0))then
         write(*,*)'found nan'
         stop
      endif

      ALT1: block
         integer :: x = 2143289344
         print *, transfer(x, 1.0)    ! prints "nan" on i686
      endblock ALT1

   end program demo_nan

  Results:

   NaN      NaN              NaN
   7FC00000 7FF8000000000000 7FFF8000000000000000000000000000
   NaN NaN NaN
   NaN NaN NaN
   ** ** **
    found nan

SEE ALSO
     IS_NAN(3f)
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function nan32(value)
use,intrinsic :: iso_fortran_env, only: real32
implicit none

$@(#) M_units:: nan32(3fp): Returns a NAN (Not a number) of type real32

character(len=3),save :: STRING='NaN'
real(kind=real32) :: nan32,value
   read(STRING,*)nan32
   ! (if X is NaN the comparison with 0. is always false.)
   !if ( (nan32<=0.0_real32) .or. (nan32>=0.0_real32) )then
   !   write(*,*)'nan(3f) did not produce a nan'
   !   stop
   !endif
end function nan32
!===================================================================================================================================
function nan64(value)
use,intrinsic :: iso_fortran_env, only: real64
implicit none

$@(#) M_units:: nan64(3fp): Returns a NAN (Not a number) of type real64

character(len=3),save :: STRING='NaN'
real(kind=real64) :: nan64,value
   read(STRING,*)nan64
   ! (if X is NaN the comparison with 0. is always false.)
   !if ( (nan64<=0.0_real64) .or. (nan64>=0.0_real64) )then
   !   write(*,*)'nan(3f) did not produce a nan'
   !   stop
   !endif
end function nan64
!===================================================================================================================================
function nan128(value)
use,intrinsic :: iso_fortran_env, only: real128
implicit none

!$@(#) M_units:: nan128(3fp): Returns a NAN (Not a number) of type real128

character(len=3),save :: STRING='NaN'
real(kind=real128) :: nan128,value
   read(STRING,*)nan128
   ! (if X is NaN the comparison with 0. is always false.)
   !if ( (nan128<=0.0_real128) .or. (nan128>=0.0_real128) )then
   !   write(*,*)'nan(3f) did not produce a nan'
   !   stop
   !endif
end function nan128
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$BLOCK COMMENT -file is_even.3m_units.man
NAME
   is_even(3f) - [M_units] determine if integer is even
   (LICENSE:PD)
SYNOPSIS
   elemental pure logical is_even(int)

    integer(kind=int8|int16|int32|int64) :: int
DESCRIPTION
    Determine if an integer is even or not.
OPTIONS
    int      The integer to test
RETURNS
    is_even  logical value is .true. if the input value INT is even
EXAMPLE
  simple example

    program demo_is_even
    use M_units, only : is_even
    implicit none
    integer :: i
       write(*,*)is_even(0)
       write(*,*)is_even(-1)
       write(*,*)is_even(-2)
       write(*,*)is_even(+1)
       write(*,*)is_even(+2)
       write(*,*)is_even([10,11,17,19,22])
       write(*,*)(is_even(i),i=-10,10)
    end program demo_is_even
  Expected output
    T
    F
    T
    F
    T
    T F F F T
    T F T F T F T F T F T F T F T F T F T F T
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental pure function is_even(ival)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64

$@(#) M_units::is_even(3f): determine if integer is  even

class(*),intent(in) :: ival
logical             :: is_even
select type(ival)
   type is (integer(kind=int8))  ; is_even = mod(ival, 2_int8)   == 0_int8
   type is (integer(kind=int16)) ; is_even = iand(ival, 1_int16) == 0_int16
   type is (integer(kind=int32)) ; is_even = iand(ival, 1_int32) == 0_int32
   type is (integer(kind=int64)) ; is_even = mod(ival, 2_int64)  == 0_int64
   end select
end function is_even
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$BLOCK COMMENT -file is_nan.3m_units.man
NAME
   is_nan(3f) - [M_units] determine if integer is a Nan (Not a Number) value
   (LICENSE:PD)
SYNOPSIS
   elemental pure logical is_nan(value)

    integer(kind=real32|real64|real128|complex) :: value
DESCRIPTION
    Determine if a real or complex value is a NaN (Not a Number) value
OPTIONS
    value   The value to test
EXAMPLE
  simple example

    program demo_is_nan
    use M_units, only : is_nan
    real :: x
    character(len=*),parameter   :: linei='Infinity'
    character(len=*),parameter   :: line='NaN'
    character(len=:),allocatable :: readable
    real,parameter :: arr(*)=[-100.0,100.0,huge(0.0)]
       readable=linei
       read(readable,*)x
       write(*,*)is_nan(x),x   ! note Infinity is not a Nan
       write(*,*)is_nan(-x),-x
       readable=line
       read(readable,*)x
       write(*,*)is_nan(x),x
       write(*,*)x==x,x  ! note Nan is never equal to another value
       write(*,*)is_nan(arr),arr
    end program demo_is_nan

  Expected results

    F         Infinity
    F        -Infinity
    T              NaN
    F              NaN
    F F F  -100.000000       100.000000       3.40282347E+38
AUTHOR
   John S. Urban
LICENSE
   Public Domain
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental pure function is_nan(x)
!!use IEEE_EXCEPTIONS, only : ieee_support_nan ! is IEEE NaNs supported?
use,intrinsic :: IEEE_ARITHMETIC, only : IEEE_IS_NAN       ! Determine if value is IEEE Not-a-Number.
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

$@(#) M_units::is_nan(3f): determine if value is  IEEE Not-a-Number

class(*),intent(in) :: x
logical             :: is_nan
   select type(x)
      type is (real(kind=real32));      is_nan=ieee_is_nan(x)
      type is (real(kind=real64));      is_nan=ieee_is_nan(x)
      type is (real(kind=real128));     is_nan=ieee_is_nan(x)
      type is (complex);                is_nan=ieee_is_nan(real(x)).and.ieee_is_nan(aimag(x))
      !!type is (complex);                is_nan=ieee_is_nan(x%re).and.ieee_is_nan(x%im)
   end select
end function is_nan
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine test_suite_M_units()
use M_framework__verify, only : unit_test_start,unit_test,unit_test_done,unit_test_good,unit_test_bad,unit_test_msg
use M_framework__verify, only : unit_test_level
use M_framework__msg,   only : str

!! test constants
   call testit_p('pi',      real(PI)      ,  real(3.141592653589793238462643383279500d0)  ,message='')
   call testit_p('e',       real(E)       ,  real(2.718281828459045235360d0)              ,message='')
   !!call testit_p('radian',  real(RADIAN)  ,  real(57.29577951310d0)                       ,message='')
   !!call testit_p('degree',  real(DEGREE)  ,  real(0.0174532925199430d0)                   ,message='')

!! setup
   call test_acosd()
   call test_asind()
   call test_atan2d()
   call test_atand()
   call test_atomnum2symbol()
   call test_c2f()
   call test_cartesian_to_polar()
   call test_cartesian_to_spherical()
   call test_cosd()
   call test_d2r()
   call test_f2c()
   call test_feet_to_meters()
   call test_meters_to_feet()
   call test_norm_angle_deg_double()
   call test_norm_angle_deg_integer()
   call test_norm_angle_deg_real()
   call test_norm_angle_rad()
   call test_polar_to_cartesian()
   call test_pounds_to_kilograms()
   call test_r2d()
   call test_sind()
   call test_spherical_to_cartesian()
   call test_symbol2atomnum()
   call test_tand()
   call test_inf()
   call test_nan()
   call test_is_nan()
   call test_is_even()
!! teardown
contains
!===================================================================================================================================
subroutine testit_p(label,value1,value2,message)
use M_anything,only : anyscalar_to_real, anyscalar_to_double
USE M_Compare_Float_Numbers
use M_framework__verify, only : accdig
use M_framework__verify, only : unit_test
class(*),intent(in) :: value1, value2
real                :: v1, v2
character(len=*)    :: label
character(len=*)    :: message
logical             :: stat
real                :: significant_digits
integer             :: ind
real                :: acurcy

   v1=anyscalar_to_real(value1)
   v2=anyscalar_to_real(value2)
   stat=v1 .EqualTo. v2

   if(.not.stat)then
!     INPUT ...
!     real,intent(in) :: x           ! First  of two real numbers to be compared.
!     real,intent(in) :: y           ! Second of two real numbers to be compared.
!     real,intent(in) :: digi0       ! Number of digits to be satisfied in relative tolerance.
!     OUTPUT ...
!     integer,intent(out) :: ind     ! = 0, If tolerance is     satisfied.
!                                    ! = 1, If tolerance is not satisfied.
!     real,intent(out) :: acurcy     ! = - LOG10 (ABS((X-Y)/Y)))
      significant_digits=int(log10(2.0**digits(0.0)))     ! MAXIMUM NUMBER OF SIGNIFICANT DIGITS IN A REAL NUMBER.
      call accdig (v1,v2,significant_digits-2,ACURCY,IND)
      if(ind.eq.0)stat=.true.
   endif
!-----------------------
 call unit_test(label,stat,label,v1,v2,trim(message),'accuracy=',acurcy,'asked for',int(significant_digits)-2,'digits')
end subroutine testit_p
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_nan()
use,intrinsic :: iso_fortran_env, only: real32, real64, real128
real(kind=real32) :: r32
real(kind=real64) :: r64
real(kind=real128) :: r128
   call unit_test_start('nan',msg='')
   ! (if X is NaN the comparison with 0.0 is always false.)
   r32=nan(0.0_real32)
   call unit_test('nan',.not.(r32<=0.0_real32) .and. .not.(r32>=0.0_real32),msg='real32')

   r64=nan(0.0_real64)
   call unit_test('nan',.not.(r64<=0.0_real64) .and. .not.(r64>=0.0_real64),msg='real64')

   r128=nan(0.0_real128)
   call unit_test('nan',.not.(r128<=0.0_real128) .and. .not.(r128>=0.0_real128),msg='real128')

   call unit_test_done('nan',msg='')
end subroutine test_nan
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_is_even()
logical,parameter     :: t=.true.
logical,parameter     :: f=.false.
   call unit_test_start('is_even',msg='')
   call unit_test('is_even', all(is_even([-10, 0, 1, 2, 3]).eqv.[t,t,f,t,f]), '-10, 0, 1, 2, 3')
   call unit_test_done('is_even',msg='')
end subroutine test_is_even
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_is_nan()
character(len=3),save :: line='NaN'
real                  :: x
logical,parameter     :: t=.true.
logical,parameter     :: f=.false.
   call unit_test_start('is_nan',msg='')
   read(line,*)x
call unit_test('is_nan', all(is_nan([x, 0.0,-0.0,-x,-100.0,100.0,huge(0.0)]).eqv.[t,f,f,t,f,f,f]),  &
        & 'checking',x,0,-x,-100.0,100.0,huge(0.0))
   call unit_test_done('is_nan',msg='')
end subroutine test_is_nan
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_inf()
   call unit_test_start('inf',msg='')
   !!call unit_test('inf', 0.eq.0, 'checking', 100)
   call unit_test_done('inf',msg='')
end subroutine test_inf
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_acosd()

   call unit_test_start('acosd',msg='')
   !!call unit_test('acosd', 0.eq.0, 'checking', 100)
   call unit_test_done('acosd',msg='')
end subroutine test_acosd
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_asind()

   call unit_test_start('asind',msg='')
   !!call unit_test('asind', 0.eq.0, 'checking', 100)
   call unit_test_done('asind',msg='')
end subroutine test_asind
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_atan2d()

   call unit_test_start('atan2d',msg='')
   !!call unit_test('atan2d', 0.eq.0, 'checking', 100)
   call unit_test_done('atan2d',msg='')
end subroutine test_atan2d
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_atand()

   call unit_test_start('atand',msg='')
   !!call unit_test('atand', 0.eq.0, 'checking', 100)
   call unit_test_done('atand',msg='')
end subroutine test_atand
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_atomnum2symbol()

   call unit_test_start('atomnum2symbol',msg='')
   !!call unit_test('atomnum2symbol', 0.eq.0, 'checking', 100)
   call unit_test_done('atomnum2symbol',msg='')
end subroutine test_atomnum2symbol
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_c2f()

   call unit_test_start('c2f',msg='')
   call testit_p('c2f',     c2f(0.0)   ,  32.0,message='')
   call testit_p('c2f',     c2f(100.0) , 212.0,message='')
   call testit_p('c2f',     c2f(-40.0) , -40.0,message='')
   call unit_test_done('c2f',msg='')
end subroutine test_c2f
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_cartesian_to_polar()

   call unit_test_start('cartesian_to_polar',msg='')
   !!call unit_test('cartesian_to_polar', 0.eq.0, 'checking', 100)
   call unit_test_done('cartesian_to_polar',msg='')
end subroutine test_cartesian_to_polar
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_cartesian_to_spherical()

use M_framework__verify,  only : accdig
implicit none
real    :: x=10.0,y=10.0,z=10.0
real    :: radius,inclination,azimuth
real    :: acurcy
integer :: ind1,ind2,ind3
   call unit_test_start('cartesian_to_spherical',msg='')

   ! 10,10,10 -> 17.32, 0.9553, 0.7854
   call cartesian_to_spherical(x,y,z,radius,inclination,azimuth)
   call accdig(radius,      17.3205090,   5.0,acurcy,ind1)
   call accdig(inclination,  0.955316663 ,5.0,acurcy,ind2)
   call accdig(azimuth,      0.785398185 ,5.0,acurcy,ind3)
   call unit_test('cartesian_to_spherical',all([ind1,ind2,ind3].eq.0),x,y,z,'to',radius,inclination,azimuth)

   call unit_test_done('cartesian_to_spherical') ! if got here without being stopped assume passed test
end subroutine test_cartesian_to_spherical
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_cosd()

real, allocatable :: values(:)
integer           :: i
values=[0.0, 30.0, 45.0, 60.0, 92.0, 120.0, 135.0, 150.0, 180.0, 210.0, 240.0, 273.0, 300.0, 330.0, 360.0, -45.0]
   call unit_test_start('cosd',msg='')
   do i=1,size(values)
      call testit_p('cosd', cosd(values(i)), cos(d2r(values(i))),message=str('value=',values(i)) )
   enddo
   call unit_test_done('cosd',msg='')

!  unit_test:       cosd  FAILED:cosd 6.12323426E-17 -4.37113883E-08 value= 90.0000000 accuracy= 0.00000000 asked for 6 digits
!  unit_test:       cosd  FAILED:cosd -1.83697015E-16 1.19248806E-08 value= 270.000000 accuracy= 0.00000000 asked for 6 digits
end subroutine test_cosd
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_d2r()

   call unit_test_start('d2r',msg='')

   call testit_p('d2r', d2r(    0.0)    , 0.0       ,message='real for 0')
   call testit_p('d2r', d2r(   45.0)    , PI/4.0    ,message='real for 45')
   call testit_p('d2r', d2r(  -45.0)    , -PI/4.0   ,message='real for -45')
   call testit_p('d2r', d2r(   90.0)    , PI/2      ,message='real for 90')
   call testit_p('d2r', d2r(  180.0)    , PI        ,message='real for 180')

   call testit_p('d2r', d2r(  0.0d0)    , 0.0d0     ,message='double for 0')
   call testit_p('d2r', d2r(  45.0d0)   , PI/4.0d0  ,message='double for 45')
   call testit_p('d2r', d2r(  -45.0d0)  , -PI/4.0d0 ,message='double for -45')
   call testit_p('d2r', d2r(  90.0d0)   , PI/2d0    ,message='double for 90')
   call testit_p('d2r', d2r(  180.0d0)  , PI        ,message='double for 180')

   call testit_p('d2r', d2r(    0)      , 0.0       ,message='integer for 0')
   call testit_p('d2r', d2r(   45)      , PI/4.0    ,message='integer for 45')
   call testit_p('d2r', d2r(  -45)      , -PI/4.0   ,message='integer for -45')
   call testit_p('d2r', d2r(   90)      , PI/2      ,message='integer for 90')
   call testit_p('d2r', d2r(  180)      , PI        ,message='integer for 180')

   call unit_test_done('d2r',msg='')

end subroutine test_d2r
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_f2c()

use M_framework__verify, only : unit_test_start,unit_test,unit_test_done,unit_test_good,unit_test_bad,unit_test_msg
use M_framework__verify, only : unit_test_level
   call unit_test_start('f2c',msg='')
   call testit_p('f2c',     f2c(32.0)  ,   0.0,message='')
   call testit_p('f2c',     f2c(212.0) , 100.0,message='')
   call testit_p('f2c',     f2c(-40.0) , -40.0,message='')
   call unit_test_done('f2c',msg='')
end subroutine test_f2c
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_feet_to_meters()
doubleprecision, parameter :: f2m=0.3048d0
   call unit_test_start('feet_to_meters',msg=' 0.3048')

   call unit_test('feet_to_meters', &
      & all(abs(feet_to_meters([ -1.0, 0.0, 1.0 ,1.0/12.0])- [-f2m, 0.0d0, f2m, 0.0254d0]).lt.0.00001),'real')
   call unit_test('feet_to_meters', &
      & all(abs(feet_to_meters([ -1,   0,   1   ])- [-f2m, 0.0d0, f2m]).lt.0.00001),'integer')
   call unit_test('feet_to_meters', &
      & all(abs([feet_to_meters(-1.0d0),feet_to_meters(0.0d0),feet_to_meters(1.0d0)]-[-f2m, 0.0d0, f2m]).lt.0.00001),'double')

   call unit_test_done('feet_to_meters',msg='')
end subroutine test_feet_to_meters

!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_meters_to_feet()
   doubleprecision, parameter :: m2f=3.2808398950131233595d0

   call unit_test_start('meters_to_feet',msg='3.2808398950131233595')

   call unit_test('meters_to_feet', &
     & all(abs(meters_to_feet([ -1.0, 0.0, 1.0 ])-[-m2f,0.0d0,m2f]).lt.0.00001d0),msg='real')
   call unit_test('meters_to_feet', &
     & all(abs(meters_to_feet([ -1,   0,   1   ])-[-m2f,0.0d0,m2f]).lt.0.00001d0) ,msg='integer')
   call unit_test('meters_to_feet', &
     & all(abs([meters_to_feet(-1d0),meters_to_feet(0.0d0),meters_to_feet(1.0d0)]-[-m2f,0.0d0,m2f]).lt.0.00001d0),msg='double')

   call unit_test_done('meters_to_feet',msg='')
end subroutine test_meters_to_feet
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_norm_angle_deg_double()

   call unit_test_start('norm_angle_deg_double',msg='')
   !!call unit_test('norm_angle_deg_double', 0.eq.0, 'checking', 100)
   call unit_test_done('norm_angle_deg_double',msg='')
end subroutine test_norm_angle_deg_double
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_norm_angle_deg_integer()

   call unit_test_start('norm_angle_deg_integer',msg='')
   !!call unit_test('norm_angle_deg_integer', 0.eq.0, 'checking', 100)
   call unit_test_done('norm_angle_deg_integer',msg='')
end subroutine test_norm_angle_deg_integer
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_norm_angle_deg_real()

   call unit_test_start('norm_angle_deg_real',msg='')
   !!call unit_test('norm_angle_deg_real', 0.eq.0, 'checking', 100)
   call unit_test_done('norm_angle_deg_real',msg='')
end subroutine test_norm_angle_deg_real
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_norm_angle_rad()

   call unit_test_start('norm_angle_rad',msg='')
   !!call unit_test('norm_angle_rad', 0.eq.0, 'checking', 100)
   call unit_test_done('norm_angle_rad',msg='')
end subroutine test_norm_angle_rad
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_polar_to_cartesian()

   call unit_test_start('polar_to_cartesian',msg='')
   !!call unit_test('polar_to_cartesian', 0.eq.0, 'checking', 100)
   call unit_test_done('polar_to_cartesian',msg='')
end subroutine test_polar_to_cartesian
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_pounds_to_kilograms()

   call unit_test_start('pounds_to_kilograms',msg='')
   call unit_test('pounds_to_kilograms',abs(pounds_to_kilograms(1.0)-0.45359237).lt.0.00001,'real')
   call unit_test('pounds_to_kilograms',any(abs(pounds_to_kilograms([ 0, 1, 100, 200 ])-&
      &[0.0, 0.45359237, 45.359237,90.718474]).lt.0.00001),'integer')
   call unit_test('pounds_to_kilograms',abs(pounds_to_kilograms(1.0d0)-0.45359237).lt.0.00001,'double')
   call unit_test_done('pounds_to_kilograms',msg='')
end subroutine test_pounds_to_kilograms
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_r2d()

real              :: x=real(PI)
doubleprecision   :: d=PI

   call unit_test_start('r2d',msg='')

   call testit_p('r2d', r2d(  0.0)      ,   0.0    ,message='real')
   call testit_p('r2d', r2d(  x/4)      ,  45.0    ,message='real')
   call testit_p('r2d', r2d( -x/4)      , -45.0    ,message='real')
   call testit_p('r2d', r2d(  x/2)      ,  90.0    ,message='real')
   call testit_p('r2d', r2d(  x)        , 180.0    ,message='real')

   call testit_p('r2d', r2d(  0.0d0)    ,   0.0d0  ,message='double')
   call testit_p('r2d', r2d(  d/4.0d0)  ,  45.0d0  ,message='double')
   call testit_p('r2d', r2d( -d/4.0d0)  , -45.0d0  ,message='double')
   call testit_p('r2d', r2d(  d/2.0d0)  ,  90.0d0  ,message='double')
   call testit_p('r2d', r2d(  d)        , 180.0d0  ,message='double')

   call testit_p('r2d', r2d(  0)        ,   0.0    ,message='integer')

   call unit_test_done('r2d',msg='')
end subroutine test_r2d
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_sind()

real, allocatable :: values(:)
integer           :: i
   values=[0.0, 30.0, 45.0, 60.0, 90.0, 120.0, 135.0, 150.0, 181.0, 210.0, 240.0, 270.0, 300.0, 330.0, 362.0, -45.0]
   call unit_test_start('sind',msg='')
   do i=1,size(values)
      call testit_p('sind',   sind(values(i))             ,  sin(d2r(values(i))),message=str('value=',values(i))  )
   enddo
   call unit_test_done('sind',msg='')
! unit_test:       sind  FAILED:sind 1.22464685E-16 -8.74227766E-08 value= 180.000000 accuracy= 0.00000000 asked for 6 digits
! unit_test:       sind  FAILED:sind -2.44929371E-16 1.74845553E-07 value= 360.000000 accuracy= 0.00000000 asked for 6 digits
end subroutine test_sind
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_spherical_to_cartesian()
use M_framework__verify,  only : accdig
implicit none
real    :: x,y,z
real    :: radius,inclination,azimuth
real    :: acurcy
integer :: ind1,ind2,ind3
   call unit_test_start('spherical_to_cartesian',msg='')

   radius=17.32; inclination=0.9553; azimuth=0.7854
   x=-9999; y=-9999; z=-9999;
   call spherical_to_cartesian(radius,inclination,azimuth,x,y,z)

   call accdig(x,10.0,4.0,acurcy,ind1)
   call accdig(y,10.0,4.0,acurcy,ind2)
   call accdig(z,10.0,4.0,acurcy,ind3)

   call unit_test('spherical_to_cartesian',all([ind1,ind2,ind3].eq.0),radius,inclination,azimuth,'to',x,y,z)

   call unit_test_done('spherical_to_cartesian',msg='')
end subroutine test_spherical_to_cartesian
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_symbol2atomnum()

   call unit_test_start('symbol2atomnum',msg='')
   !!call unit_test('symbol2atomnum', 0.eq.0, 'checking', 100)
   call unit_test_done('symbol2atomnum',msg='')
end subroutine test_symbol2atomnum
!TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
subroutine test_tand()
real, allocatable :: values(:)
integer                      :: i
   values=[0.0,30.0,45.0,60.0,92.0,120.0,135.0,150.0,183.0,210.0,240.0,273.0,300.0, 330.0, 362.0, -45.0]
   call unit_test_start('tand',msg='')
   do i=1,size(values)
      call testit_p('tand', tand(values(i)), tan(d2r(values(i))),message=str('value=',values(i)))
   enddo
   call unit_test_done('tand',msg='')
! unit_test:       tand  FAILED:tand 1.63312395E+16 -22877332.0 value= 90.0000000 accuracy= -8.85361290 asked for 6 digits
! unit_test:       tand  FAILED:tand -1.22464685E-16 8.74227766E-08 value= 180.000000 accuracy= 0.00000000 asked for 6 digits
! unit_test:       tand  FAILED:tand 5.44374649E+15 -83858280.0 value= 270.000000 accuracy= -7.81235218 asked for 6 digits
! unit_test:       tand  FAILED:tand -2.44929371E-16 1.74845553E-07 value= 360.000000 accuracy= 0.00000000 asked for 6 digits
end subroutine test_tand
!===================================================================================================================================
end subroutine test_suite_M_units
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_units
!***********************************************************************************************************************************
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!***********************************************************************************************************************************
$ENDIF
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$IFDEF C
/*================================================================================================================================*/
#include <math.h>
float d2r(float degrees) {
#ident "@(#)d2r(3c): Convert degrees to radians"
   return((degrees)*acos(-1.0)/180.0);
}
/*================================================================================================================================*/
#include <math.h>
float r2d(float radians) {
#ident "@(#)r2d(3c): Convert radians to degrees"
   return((radians)*180.0/acos(-1.0));
}
/*================================================================================================================================*/
$ENDIF
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$IFDEF PREP_TEST
   This begins the section that will be processed by prep. Typically it
   is called by
      prep -system -html -verbose -i M_units.HTML
   if $SYSTEM commands are trusted.

   This section typically contains unit tests of the modules, and
   special processing such as extracting a basic man(1) page from the
   documentation, extracting the code into a plain Fortran file for
   use as a download file for the web page, and any other special
   processing needed to support the MODULE code.

   make sure scratch directory exists
$SYSTEM mkdir -p tmp/
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$ENDIF
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$! 2015-09-13
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
             Fundamental Physical Constants --- Complete Listing


  From:  http://physics.nist.gov/constants



  Quantity                                                       Value                 Uncertainty           Unit
-----------------------------------------------------------------------------------------------------------------------------
{220} lattice spacing of silicon                            192.015 5714 e-12        0.000 0032 e-12          m
alpha particle-electron mass ratio                          7294.299 541 36          0.000 000 24
alpha particle mass                                         6.644 657 230 e-27       0.000 000 082 e-27       kg
alpha particle mass energy equivalent                       5.971 920 097 e-10       0.000 000 073 e-10       J
alpha particle mass energy equivalent in MeV                3727.379 378             0.000 023                MeV
alpha particle mass in u                                    4.001 506 179 127        0.000 000 000 063        u
alpha particle molar mass                                   4.001 506 179 127 e-3    0.000 000 000 063 e-3    kg mol^-1
alpha particle-proton mass ratio                            3.972 599 689 07         0.000 000 000 36
Angstrom star                                               1.000 014 95 e-10        0.000 000 90 e-10        m
atomic mass constant                                        1.660 539 040 e-27       0.000 000 020 e-27       kg
atomic mass constant energy equivalent                      1.492 418 062 e-10       0.000 000 018 e-10       J
atomic mass constant energy equivalent in MeV               931.494 0954             0.000 0057               MeV
atomic mass unit-electron volt relationship                 931.494 0954 e6          0.000 0057 e6            eV
atomic mass unit-hartree relationship                       3.423 177 6902 e7        0.000 000 0016 e7        E_h
atomic mass unit-hertz relationship                         2.252 342 7206 e23       0.000 000 0010 e23       Hz
atomic mass unit-inverse meter relationship                 7.513 006 6166 e14       0.000 000 0034 e14       m^-1
atomic mass unit-joule relationship                         1.492 418 062 e-10       0.000 000 018 e-10       J
atomic mass unit-kelvin relationship                        1.080 954 38 e13         0.000 000 62 e13         K
atomic mass unit-kilogram relationship                      1.660 539 040 e-27       0.000 000 020 e-27       kg
atomic unit of 1st hyperpolarizability                      3.206 361 329 e-53       0.000 000 020 e-53       C^3 m^3 J^-2
atomic unit of 2nd hyperpolarizability                      6.235 380 085 e-65       0.000 000 077 e-65       C^4 m^4 J^-3
atomic unit of action                                       1.054 571 800 e-34       0.000 000 013 e-34       J s
atomic unit of charge                                       1.602 176 6208 e-19      0.000 000 0098 e-19      C
atomic unit of charge density                               1.081 202 3770 e12       0.000 000 0067 e12       C m^-3
atomic unit of current                                      6.623 618 183 e-3        0.000 000 041 e-3        A
atomic unit of electric dipole mom.                         8.478 353 552 e-30       0.000 000 052 e-30       C m
atomic unit of electric field                               5.142 206 707 e11        0.000 000 032 e11        V m^-1
atomic unit of electric field gradient                      9.717 362 356 e21        0.000 000 060 e21        V m^-2
atomic unit of electric polarizability                      1.648 777 2731 e-41      0.000 000 0011 e-41      C^2 m^2 J^-1
atomic unit of electric potential                           27.211 386 02            0.000 000 17             V
atomic unit of electric quadrupole mom.                     4.486 551 484 e-40       0.000 000 028 e-40       C m^2
atomic unit of energy                                       4.359 744 650 e-18       0.000 000 054 e-18       J
atomic unit of force                                        8.238 723 36 e-8         0.000 000 10 e-8         N
atomic unit of length                                       0.529 177 210 67 e-10    0.000 000 000 12 e-10    m
atomic unit of mag. dipole mom.                             1.854 801 999 e-23       0.000 000 011 e-23       J T^-1
atomic unit of mag. flux density                            2.350 517 550 e5         0.000 000 014 e5         T
atomic unit of magnetizability                              7.891 036 5886 e-29      0.000 000 0090 e-29      J T^-2
atomic unit of mass                                         9.109 383 56 e-31        0.000 000 11 e-31        kg
atomic unit of mom.um                                       1.992 851 882 e-24       0.000 000 024 e-24       kg m s^-1
atomic unit of permittivity                                 1.112 650 056... e-10    (exact)                  F m^-1
atomic unit of time                                         2.418 884 326 509 e-17   0.000 000 000 014 e-17   s
atomic unit of velocity                                     2.187 691 262 77 e6      0.000 000 000 50 e6      m s^-1
Avogadro constant                                           6.022 140 857 e23        0.000 000 074 e23        mol^-1
Bohr magneton                                               927.400 9994 e-26        0.000 0057 e-26          J T^-1
Bohr magneton in eV/T                                       5.788 381 8012 e-5       0.000 000 0026 e-5       eV T^-1
Bohr magneton in Hz/T                                       13.996 245 042 e9        0.000 000 086 e9         Hz T^-1
Bohr magneton in inverse meters per tesla                   46.686 448 14            0.000 000 29             m^-1 T^-1
Bohr magneton in K/T                                        0.671 714 05             0.000 000 39             K T^-1
Bohr radius                                                 0.529 177 210 67 e-10    0.000 000 000 12 e-10    m
Boltzmann constant                                          1.380 648 52 e-23        0.000 000 79 e-23        J K^-1
Boltzmann constant in eV/K                                  8.617 3303 e-5           0.000 0050 e-5           eV K^-1
Boltzmann constant in Hz/K                                  2.083 6612 e10           0.000 0012 e10           Hz K^-1
Boltzmann constant in inverse meters per kelvin             69.503 457               0.000 040                m^-1 K^-1
characteristic impedance of vacuum                          376.730 313 461...       (exact)                  ohm
classical electron radius                                   2.817 940 3227 e-15      0.000 000 0019 e-15      m
Compton wavelength                                          2.426 310 2367 e-12      0.000 000 0011 e-12      m
Compton wavelength over 2 pi                                386.159 267 64 e-15      0.000 000 18 e-15        m
conductance quantum                                         7.748 091 7310 e-5       0.000 000 0018 e-5       S
conventional value of Josephson constant                    483 597.9 e9             (exact)                  Hz V^-1
conventional value of von Klitzing constant                 25 812.807               (exact)                  ohm
Cu x unit                                                   1.002 076 97 e-13        0.000 000 28 e-13        m
deuteron-electron mag. mom. ratio                           -4.664 345 535 e-4       0.000 000 026 e-4
deuteron-electron mass ratio                                3670.482 967 85          0.000 000 13
deuteron g factor                                           0.857 438 2311           0.000 000 0048
deuteron mag. mom.                                          0.433 073 5040 e-26      0.000 000 0036 e-26      J T^-1
deuteron mag. mom. to Bohr magneton ratio                   0.466 975 4554 e-3       0.000 000 0026 e-3
deuteron mag. mom. to nuclear magneton ratio                0.857 438 2311           0.000 000 0048
deuteron mass                                               3.343 583 719 e-27       0.000 000 041 e-27       kg
deuteron mass energy equivalent                             3.005 063 183 e-10       0.000 000 037 e-10       J
deuteron mass energy equivalent in MeV                      1875.612 928             0.000 012                MeV
deuteron mass in u                                          2.013 553 212 745        0.000 000 000 040        u
deuteron molar mass                                         2.013 553 212 745 e-3    0.000 000 000 040 e-3    kg mol^-1
deuteron-neutron mag. mom. ratio                            -0.448 206 52            0.000 000 11
deuteron-proton mag. mom. ratio                             0.307 012 2077           0.000 000 0015
deuteron-proton mass ratio                                  1.999 007 500 87         0.000 000 000 19
deuteron rms charge radius                                  2.1413 e-15              0.0025 e-15              m
electric constant                                           8.854 187 817... e-12    (exact)                  F m^-1
electron charge to mass quotient                            -1.758 820 024 e11       0.000 000 011 e11        C kg^-1
electron-deuteron mag. mom. ratio                           -2143.923 499            0.000 012
electron-deuteron mass ratio                                2.724 437 107 484 e-4    0.000 000 000 096 e-4
electron g factor                                           -2.002 319 304 361 82    0.000 000 000 000 52
electron gyromag. ratio                                     1.760 859 644 e11        0.000 000 011 e11        s^-1 T^-1
electron gyromag. ratio over 2 pi                           28 024.951 64            0.000 17                 MHz T^-1
electron-helion mass ratio                                  1.819 543 074 854 e-4    0.000 000 000 088 e-4
electron mag. mom.                                          -928.476 4620 e-26       0.000 0057 e-26          J T^-1
electron mag. mom. anomaly                                  1.159 652 180 91 e-3     0.000 000 000 26 e-3
electron mag. mom. to Bohr magneton ratio                   -1.001 159 652 180 91    0.000 000 000 000 26
electron mag. mom. to nuclear magneton ratio                -1838.281 972 34         0.000 000 17
electron mass                                               9.109 383 56 e-31        0.000 000 11 e-31        kg
electron mass energy equivalent                             8.187 105 65 e-14        0.000 000 10 e-14        J
electron mass energy equivalent in MeV                      0.510 998 9461           0.000 000 0031           MeV
electron mass in u                                          5.485 799 090 70 e-4     0.000 000 000 16 e-4     u
electron molar mass                                         5.485 799 090 70 e-7     0.000 000 000 16 e-7     kg mol^-1
electron-muon mag. mom. ratio                               206.766 9880             0.000 0046
electron-muon mass ratio                                    4.836 331 70 e-3         0.000 000 11 e-3
electron-neutron mag. mom. ratio                            960.920 50               0.000 23
electron-neutron mass ratio                                 5.438 673 4428 e-4       0.000 000 0027 e-4
electron-proton mag. mom. ratio                             -658.210 6866            0.000 0020
electron-proton mass ratio                                  5.446 170 213 52 e-4     0.000 000 000 52 e-4
electron-tau mass ratio                                     2.875 92 e-4             0.000 26 e-4
electron to alpha particle mass ratio                       1.370 933 554 798 e-4    0.000 000 000 045 e-4
electron to shielded helion mag. mom. ratio                 864.058 257              0.000 010
electron to shielded proton mag. mom. ratio                 -658.227 5971            0.000 0072
electron-triton mass ratio                                  1.819 200 062 203 e-4    0.000 000 000 084 e-4
electron volt                                               1.602 176 6208 e-19      0.000 000 0098 e-19      J
electron volt-atomic mass unit relationship                 1.073 544 1105 e-9       0.000 000 0066 e-9       u
electron volt-hartree relationship                          3.674 932 248 e-2        0.000 000 023 e-2        E_h
electron volt-hertz relationship                            2.417 989 262 e14        0.000 000 015 e14        Hz
electron volt-inverse meter relationship                    8.065 544 005 e5         0.000 000 050 e5         m^-1
electron volt-joule relationship                            1.602 176 6208 e-19      0.000 000 0098 e-19      J
electron volt-kelvin relationship                           1.160 452 21 e4          0.000 000 67 e4          K
electron volt-kilogram relationship                         1.782 661 907 e-36       0.000 000 011 e-36       kg
elementary charge                                           1.602 176 6208 e-19      0.000 000 0098 e-19      C
elementary charge over h                                    2.417 989 262 e14        0.000 000 015 e14        A J^-1
Faraday constant                                            96 485.332 89            0.000 59                 C mol^-1
Faraday constant for conventional electric current          96 485.3251              0.0012                   C_90 mol^-1
Fermi coupling constant                                     1.166 3787 e-5           0.000 0006 e-5           GeV^-2
fine-structure constant                                     7.297 352 5664 e-3       0.000 000 0017 e-3
first radiation constant                                    3.741 771 790 e-16       0.000 000 046 e-16       W m^2
first radiation constant for spectral radiance              1.191 042 953 e-16       0.000 000 015 e-16       W m^2 sr^-1
hartree-atomic mass unit relationship                       2.921 262 3197 e-8       0.000 000 0013 e-8       u
hartree-electron volt relationship                          27.211 386 02            0.000 000 17             eV
Hartree energy                                              4.359 744 650 e-18       0.000 000 054 e-18       J
Hartree energy in eV                                        27.211 386 02            0.000 000 17             eV
hartree-hertz relationship                                  6.579 683 920 711 e15    0.000 000 000 039 e15    Hz
hartree-inverse meter relationship                          2.194 746 313 702 e7     0.000 000 000 013 e7     m^-1
hartree-joule relationship                                  4.359 744 650 e-18       0.000 000 054 e-18       J
hartree-kelvin relationship                                 3.157 7513 e5            0.000 0018 e5            K
hartree-kilogram relationship                               4.850 870 129 e-35       0.000 000 060 e-35       kg
helion-electron mass ratio                                  5495.885 279 22          0.000 000 27
helion g factor                                             -4.255 250 616           0.000 000 050
helion mag. mom.                                            -1.074 617 522 e-26      0.000 000 014 e-26       J T^-1
helion mag. mom. to Bohr magneton ratio                     -1.158 740 958 e-3       0.000 000 014 e-3
helion mag. mom. to nuclear magneton ratio                  -2.127 625 308           0.000 000 025
helion mass                                                 5.006 412 700 e-27       0.000 000 062 e-27       kg
helion mass energy equivalent                               4.499 539 341 e-10       0.000 000 055 e-10       J
helion mass energy equivalent in MeV                        2808.391 586             0.000 017                MeV
helion mass in u                                            3.014 932 246 73         0.000 000 000 12         u
helion molar mass                                           3.014 932 246 73 e-3     0.000 000 000 12 e-3     kg mol^-1
helion-proton mass ratio                                    2.993 152 670 46         0.000 000 000 29
hertz-atomic mass unit relationship                         4.439 821 6616 e-24      0.000 000 0020 e-24      u
hertz-electron volt relationship                            4.135 667 662 e-15       0.000 000 025 e-15       eV
hertz-hartree relationship                                  1.519 829 846 0088 e-16  0.000 000 000 0090 e-16  E_h
hertz-inverse meter relationship                            3.335 640 951... e-9     (exact)                  m^-1
hertz-joule relationship                                    6.626 070 040 e-34       0.000 000 081 e-34       J
hertz-kelvin relationship                                   4.799 2447 e-11          0.000 0028 e-11          K
hertz-kilogram relationship                                 7.372 497 201 e-51       0.000 000 091 e-51       kg
inverse fine-structure constant                             137.035 999 139          0.000 000 031
inverse meter-atomic mass unit relationship                 1.331 025 049 00 e-15    0.000 000 000 61 e-15    u
inverse meter-electron volt relationship                    1.239 841 9739 e-6       0.000 000 0076 e-6       eV
inverse meter-hartree relationship                          4.556 335 252 767 e-8    0.000 000 000 027 e-8    E_h
inverse meter-hertz relationship                            299 792 458              (exact)                  Hz
inverse meter-joule relationship                            1.986 445 824 e-25       0.000 000 024 e-25       J
inverse meter-kelvin relationship                           1.438 777 36 e-2         0.000 000 83 e-2         K
inverse meter-kilogram relationship                         2.210 219 057 e-42       0.000 000 027 e-42       kg
inverse of conductance quantum                              12 906.403 7278          0.000 0029               ohm
Josephson constant                                          483 597.8525 e9          0.0030 e9                Hz V^-1
joule-atomic mass unit relationship                         6.700 535 363 e9         0.000 000 082 e9         u
joule-electron volt relationship                            6.241 509 126 e18        0.000 000 038 e18        eV
joule-hartree relationship                                  2.293 712 317 e17        0.000 000 028 e17        E_h
joule-hertz relationship                                    1.509 190 205 e33        0.000 000 019 e33        Hz
joule-inverse meter relationship                            5.034 116 651 e24        0.000 000 062 e24        m^-1
joule-kelvin relationship                                   7.242 9731 e22           0.000 0042 e22           K
joule-kilogram relationship                                 1.112 650 056... e-17    (exact)                  kg
kelvin-atomic mass unit relationship                        9.251 0842 e-14          0.000 0053 e-14          u
kelvin-electron volt relationship                           8.617 3303 e-5           0.000 0050 e-5           eV
kelvin-hartree relationship                                 3.166 8105 e-6           0.000 0018 e-6           E_h
kelvin-hertz relationship                                   2.083 6612 e10           0.000 0012 e10           Hz
kelvin-inverse meter relationship                           69.503 457               0.000 040                m^-1
kelvin-joule relationship                                   1.380 648 52 e-23        0.000 000 79 e-23        J
kelvin-kilogram relationship                                1.536 178 65 e-40        0.000 000 88 e-40        kg
kilogram-atomic mass unit relationship                      6.022 140 857 e26        0.000 000 074 e26        u
kilogram-electron volt relationship                         5.609 588 650 e35        0.000 000 034 e35        eV
kilogram-hartree relationship                               2.061 485 823 e34        0.000 000 025 e34        E_h
kilogram-hertz relationship                                 1.356 392 512 e50        0.000 000 017 e50        Hz
kilogram-inverse meter relationship                         4.524 438 411 e41        0.000 000 056 e41        m^-1
kilogram-joule relationship                                 8.987 551 787... e16     (exact)                  J
kilogram-kelvin relationship                                6.509 6595 e39           0.000 0037 e39           K
lattice parameter of silicon                                543.102 0504 e-12        0.000 0089 e-12          m
Loschmidt constant (273.15 K, 100 kPa)                      2.651 6467 e25           0.000 0015 e25           m^-3
Loschmidt constant (273.15 K, 101.325 kPa)                  2.686 7811 e25           0.000 0015 e25           m^-3
mag. constant                                               12.566 370 614... e-7    (exact)                  N A^-2
mag. flux quantum                                           2.067 833 831 e-15       0.000 000 013 e-15       Wb
molar gas constant                                          8.314 4598               0.000 0048               J mol^-1 K^-1
molar mass constant                                         1 e-3                    (exact)                  kg mol^-1
molar mass of carbon-12                                     12 e-3                   (exact)                  kg mol^-1
molar Planck constant                                       3.990 312 7110 e-10      0.000 000 0018 e-10      J s mol^-1
molar Planck constant times c                               0.119 626 565 582        0.000 000 000 054        J m mol^-1
molar volume of ideal gas (273.15 K, 100 kPa)               22.710 947 e-3           0.000 013 e-3            m^3 mol^-1
molar volume of ideal gas (273.15 K, 101.325 kPa)           22.413 962 e-3           0.000 013 e-3            m^3 mol^-1
molar volume of silicon                                     12.058 832 14 e-6        0.000 000 61 e-6         m^3 mol^-1
Mo x unit                                                   1.002 099 52 e-13        0.000 000 53 e-13        m
muon Compton wavelength                                     11.734 441 11 e-15       0.000 000 26 e-15        m
muon Compton wavelength over 2 pi                           1.867 594 308 e-15       0.000 000 042 e-15       m
muon-electron mass ratio                                    206.768 2826             0.000 0046
muon g factor                                               -2.002 331 8418          0.000 000 0013
muon mag. mom.                                              -4.490 448 26 e-26       0.000 000 10 e-26        J T^-1
muon mag. mom. anomaly                                      1.165 920 89 e-3         0.000 000 63 e-3
muon mag. mom. to Bohr magneton ratio                       -4.841 970 48 e-3        0.000 000 11 e-3
muon mag. mom. to nuclear magneton ratio                    -8.890 597 05            0.000 000 20
muon mass                                                   1.883 531 594 e-28       0.000 000 048 e-28       kg
muon mass energy equivalent                                 1.692 833 774 e-11       0.000 000 043 e-11       J
muon mass energy equivalent in MeV                          105.658 3745             0.000 0024               MeV
muon mass in u                                              0.113 428 9257           0.000 000 0025           u
muon molar mass                                             0.113 428 9257 e-3       0.000 000 0025 e-3       kg mol^-1
muon-neutron mass ratio                                     0.112 454 5167           0.000 000 0025
muon-proton mag. mom. ratio                                 -3.183 345 142           0.000 000 071
muon-proton mass ratio                                      0.112 609 5262           0.000 000 0025
muon-tau mass ratio                                         5.946 49 e-2             0.000 54 e-2
natural unit of action                                      1.054 571 800 e-34       0.000 000 013 e-34       J s
natural unit of action in eV s                              6.582 119 514 e-16       0.000 000 040 e-16       eV s
natural unit of energy                                      8.187 105 65 e-14        0.000 000 10 e-14        J
natural unit of energy in MeV                               0.510 998 9461           0.000 000 0031           MeV
natural unit of length                                      386.159 267 64 e-15      0.000 000 18 e-15        m
natural unit of mass                                        9.109 383 56 e-31        0.000 000 11 e-31        kg
natural unit of mom.um                                      2.730 924 488 e-22       0.000 000 034 e-22       kg m s^-1
natural unit of mom.um in MeV/c                             0.510 998 9461           0.000 000 0031           MeV/c
natural unit of time                                        1.288 088 667 12 e-21    0.000 000 000 58 e-21    s
natural unit of velocity                                    299 792 458              (exact)                  m s^-1
neutron Compton wavelength                                  1.319 590 904 81 e-15    0.000 000 000 88 e-15    m
neutron Compton wavelength over 2 pi                        0.210 019 415 36 e-15    0.000 000 000 14 e-15    m
neutron-electron mag. mom. ratio                            1.040 668 82 e-3         0.000 000 25 e-3
neutron-electron mass ratio                                 1838.683 661 58          0.000 000 90
neutron g factor                                            -3.826 085 45            0.000 000 90
neutron gyromag. ratio                                      1.832 471 72 e8          0.000 000 43 e8          s^-1 T^-1
neutron gyromag. ratio over 2 pi                            29.164 6933              0.000 0069               MHz T^-1
neutron mag. mom.                                           -0.966 236 50 e-26       0.000 000 23 e-26        J T^-1
neutron mag. mom. to Bohr magneton ratio                    -1.041 875 63 e-3        0.000 000 25 e-3
neutron mag. mom. to nuclear magneton ratio                 -1.913 042 73            0.000 000 45
neutron mass                                                1.674 927 471 e-27       0.000 000 021 e-27       kg
neutron mass energy equivalent                              1.505 349 739 e-10       0.000 000 019 e-10       J
neutron mass energy equivalent in MeV                       939.565 4133             0.000 0058               MeV
neutron mass in u                                           1.008 664 915 88         0.000 000 000 49         u
neutron molar mass                                          1.008 664 915 88 e-3     0.000 000 000 49 e-3     kg mol^-1
neutron-muon mass ratio                                     8.892 484 08             0.000 000 20
neutron-proton mag. mom. ratio                              -0.684 979 34            0.000 000 16
neutron-proton mass difference                              2.305 573 77 e-30        0.000 000 85 e-30
neutron-proton mass difference energy equivalent            2.072 146 37 e-13        0.000 000 76 e-13
neutron-proton mass difference energy equivalent in MeV     1.293 332 05             0.000 000 48
neutron-proton mass difference in u                         0.001 388 449 00         0.000 000 000 51
neutron-proton mass ratio                                   1.001 378 418 98         0.000 000 000 51
neutron-tau mass ratio                                      0.528 790                0.000 048
neutron to shielded proton mag. mom. ratio                  -0.684 996 94            0.000 000 16
Newtonian constant of gravitation                           6.674 08 e-11            0.000 31 e-11            m^3 kg^-1 s^-2
Newtonian constant of gravitation over h-bar c              6.708 61 e-39            0.000 31 e-39            (GeV/c^2)^-2
nuclear magneton                                            5.050 783 699 e-27       0.000 000 031 e-27       J T^-1
nuclear magneton in eV/T                                    3.152 451 2550 e-8       0.000 000 0015 e-8       eV T^-1
nuclear magneton in inverse meters per tesla                2.542 623 432 e-2        0.000 000 016 e-2        m^-1 T^-1
nuclear magneton in K/T                                     3.658 2690 e-4           0.000 0021 e-4           K T^-1
nuclear magneton in MHz/T                                   7.622 593 285            0.000 000 047            MHz T^-1
Planck constant                                             6.626 070 040 e-34       0.000 000 081 e-34       J s
Planck constant in eV s                                     4.135 667 662 e-15       0.000 000 025 e-15       eV s
Planck constant over 2 pi                                   1.054 571 800 e-34       0.000 000 013 e-34       J s
Planck constant over 2 pi in eV s                           6.582 119 514 e-16       0.000 000 040 e-16       eV s
Planck constant over 2 pi times c in MeV fm                 197.326 9788             0.000 0012               MeV fm
Planck length                                               1.616 229 e-35           0.000 038 e-35           m
Planck mass                                                 2.176 470 e-8            0.000 051 e-8            kg
Planck mass energy equivalent in GeV                        1.220 910 e19            0.000 029 e19            GeV
Planck temperature                                          1.416 808 e32            0.000 033 e32            K
Planck time                                                 5.391 16 e-44            0.000 13 e-44            s
proton charge to mass quotient                              9.578 833 226 e7         0.000 000 059 e7         C kg^-1
proton Compton wavelength                                   1.321 409 853 96 e-15    0.000 000 000 61 e-15    m
proton Compton wavelength over 2 pi                         0.210 308 910 109 e-15   0.000 000 000 097 e-15   m
proton-electron mass ratio                                  1836.152 673 89          0.000 000 17
proton g factor                                             5.585 694 702            0.000 000 017
proton gyromag. ratio                                       2.675 221 900 e8         0.000 000 018 e8         s^-1 T^-1
proton gyromag. ratio over 2 pi                             42.577 478 92            0.000 000 29             MHz T^-1
proton mag. mom.                                            1.410 606 7873 e-26      0.000 000 0097 e-26      J T^-1
proton mag. mom. to Bohr magneton ratio                     1.521 032 2053 e-3       0.000 000 0046 e-3
proton mag. mom. to nuclear magneton ratio                  2.792 847 3508           0.000 000 0085
proton mag. shielding correction                            25.691 e-6               0.011 e-6
proton mass                                                 1.672 621 898 e-27       0.000 000 021 e-27       kg
proton mass energy equivalent                               1.503 277 593 e-10       0.000 000 018 e-10       J
proton mass energy equivalent in MeV                        938.272 0813             0.000 0058               MeV
proton mass in u                                            1.007 276 466 879        0.000 000 000 091        u
proton molar mass                                           1.007 276 466 879 e-3    0.000 000 000 091 e-3    kg mol^-1
proton-muon mass ratio                                      8.880 243 38             0.000 000 20
proton-neutron mag. mom. ratio                              -1.459 898 05            0.000 000 34
proton-neutron mass ratio                                   0.998 623 478 44         0.000 000 000 51
proton rms charge radius                                    0.8751 e-15              0.0061 e-15              m
proton-tau mass ratio                                       0.528 063                0.000 048
quantum of circulation                                      3.636 947 5486 e-4       0.000 000 0017 e-4       m^2 s^-1
quantum of circulation times 2                              7.273 895 0972 e-4       0.000 000 0033 e-4       m^2 s^-1
Rydberg constant                                            10 973 731.568 508       0.000 065                m^-1
Rydberg constant times c in Hz                              3.289 841 960 355 e15    0.000 000 000 019 e15    Hz
Rydberg constant times hc in eV                             13.605 693 009           0.000 000 084            eV
Rydberg constant times hc in J                              2.179 872 325 e-18       0.000 000 027 e-18       J
Sackur-Tetrode constant (1 K, 100 kPa)                      -1.151 7084              0.000 0014
Sackur-Tetrode constant (1 K, 101.325 kPa)                  -1.164 8714              0.000 0014
second radiation constant                                   1.438 777 36 e-2         0.000 000 83 e-2         m K
shielded helion gyromag. ratio                              2.037 894 585 e8         0.000 000 027 e8         s^-1 T^-1
shielded helion gyromag. ratio over 2 pi                    32.434 099 66            0.000 000 43             MHz T^-1
shielded helion mag. mom.                                   -1.074 553 080 e-26      0.000 000 014 e-26       J T^-1
shielded helion mag. mom. to Bohr magneton ratio            -1.158 671 471 e-3       0.000 000 014 e-3
shielded helion mag. mom. to nuclear magneton ratio         -2.127 497 720           0.000 000 025
shielded helion to proton mag. mom. ratio                   -0.761 766 5603          0.000 000 0092
shielded helion to shielded proton mag. mom. ratio          -0.761 786 1313          0.000 000 0033
shielded proton gyromag. ratio                              2.675 153 171 e8         0.000 000 033 e8         s^-1 T^-1
shielded proton gyromag. ratio over 2 pi                    42.576 385 07            0.000 000 53             MHz T^-1
shielded proton mag. mom.                                   1.410 570 547 e-26       0.000 000 018 e-26       J T^-1
shielded proton mag. mom. to Bohr magneton ratio            1.520 993 128 e-3        0.000 000 017 e-3
shielded proton mag. mom. to nuclear magneton ratio         2.792 775 600            0.000 000 030
speed of light in vacuum                                    299 792 458              (exact)                  m s^-1
standard acceleration of gravity                            9.806 65                 (exact)                  m s^-2
standard atmosphere                                         101 325                  (exact)                  Pa
standard-state pressure                                     100 000                  (exact)                  Pa
Stefan-Boltzmann constant                                   5.670 367 e-8            0.000 013 e-8            W m^-2 K^-4
tau Compton wavelength                                      0.697 787 e-15           0.000 063 e-15           m
tau Compton wavelength over 2 pi                            0.111 056 e-15           0.000 010 e-15           m
tau-electron mass ratio                                     3477.15                  0.31
tau mass                                                    3.167 47 e-27            0.000 29 e-27            kg
tau mass energy equivalent                                  2.846 78 e-10            0.000 26 e-10            J
tau mass energy equivalent in MeV                           1776.82                  0.16                     MeV
tau mass in u                                               1.907 49                 0.000 17                 u
tau molar mass                                              1.907 49 e-3             0.000 17 e-3             kg mol^-1
tau-muon mass ratio                                         16.8167                  0.0015
tau-neutron mass ratio                                      1.891 11                 0.000 17
tau-proton mass ratio                                       1.893 72                 0.000 17
Thomson cross section                                       0.665 245 871 58 e-28    0.000 000 000 91 e-28    m^2
triton-electron mass ratio                                  5496.921 535 88          0.000 000 26
triton g factor                                             5.957 924 920            0.000 000 028
triton mag. mom.                                            1.504 609 503 e-26       0.000 000 012 e-26       J T^-1
triton mag. mom. to Bohr magneton ratio                     1.622 393 6616 e-3       0.000 000 0076 e-3
triton mag. mom. to nuclear magneton ratio                  2.978 962 460            0.000 000 014
triton mass                                                 5.007 356 665 e-27       0.000 000 062 e-27       kg
triton mass energy equivalent                               4.500 387 735 e-10       0.000 000 055 e-10       J
triton mass energy equivalent in MeV                        2808.921 112             0.000 017                MeV
triton mass in u                                            3.015 500 716 32         0.000 000 000 11         u
triton molar mass                                           3.015 500 716 32 e-3     0.000 000 000 11 e-3     kg mol^-1
triton-proton mass ratio                                    2.993 717 033 48         0.000 000 000 22
unified atomic mass unit                                    1.660 539 040 e-27       0.000 000 020 e-27       kg
von Klitzing constant                                       25 812.807 4555          0.000 0059               ohm
weak mixing angle                                           0.2223                   0.0021
Wien frequency displacement law constant                    5.878 9238 e10           0.000 0034 e10           Hz K^-1
Wien wavelength displacement law constant                   2.897 7729 e-3           0.000 0017 e-3           m K
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
!*********************************************************************************************************************************
!> \brief  Returns angle in radians between -pi and pi
!! \param ang  Input angle (radians)
function rev2(ang)
doubleprecision,intent(in) :: ang
doubleprecision            :: rev2
   rev2 = ang - dble(floor(ang/pi2)) * pi2
   if(rev2.gt.pi) rev2 = rev2 - pi2
end function rev2
!*********************************************************************************************************************************
!> \brief  Returns angle in radians between -pi and pi  --  single precision
!! \param ang  Input angle (radians)
function rrev2(ang)
   real, intent(in) :: ang
   real :: rrev2
   rrev2 = ang - real(floor(ang/rpi2)) * rpi2
   if(rrev2.gt.rpi) rrev2 = rrev2 - rpi2
end function rrev2
  !*********************************************************************************************************************************
  !> \brief  Returns angle in degrees between -180 and 180
  !! \param ang  Input angle (degrees)
  function rv180(ang)
    use SUFR_kinds, only: double
    implicit none
    real(double), intent(in) :: ang
    real(double) :: rv180
    rv180 = ang - floor(ang/360.0d0) * 360.0d0
    if(rv180.gt.180.d0) rv180 = rv180 - 360.0d0
  end function rv180
  !*********************************************************************************************************************************
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
/ dimensions
m                       *a*
kg                      *b*
sec                     *c*
coul                    *d*
candela                 *e*
dollar                  *f*
radian                  *g*
bit                     *h*
erlang                  *i*
degC                    *j*

/ constants

fuzz                    1
pi                      3.14159265358979323846
c                       2.997925+8 m/sec fuzz
g                       9.80665 m/sec2
au                      1.49597871+11 m fuzz
mole                    6.022169+23 fuzz
e                       1.6021917-19 coul fuzz
energy                  c2
force                   g
mercury                 1.33322+5 kg/m2-sec2
hg                      mercury

/ dimensionless

degree                  1|180 pi-radian
circle                  2 pi-radian
turn                    2 pi-radian
grade                   .9 degree
arcdeg                  1 degree
arcmin                  1|60 arcdeg
ccs                     1|36 erlang
arcsec                  1|60 arcmin

steradian               radian2
sphere                  4 pi-steradian
sr                      steradian

/ Time

second                  sec
s                       sec
minute                  60 sec
min                     minute
hour                    60 min
hr                      hour
day                     24 hr
da                      day
week                    7 day
year                    365.24219879 day fuzz
yr                      year
month                   1|12 year
ms                      millisec
us                      microsec

/ Mass

gram                    millikg
gm                      gram
mg                      milligram
metricton               kilokg

/ Avoirdupois

lb                      .45359237 kg
lbf                     lb g
ounce                   1|16 lb
oz                      ounce
dram                    1|16 oz
dr                      dram
grain                   1|7000 lb
gr                      grain
shortton                2000 lb
ton                     shortton
longton                 2240 lb

/ Apothecary

scruple                 20 grain
apdram                  60 grain
apounce                 480 grain
appound                 5760 grain

/ Length

meter                   m
cm                      centimeter
mm                      millimeter
km                      kilometer
nm                      nanometer
micron                  micrometer
angstrom                decinanometer

inch                    2.54 cm
in                      inch
foot                    12 in
feet                    foot
ft                      foot
yard                    3 ft
yd                      yard
rod                     5.5 yd
rd                      rod
mile                    5280 ft
mi                      mile

british                 1200|3937 m/ft
nmile                   1852m

acre                    4840 yd2

cc                      cm3
liter                   kilocc
ml                      milliliter

/ US Liquid

gallon                  231 in3
imperial                1.20095
gal                     gallon
quart                   1|4 gal
qt                      quart
pint                    1|2 qt
pt                      pint

floz                    1|16 pt
fldr                    1|8 floz

/ US Dry

dry                     268.8025 in3/gallon fuzz
peck                    8 dry-quart
pk                      peck
bushel                  4 peck
bu                      bushel

/ British

brgallon                277.420 in3 fuzz
brquart                 1|4 brgallon
brpint                  1|2 brquart
brfloz                  1|20 brpint
brpeck                  554.84 in3 fuzz
brbushel                4 brpeck

/ Energy Work

newton                  kg-m/sec2
nt                      newton
joule                   nt-m
cal                     4.1868 joule

/ Electrical

coulomb                 coul
ampere                  coul/sec
amp                     ampere
watt                    joule/sec
volt                    watt/amp
ohm                     volt/amp
mho                     /ohm
farad                   coul/volt
henry                   sec2/farad
weber                   volt-sec

/ Light

cd                      candela
lumen                   cd sr
lux                     cd sr/m2


/ PDP-11

baud                    bit/sec
byte                    8 bit
word                    2 byte
block                   512 byte
K                       1024 word
tc                      578 block
rktrack                 12 block
rkcylinder              2 rktrack
rk                      203 rkcylinder
rptrack                 10 block
rpcylinder              20 rptracks
rp                      406 rpcylinder
rftrack                 8 block
rfshoe                  8 rftrack
rfdisk                  16 rfshoe
rf                      2 rfdisk

/ Trivia

%                       1|100
admiraltyknot           6080 ft/hr
apostilb                cd/pi-m2
are                     1+2 m2
arpentcan               27.52 mi
arpentlin               191.835 ft
astronomicalunit        au
atmosphere              1.01325+5 nt/m2
atm                     atmosphere
atomicmassunit          1.66044-27 kg fuzz
amu                     atomicmassunit
bag                     94 lb
bakersdozen             13
bar                     1+5 nt/m2
barie                   1-1 nt/m2
barleycorn              1|3 in
barn                    1-28 m2
barrel                  42 gal
barye                   1-1 nt/m2
bev                     1+9 e-volt
biot                    10 amp
blondel                 cd/pi-m2
boardfoot               144 in3
bolt                    40 yd
bottommeasure           1|40 in
britishthermalunit      1.05506+3 joule fuzz
btu                     britishthermalunit
refrigeration           12000 btu/ton-hour
buck                    dollar
cable                   720 ft
caliber                 1-2 in
calorie                 cal
carat                   205 mg
cent                    centidollar
cental                  100 lb
centesimalminute        1-2 grade
centesimalsecond        1-4 grade
century                 100 year
cfs                     ft3/sec
chain                   66 ft
circularinch            1|4 pi-in2
circularmil             1-6|4 pi-in2
clusec                  1-8 mm-hg m3/s
coomb                   4 bu
cord                    128 ft3
cordfoot                cord
crith                   9.06-2 gm
cubit                   18 in
cup                     1|2 pt
curie                   3.7+10 /sec
dalton                  amu
decade                  10 yr
dioptre                 /m
displacementton         35 ft3
doppelzentner           100 kg
dozen                   12
drop                    .03 cm3
dyne                    cm-gm/sec2
electronvolt            e-volt
ell                     45 in
engineerschain          100 ft
engineerslink           100|100 ft
equivalentfootcandle    lumen/pi-ft2
equivalentlux   lumen/pi-m2
equivalentphot          cd/pi-cm2
erg                     cm2-gm/sec2
ev                      e-volt
faraday                 9.652+4 coul
fathom                  6 ft
fermi                   1-15 m
fifth                   4|5 qt
fin                     5 dollar
finger                  7|8 in
firkin                  9 gal
footcandle              lumen/ft2
footlambert             cd/pi-ft2
fortnight               14 da
franklin                3.33564-10 coul
frigorie                kilocal
furlong                 220 yd
galileo                 1-2 m/sec2
gamma                   1-9 weber/m2
gauss                   1-4 weber/m2
geodeticfoot            british-ft
geographicalmile        1852 m
gilbert                 7.95775-1 amp
gill                    1|4 pt
gross                   144
gunterschain            22 yd
hand                    4 in
hectare                 1+4 m2
hefnercandle            .92 cd
hertz                   /sec
hogshead                2 barrel
hd                      hogshead
homestead               1|4 mi2
horsepower              550 ft-lb-g/sec
hp                      horsepower
hyl                     gm force sec2/m
hz                      /sec
imaginarycubicfoot      1.4 ft3
jeroboam                4|5 gal
karat                   1|24
kcal                    kilocal
kcalorie                kilocal
kelvin                  degC
kev                     1+3 e-volt
key                     kg
khz                     1+3 /sec
kilderkin               18 gal
knot                    nmile/hr
lambert                 cd/pi-cm2
langley                 cal/cm2
last                    80 bu
league                  3 mi
lightyear               c-yr
line                    1|12 in
link                    66|100 ft
longhundredweight       112 lb
longquarter             28 lb
lusec                   1-6 mm-hg m3/s
mach                    331.46 m/sec
magnum                  2 qt
marineleague            3 nmile
maxwell                 1-8 weber
metriccarat             200 mg
mev                     1+6 e-volt
mgd                     megagal/day
mh                      millihenry
mhz                     1+6 /sec
mil                     1-3 in
millenium               1000 year
minersinch              1.5 ft3/min
minim                   1|60 fldr
mo                      month
mpg                     mile/gal
mph                     mile/hr
nail                    1|16 yd
nauticalmile            nmile
nit                     cd/m2
noggin                  1|8 qt
nox                     1-3 lux
ns                      nanosec
oersted                 2.5+2 pi-amp/m
oe                      oersted
pace                    36 in
palm                    3 in
parasang                3.5 mi
parsec                  au-radian/arcsec
pascal                  nt/m2
pc                      parsec
pennyweight             1|20 oz
percent                 %
perch                   rd
pf                      picofarad
phot                    lumen/cm2
pica                    1|6 in
pieze                   1+3 nt/m2
pipe                    4 barrel
point                   1|72 in
poise                   gm/cm-sec
pole                    rd
poundal                 ft-lb/sec2
pdl                     poundal
proof                   1|200
psi                     lb-g/in2
quarter                 9 in
quartersection          1|4 mi2
quintal                 100 kg
quire                   25
rad                     100 erg/gm
rankine                 1.8 kelvin
ream                    500
registerton             100 ft3
rehoboam                156 floz
rhe                     10 m2/nt-sec
rontgen                 2.58-4 curie/kg
rood                    1.21+3 yd2
rope                    20 ft
rutherford              1+6 /sec
rydberg                 1.36054+1 ev
sabin                   1 ft2
sack                    3 bu
seam                    8 bu
section                 mi2
shippington             40 ft3
shorthundredweight      100 lb
shortquarter            25 lb
siemens                 /ohm
sigma                   microsec
skein                   120 yd
skot                    1-3 apostilb
slug                    lb-g-sec2/ft
span                    9 in
spat                    4 pi sr
spindle                 14400 yd
square                  100 ft2
stere                   m3
sthene                  1+3 nt
stilb                   cd/cm2
stoke                   1-4 m2/sec
stone                   14 lb
strike                  2 bu
surveyfoot              british-ft
surveyorschain          66 ft
surveyorslink           66|100 ft
tablespoon              4 fldr
teaspoon                4|3 fldr
tesla                   weber/m2
therm                   1+5 btu
thermie                 1+6 cal
timberfoot              ft3
tnt                     4.6+6 m2/sec2
tonne                   1+6 gm
torr                    mm hg
township                36 mi2
tun                     8 barrel
water                   .22491|2.54 kg/m2-sec2
wey                     40 bu
weymass                 252 lb
Xunit                   1.00202-13m
k                       1.38047-16 erg/degC
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
! for unit conversions
!doubleprecision,parameter,public :: g                       9.80665             ! m/sec2
!doubleprecision,parameter,public :: e                       1.6021917-19        ! coul
!doubleprecision,parameter,public :: mercury                 1.33322+5           ! kg/m2-sec2
!doubleprecision,parameter,public :: year                    365.24219879        ! day fuzz
!doubleprecision,parameter,public :: lb                      .45359237           ! kg
!doubleprecision,parameter,public :: inch                    2.54                ! cm
!doubleprecision,parameter,public :: nmile                   1852                ! m
!doubleprecision,parameter,public :: acre                    4840                ! yd2
!doubleprecision,parameter,public :: gallon                  231                 ! in3
!doubleprecision,parameter,public :: imperial                1.20095             ! gallons
!doubleprecision,parameter,public :: au                      1.49597871+11
!doubleprecision,parameter,public :: mole                    6.022169+23
!doubleprecision,parameter,public :: brgallon                277.420             ! in3
!doubleprecision,parameter,public :: cal                     4.1868              ! joule
!doubleprecision,parameter,public :: atmosphere              1.01325+5           ! nt/m2
!doubleprecision,parameter,public :: atomicmassunit          1.66044-27          ! kg
!doubleprecision,parameter,public :: carat                   205                 ! mg
!doubleprecision,parameter,public :: faraday                 9.652+4             ! coul
!doubleprecision,parameter,public :: fathom                  6                   ! ft
!doubleprecision,parameter,public :: fermi                   1e-15               ! m

! Also see Table of Constants to 50 Places at: http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html

 integer, public, parameter :: DP = selected_real_kind(15)

 real(kind=DP), public, parameter::              &

 e_Recip      =  0.3678794411714423215955238_DP, &
 e_Squared    =  7.3890560989306502272304275_DP, &
 Log10_of_e   =  0.4342944819032518276511289_DP, &

 Euler_Log    = -0.5495393129816448223376617_DP, &
 Gamma_Log    = -0.5495393129816448223376617_DP, &

 Ln_2         =  0.6931471805599453094172321_DP, &
 Ln_10        =  2.3025850929940456840179915_DP, &
 Log10_of_2   =  0.3010299956639811952137389_DP, &

 pi_Ln        =  1.1447298858494001741434273_DP, &
 pi_Log10     =  0.4971498726941338543512683_DP, &
 pi_Over_2    =  1.5707963267948966192313217_DP, &
 pi_Over_3    =  1.0471975511965977461542145_DP, &
 pi_Over_4    =  0.7853981633974483096156608_DP, &
 pi_Recip     =  0.3183098861837906715377675_DP, &
 pi_Squared   =  9.8696044010893586188344910_DP, &
 pi_Sq_Root   =  1.7724538509055160272981675_DP, &

 Sq_Root_of_2 =  1.4142135623730950488016887_DP, &
 Sq_Root_of_3 =  1.7320508075688772935274463_DP

                Constant                                                       Decimal
1 Angstrom unit                                           10**(-8) cm
Avogadro's number                                         (6.0247+-.0002)x10**23/mole
                                                          (physical scale)
K (constant of gravitation)                               6.670x10**(-8)
                                                          (attraction in dynes between two gram masses one centimeter apart)
                                                          101.2 ft/min.
1 Knot                                                    1.688 ft/sec.
                                                          1.152mi/hr.

ln(2)                                                     0.69314 71805 59945 3

ln(10)                                                    2.30258 50929 94045 68402
log10(2)                                                  0.30102 99956 63981
log10(e)                                                  0.43429 44819 03251 82765
1 micron                                                  10**(-4) cm
Planck's constant                                         6.6254+-.0002x10**(-27) erg sec
mean radius of earth                                      3959 miles, 6317 km.
mean density of Terra                                     5.522 grams per cm**3
Specific heat of air at constant pressure                 0.238
Coefficient of expansion of gases                         0.003665
heat equivalent of vaporization of water                  535.9 cal. per gram.
heat equivalent of fusion of water                        79.24 cal. per gram.
Density of mercury at 0 degrees C                         13.59509 g. per cm3.
maximum density of water at 3.98 C                        0.999973 g. per cm3.
Velocity of sound in dry air at 0 C                       33.136 cm/sec = 1089 ft/sec.
Density of dry air at 0 C and 760 mm.                     0.001293 g. per cm3.
1 nautical mile                                           1 minute of arc on earth's surface at equator
Length of seconds pendulum at sea level, lat. 45 degrees  99.356 cm = 39.116 in.
1 degree of latitude at 40 degrees                        69 miles
Acceleration due to gravity at sea level, lat. 45 degrees 980.616 cm per sec per sec = 32.172 ft/sec2

CONFLICTING CONSTANTS:

    Gravitation Constant K = 6.664 x 10**-8 dynes between two gram masses one centimeter apart.
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
Useful constants

<center>
<table border="8" cellspacing="5" cellpadding="3" >
<caption> <b> Miscellaneous Constants</b></caption>
     <tr><th align=center> Constant                    </th><th align=center> Decimal                                      </th>
</tr><tr><td> 1 radian                                 </td><td> 57.29577 95131 degrees                       </td>
</tr><tr><td> PI                                       </td><td> 3.14159 26535 89793 23846 26433 83279 50     </td>
</tr><tr><td> velocity of light in a vacuum            </td><td> 2.99776x10**10 cm/sec<br>9.83514x10**8 ft/sec<br>186272 mi/sec</td>
</tr><tr><td> 1 Angstrom unit                          </td><td> 10**(-8) cm                                  </td>
</tr><tr><td> Avogadro's number                        </td><td> (6.0247+-.0002)x10**23/mole<br>(physical scale)</td>
</tr><tr><td> Degree                                   </td><td> 0.01745 32925 19943 radians                  </td>
</tr><tr><td> e                                        </td><td> 2.71828 18284 59045 23536                    </td>
</tr><tr><td> K (constant of gravitation)</td><td>6.670x10**(-8) <br> (attraction in dynes between two gram masses one centimeter apart)</td>
</tr><tr><td> 1 Knot                                   </td><td> 101.2 ft/min.<br>1.688 ft/sec.<br>1.152mi/hr.</td>
</tr><tr><td> ln(2)                                    </td><td> 0.69314 71805 59945 3                        </td>
</tr><tr><td> ln(10)                                   </td><td> 2.30258 50929 94045 68402                    </td>
</tr><tr><td> log10(2)                                 </td><td> 0.30102 99956 63981                          </td>
</tr><tr><td> log10(e)                                 </td><td> 0.43429 44819 03251 82765                    </td>
</tr><tr><td> 1 micron                                 </td><td> 10**(-4) cm                                  </td>
</tr><tr><td> Planck's constant                        </td><td> 6.6254+-.0002x10**(-27) erg sec              </td>
</tr><tr><td> mean radius of earth                     </td><td> 3959 miles, 6317 km.                         </td>
</tr><tr><td> mean density of Terra                    </td><td> 5.522 grams per cm**3                        </td>
</tr><tr><td> Specific heat of air at contant pressure </td><td> 0.238                                        </td>
</tr><tr><td> Coefficient of expansion of gases        </td><td> 0.003665                                     </td>
</tr><tr><td> heat equivalent of vaporization of water </td><td> 535.9 cal. per gram.                         </td>
</tr><tr><td> heat equivalent of fusion of water       </td><td> 79.24 cal. per gram.                         </td>
</tr><tr><td> Density of mercury at 0 degrees C        </td><td> 13.59509 g. per cm3.                         </td>
</tr><tr><td> maximum density of water at 3.98 C       </td><td> 0.999973 g. per cm3.                         </td>
</tr><tr><td> Velocity of sound in dry air at 0 C      </td><td> 33.136 cm/sec = 1089 ft/sec.                 </td>
</tr><tr><td> Density of dry air at 0 C and 760 mm.    </td><td> 0.001293 g. per cm3.                         </td>
</tr><tr><td> 1 nautical mile                          </td><td> 1 minute of arc on earth's surface at equator</td>
</tr><tr><td> Length of seconds pendulum at sea level, lat. 45 degrees  </td><td> 99.356 cm = 39.116 in.      </td>
</tr><tr><td> 1 degree of latitue at 40 degrees        </td><td> 69 miles                                     </td>
</tr><tr><td> Acceleration due to gravity at sea level, lat. 45 degrees </td><td> 980.616 cm per sec per sec = 32.172 ft/sec2  </td>
</tr><tr><td>                                          </td><td>                                              </td>
</tr><tr><td>                                          </td><td>                                              </td>
</tr>
</table>
</center>

<h4> CONFLICTING CONSTANTS: </h4>
<pre>
    Velocity of light in a vacuum = 2.99796*10**10 cm/sec = 983.571*10**6 ft/sec = 186,284 miles/second.
    Gravitation Constant K = 6.664 x 10**-8 dynes between two gram masses one centimeter apart.
</pre>

$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
