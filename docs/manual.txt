accdig (3m_framework__approx) - [M_framework__approx] compare two numbers only up to a specified number of digits (LICENSE:PD)
almost (3m_framework__approx) - [M_framework__approx] return true or false if two numbers agree up to specified number of digits (LICENSE:PD)
assert (3m_framework__msg) - [M_framework__msg] print filename, linenumber, and message to stderr and stop program (LICENSE:PD)
attr (3m_framework__attr) - [M_framework__attr] substitute escape sequences for HTML-like syntax in strings (LICENSE:MIT)
attr_mode (3m_framework__attr) - [M_framework__attr] select processing mode for output from attr(3f) (LICENSE:MIT)
attr_update (3m_framework__attr) - [M_framework__attr] update internal dictionary given keyword and value (LICENSE:MIT)
compare_float (3m_framework__approx) - [M_framework__approx] compare floating point values with adjustable tolerance. (LICENSE:PD)
fmt (3m_framework__msg) - [M_framework__msg] convert any intrinsic to a string using specified format (LICENSE:PD)
fstop (3m_framework__utility) - [M_framework__utility] call stop with both a number and a message (LICENSE:PD)
in_margin (3m_framework__approx) - [M_framework__approx] check if two reals are approximately equal using a relative margin
journal (3m_framework__journal) - [M_framework__journal] provides public message routine, no paging or graphic mode change (LICENSE:PD)
M_framework (3m_framework) - [M_framework::INTRO] unit test framework (LICENSE:PD)
M_framework__attr (3m_framework__attr) - [M_framework__attr::INTRO] control text attributes on terminals (LICENSE:MIT)
M_framework__journal (3m_framework__journal) - [M_framework__journal::INTRO] write program messages to stdout and/or a log file (LICENSE:PD)
M_framework__verify (3m_framework__verify) - [M_framework__verify::INTRO] unit test framework (LICENSE:PD)
pdec (3m_framework__msg) - [M_framework__msg] write out string with ASCII decimal equivalent vertically under it (LICENSE:PD)
set (3m_framework__msg) - [M_msg] set scalars from an array (LICENSE:PD)
significant (3m_framework__approx) - [M_framework__approx] round val to specified number of significant digits
stderr (3m_framework__msg) - [M_framework__msg] write message to stderr (LICENSE:PD)
str (3m_framework__msg) - [M_framework__msg] converts up to twenty standard scalar type values to a string (LICENSE:PD)
unit_test (3m_framework__verify) - [M_framework__verify] report if logical expression is true or false, optionally call command and/or stop program. (LICENSE:PD)
unit_test_end (3m_framework__verify) - [M_framework__verify] end test of procedure started by unit_test_start(3f) (LICENSE:PD)
unit_test_expected (3m_framework__verify) - [M_framework__verify] report if two scalar values of like type and kind are equal. (LICENSE:PD)
unit_test_mode (3m_framework__verify) - [M_framework__verify] set testing modes (LICENSE:PD)
unit_test_msg (3m_framework__verify) - [M_framework__verify] converts up to twenty standard scalar values to a message for unit testing (LICENSE:PD)
unit_test_start (3m_framework__verify) - [M_framework__verify] reset counters and start a new test block (LICENSE:PD)
unit_test_stop (3m_framework__verify) - [M_framework__verify] report tally of all checks and stop program (LICENSE:PD)
unit_test_system (3m_framework__verify) - [M_framework__verify] return status from system command (LICENSE:PD)
wrt (3m_framework__msg) - [M_framework__msg] write multiple scalar values to any number of files (LICENSE:PD)
M_framework(3m_framework)			     M_framework(3m_framework)



NAME
  M_framework(3f) - [M_framework::INTRO] unit test framework (LICENSE:PD)

SYNOPSIS
  M_framework(3f) is an aggregate of Fortran modules brought together to
  provide unit testing for Fortran; and is particularly well suited for use
  with the Fortran Package Manager (fpm).

  The support modules are useful for creating terminal messages, comparing
  expected values to results, writing logfiles and playback journals
  independant of unit testing as well.

  Typically unit testing can be integrated seamlessly into the fpm(1)
  subcommand "test" making unit testing from github/gitlab CD/CI utilities as
  simple as "fpm teet" in many cases.

   BASIC TIMING IS INCLUDED
  As well as the expected **pass/fail/skipped unit testing** report.  basic
  **timing information** can be produced by the unit testing module
  M_framework__verify(3f).

   HOOKS ARE PROVIDED TO EXTERNAL LOCAL APPLICATIONS
  M_framework(3f) comes with a unique hook that allows calling your own
  programs to integrate with local logging tools, report generators,
  spreadsheets or other local infrastructure. The example program "bookkeeper"
  is included that uses the hook to write example report data files:

   + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv),
   + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html)
   + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml)

  The hook can call any local program with an interface similar to
  "bookkeeper". This allows modifying the program for local needs such as
  sending e-mail alerts and so on without having to change the tests.

    MESSAGES CAN BE COMPOSED ALMOST LIKE LIST-DIRECTED I/O
  Messages can be composed of up to twenty scalar intrinsic variables,
  allowing freedom in writing messages akin to that of list-directed I/O; but
  simultaneously to a list of output units. This easily lets messages go to
  stdout or stderr and a file of the user's choosing as well. Output can even
  be sent to a scratch file, essentially creating a quiet mode.

     DESIGNED FOR INTEGRATION WITH FPM(1)
  In conjunction with fpm(1) it is easy to run the tests with the --runner
  option, allowing for integration with other utilities as well such as the
  GNU debugger gdb(1), valgrind(1), and other tools.

   PROGRAMS INCLUDED TO GENERATE SKELETON TEST PROGRAM
  Example programs are provided to create unit test skeleton programs to ease
  usage.

     EASILY USED WITH GITHUB CD/CI
  Example CD/CI scripts that can be used with github are in the .github/
  directory that assume your tests can by run by using "fpm test".

   MOTIVATION
  Including **unit testing** is strongly encouraged for any software package,
  but particularly when it is to be used in programming environments the
  package was not developed in.

  This is the typical case for public fpm(1) packages on github.

  Additionally the proposed rules for registered fpm(1) package repositories
  include requiring package candidates themselves only have external
  dependencies that are also registered repository packages ( of course
  wrappers of C libraries or other existing libraries cannot easily be
  conformed to this).

  As a result -- this project concentrates on tools for a procedural unit
  testing framework based on nothing but standard Fortran that specifically
  can be used as a remote fpm(1) dependency in fpm(1) packages that may reside
  in public github repositories.

  That is, it is designed to be integrated with the fpm(1) "test" subcommand
  as an external dependency. It is intended to have little or no other
  dependencies and ultimately become a registered fpm(1) package to aid in the
  development of the fpm(1) repository.

  That being said, it can be used standalone as well.

DESCRIPTION
  Unit testing allows you to automatically confirm changes are acceptable so
  you can quickly and confidently make and release changes. But many of the
  operations required for testing are useful generically. So this project is
  broken down into small general-purpose modules and one unit-testing-specific
  one.

  M_framework(3f) is composed of the following individual modules:

   + **M\_framework__msg** is a small module that in particular
     can convert a list of variables of any of the common default types
     to a string.

     It performs low-level operations that are often used by other larger
     modules so it is its own module to prevent circular dependencies.

   + **M\_framework__journal__** allows for creating log and journal files

   + **M\_framework__approx** contains routines for rounding and comparing
     floating-point values.

   + **M\_framework__help** provides for creating a standard simple
     interactive help facility

   + **M\_framework__verify** is at the heart of the collection and
     handles virtually all the unit-test-specific operations.

  The procedures can be used in a variety of ways. After using them for a long
  time my typical usage has changed completely several times.

  As part of private software there was little problem calling the procedures
  directly from within the modules where they resided; and even auto-detecting
  the routines (a naming convention of "test\_suite\_$NAME" was used). The
  routines were pre-installed on virtually all platforms so using them was no
  more a burden than say, calling an intrinsic.

  Put autodetecting tools (at least the ones employed) are not generally
  portable; and with public packages there is a strong incentive to minimize
  the amount of infrastructure and external dependencies. It is generally
  imperative to make package use as simple and generic as possible.

  So the suggested scheme is to create a small test program for each procedure
  or closely related procedures in the fpm test/ directory.

   + make a subroutine for each component to be tested
   + in each test procedure start it with a call to UNIT\_CHECK\_START(3f)
   + end each test procedure it with a call to UNIT\_CHECK\_END(3f)
   + make multiple calls to UNIT\_CHECK(3f) in-between to generate
     test results
   + call each of those test routines from the main program
   + end the main program with a call to UNIT\_CHECK\_STOP(3f)

  Optionally, before starting set preferred non-default modes.

  Use the 'fpm test' command to run specific tests; all tests (the default); a
  list of tests or test names using simple globbing.

  As desired, command line options can be used to control various test
  behaviors.

  As an example, we can create a skeleton program to test a few routines.
  Using

       fpm test_suite sqrt cos sin > test/test_suite.f90

  to create the skeleton program and then adding a few actual calls to
  unit\_test\_check(3f) results in

    Sample program:

     program M_test_suite_M_intrinsics
     use,intrinsic :: iso_fortran_env, only : &
     & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
     !
     use M_framework, only : unit_test_start,unit_test,unit_test_end, &
		      unit_test_mode, unit_test_level, unit_test_stop
     use M_framework, only : CHECK_PREFIX ! change column one of messages
     !
     !use M_mymodule ! load any modules you will be testing
     implicit none
     double precision,allocatable :: expected(:), answers(:), input(:)
     double precision,parameter :: PI=atan(1.0d0)*4
     !! setup
	!---------------------------------------------------
	!OPTIONAL:
	!  values used in prefix column for various messages
	!  the default is to set them all to the basename of
	!  the executable running tests, but they can be
	!  altered. For example:
	CHECK_PREFIX=prefix(		      &
	 check_MSG    =  'check_msg:   ', &
	 check	      =  'check:       ', &
	 check_START  =  'check_start: ', &
	 check_STOP   =  'check_stop:  ', &
	 check_END    =  'check_end:   '  &
	)
	!---------------------------------------------------
	!OPTIONAL:
	! the options available at run-time on the command
	! line can have their defaults selected. See the
	! man-page for the procedure for details.
	call unit_check_mode(
	  ( keep_going=.true. ,
	  flags=[character(len=0) ::],
	  luns=[stdout],
	  command, &
	  brief=.false. ,
	  interactive=.false. ,
	  CMDLINE='',
	  debug=.false. ,
	  match
	  )
	!---------------------------------------------------
     !! test each subroutine
	call test_sqrt()
	call test_cos()
	call test_sin()
     !! teardown
	call unit_test_stop()
     contains
     subroutine test_sqrt()
     integer :: i
	call unit_test_start('sqrt',msg='calculate the square root')
	input	=[1.0d0,4.0d0,9.0d0]
	expected=[1.0d0,2.0d0,3.0d0]
	answers=[(sqrt(input(i)),i=1,size(input))]
	call unit_test('sqrt', all(expected.eq.answers),&
	   & 'check table of values')
	call unit_test('sqrt', sqrt(25.0d0).eq.5.0d0,&
	   & 'got',sqrt(25.0d0),'expected',5.0d0)
	call unit_test_end('sqrt',msg='')
     end subroutine test_sqrt

     subroutine test_sin()
	call unit_test_start('sin',msg='calculate the sine of a value')
	call unit_test_end('sin',msg='')
     end subroutine test_sin

     subroutine test_cos()
	call unit_test_start('cos',msg='calculate the cosine of a value')
	call unit_test_end('cos',msg='')
     end subroutine test_cos

     end program M_test_suite_M_intrinsics

  The output now looks like this (note if no calls to unit\_test routines are
  made between unit_test_start(3f) and unit_test_end(3f) the procedure gets an
  "UNTESTED" entry to remind you to make some tests ..).

     > check:	    sqrt   SUCCESS : check table of values
     > check:	    sqrt   SUCCESS : got 5.0000000000000000 expected 5.0000000000000000
     > check_end:   sqrt   PASSED  : GOOD:	  2 BAD:	0 DURATION:00000000012000:
     > check_end:   cos    UNTESTED: GOOD:	  0 BAD:	0 DURATION:00000000000000:
     > check_end:   sin    UNTESTED: GOOD:	  0 BAD:	0 DURATION:00000000000000:
     > check_stop:  TALLY  PASSED  : GOOD:	  2 BAD:	0 DURATION:00000000000000
     > STOP 0

  this is a model that works particularly well for basic numeric procedures.

  Now it is just a matter of adding more calls to unit\_test(3f). This is
  where procedures from the other modules become useful, as they provide
  methods for comparing float values, for example. Since Fortran has many
  powerful masking intrinsics usually just the unit\_test(3f) procedure is
  required. In particular, be familiar with the ALL(3f), ANY(3f), and PACK(3f)
  procedures.

  There are options to call a system command and use the initial string as
  options, to interactively pause after each check, and to change options like
  which output file to write on, what error level to use, and other things I
  will hopefully solidify and document here.

   RECOMMENDED BASIC USAGE
  So for an fpm(1) user a recommended process is to create and/or enter the
  test/ directory and use the "unit\_test" program. It will make a test
  program called "unit\_test\_$NAME.f90" for each name given on the command
  line.

  There is a case made for closely related groups of procedures to share a
  single test file that will be made a little bit later. For that, the command
  "test\_suite" is used instead of "unit\_test".

  For now lets assume we have or plan to have the procedures "a","b", and "c"
  in our package, and that we want to create a test for each ( and that
  unit\_test(1) has been installed in your path):

      cd $TOP_OF_FPM_PACKAGE
      cd test
      unit_test a b c

  If you then run "fpm test" the skeleton should run indicating the procedures
  are not tested. Change the routines to actually call the "unit\_test"
  procedure and you have the beginnings of a unit test for your procedures.

  The "unit\_test(3f)" procedure in its simplest form takes a string that is
  usually the procedure name and a logical expression, along with up to twenty
  completely optional intrinsic scalar values which will be used to create an
  optional message.

  The example programs also contain a placeholder call to
  unit\_test\_mode(3f).

   PROCEDURAL AND COMMAND LINE MODE OPTIONS
  The dummy skeleton routines all start with a call to unix\_check\_mode(3f).
  Its documentation describes a few default modes you can change with the
  routine. Essentially the same options are available on the command line of
  the test program(s) as well.

      # options may be specified in NAMELIST input format with no
      # extraneous spaces on the command line
      fpm test -- flags=100,200,300 keep_going=T
      # a little more Unix-like or MSWindows-like syntax is allowed, as
      # these are equivalent to the original command ...
      fpm test -- --flags=100,200,300 --keep_going
      fpm test -- /flags=100,200,300 /keep_going=T

  M_framework(3f) uses a built-in command line parser instead of packages like
  M\_CLI or M\_CLI2 to minimize the number of dependencies required.

   SUGGEST ONE TEST PER PROGRAM
  There are advantages to each procedure being tested with a separate program.

  A large number of individual test programs works well with fpm(1).  fpm
  defaults to running all the tests, but can execute subgroups easily because
  it can execute a list of tests and the names can use simple globbing.

  If you autogenerate a list of procedure names to test and call the sample
  program "unit_test" with the names of the procedures it will generate new
  names but skip existing files; allowing for a simple form of auto-generation
  assuming you have a way of listing all the procedure names to test.

  individual procedure tests can be deleted or added or moved easily when each
  is in its own file.

  It is easier to test with debuggers and other tools like gdb and valgrind on
  small units.

  This is true with other tools that you can use with --runner as well.  See
  "fpm help runner" or "fpm manual \>manual.txt" for more information.

   TESTING MANY PROCEDURES IN A SINGLE FILE
  If it is preferred, one program can test multiple procedures. The main
  disadvantage is that the complete test suite is always run unless
  conditional coding is added. One of the uses of the unit\_test\_flags(:)
  array is to allow integer values to be passed at execution time that can be
  tested to provide such conditional testing. When many tests are in one file
  the unit_test_start(3f) procedure includes a "matched" argument which can
  detect if a simple globbing expression that can be given on the command line
  matches the string composed of the test name and message.  This allows you
  to optionally select specific groups of tests from a set.

UNIQUE FEATURES
   CALLING AN EXTERNAL PROGRAM
  A unique feature of the M\_framework(3f) test harness is a hook to call a
  custom program. You can ignore it is there, but it is a very powerful
  feature if you want to do bookkeeping on the test results or enter the
  results into a tracking tool. This allows you a way to sent alerts if
  something fails in automated tests, to create spreadsheets with the test
  results, to retain results in a database or SQLite3 file, or make a custom
  tool to convert the data to something else like TAP (Test Anywhere Protocol)
  reports.

  An example program called "bookkeeper" is included that shows how to parse
  the information passed to the program that generates several files:

     + bookkeeper.csv
     + bookkeeper.html
     + bookkeeper.nml
     + bookkeeper\_clicks.csv

  To use the defaults you simply enter

      fpm test -- command=bookkeeper

  The CSV files can typically be read directly into a spreadsheet program.

  They can also be read using the SQLite3 tool. This is very powerful, letting
  you use SQL to select specific data, generate reports, and convert the
  subsequent results to HTML, CSV, flat text and other formats.

  The NAMELIST output file is essentially a record of the harness calls using
  the standardized NAMELIST format that is almost trivial to read in with a
  custom Fortran program. This might be considered a metafile format for a
  test run. You can replay the data and do whatever you want with it including
  generating alternate output file types; plotting timing data and so on.

  The HTML file is handy for importing into word processors or viewing via
  browsers. Example output files from an fpm(1) package that uses M_framemaker
  illustrate the different types of output that can be generated.

    •  [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv).
       Generally. comma-separated files can be read directly into spreadsheet
       programs, sqlite3, and several common databases.

    •  [CSV
       runtimes](https://urbanjost.github.io/M_framework/bookkeeper_clicks.csv)
       Another CSV file that is a record of the runtimes between a unit test
       start and end.

    •  [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html) An
       example of a formatted report that can be displayed in a browser.

    •  [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml).
       Essentially this is a metafile that records the unit test calls.  It is
       very easy for a custom Fortran program to read back a NAMELIST file and
       generate custom outputs instead of modifying bookkeeper(1).

  The bookkeeper(1) program is an example program that is expected to be
  customized. It provides for parsing the parameters passed to a M_framemaker
  external program.

      IMPORTING INTO SQLLITE3
  Here is an example SQLite3 Tool input file that if placed in "test.sql" can
  be run with

       sqlite3 -batch -init test.sql bookkeeper.db .quit

  if you have sqlite3(1) installed.

     .mode csv
     .import bookkeeper.csv unit_check
     .schema unit_check
     ---
     --- show all data to show it worked
     SELECT * FROM unit_check;
     ---
     --- example lists unique names
     SELECT name FROM unit_check GROUP BY name ORDER BY name ;
     ---
     --- tally up passed, failed, skipped in a text table
     .header on
     .mode column unit_check
     .width 64 9 9 9
     SELECT name,
     --- depending on SQL version a simpler IIF/IF, IFNULL, or TOTAL might be better but this works well
     --- and is relatively "standard" as much as something like a standard is actually adhered to in
     --- SQL-land.
     CASE  sum( passed == 'passed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'passed')  END  AS 'ok',
     CASE  sum( passed == 'failed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'failed')  END  AS 'not ok',
     CASE  sum( passed == 'skipped' ) WHEN NULL THEN 0 ELSE sum ( passed == 'skipped') END  AS 'skip'
     FROM unit_check
     --- WHERE condition
     GROUP BY name
     ORDER BY name ;
     ---
     --- If the table already exists, the sqlite3 tool uses all the rows,
     --- including the first row, in the CSV file as the actual data to import.
     --- Therefore, you should delete the first row of the CSV file with the
     --- header labels if adding to an existing table instead of creating
     DROP TABLE IF EXISTS unit_check;
     --- CREATE TABLE unit_check(
     ---   name   TEXT NOT NULL,
     ---   date   DATE NOT NULL,
     ---   passed TEXT NOT NULL,
     ---   msg	  TEXT
     --- );

  The last select generates a little tally table showing for all the runs in
  the input DataBaseFile the number of pass, fail, and skips of the test
  names. you could tally over a particular date range, only show failures,
  display the last test status, generating output in HTML or CSV or ...  See
  the SQLite3 Tool documentation for sqlite3(3f) for more information.

     name					   ok	      not ok	 skip
     --------------------------------------------  ---------  ---------  ---------
     accdig					   3	      0 	 0
     almost					   24	      0 	 0
     flush_trail				   0	      0 	 3
     in_margin					   30	      0 	 0
     round					   0	      0 	 3
     set_stdout_lun				   0	      0 	 3
     significant				   15	      1 	 2
     unit_test					   0	      0 	 3
     unit_test_bad				   0	      0 	 3
     unit_test_end				   0	      0 	 3
     unit_test_good				   0	      0 	 3
     unit_test_start				   0	      0 	 6
     unit_test_stop				   0	      0 	 3
     where_write_message_all			   0	      0 	 3
     write_message_only 			   4	      2 	 4


UNIQUE FEATURES
  fpm(1), gdb(1), and M\_framework(3f) work together

  It is easy to debug an individual test in a debugger. For example to run a
  test called "crash" with gdb(1) use

       fpm test --target crash --runner "gdb -ex run --quiet"

  A more elaborate example passing arguments to M\_framework(3f) to change
  default behavior to for example write output to stdout instead of stderr and
  display compiler version and options and to run all the tests in the gdb(1)
  debugger (you can enter "q" after each test has run; or enter gdb commands
  at the prompt):

      > fpm test --target '*' --verbose \
      > --runner 'gdb -ex "list, 0" -ex run --quiet --args' \
      > -- flags=9997,9998,9999 luns=6 level=3

  This is long enough that an alias or script would facilitate its use, with
  one changing it to use one's favorite options.

     EASILY CALLED BY STANDARDIZED CD/CI SCRIPTS

  If a CD/CI github automated test script creates a Fortran environment
  including fpm and simply calls "fpm test" you can standardize your testing
  and use the same CD/CI scripts for any package. The testing framework is
  designed with just that scenario in mind.

  The .github subdirectory in M\_framework package contains examples of just
  such files that you can copy as-is into your fpm project. Activate test
  actions in your github repository after adding the .github directory and
  your package will be automatically tested on several different platforms by
  the scripts whenever a "push" to the repository occurs.

  ------------------------------------------------------------------------------------------

SUPPORTS FPM
  The impatient can try this, assuming git(1) and fpm(1) are installed.

  Download the github repository and build it with fpm(1) and create a test
  fpm(1) project:

     #!/bin/bash
     # first you need to install a few example programs
     cd /tmp
     git clone https://github.com/urbanjost/M_framework.git
     cd M_framework
     # install the "unit_test", "bookkeeper", and "test_suite"
     # example programs; assuming the default install puts
     # them in your path:
     fpm install
     # "fpm help install" describes how to customize where the
     # programs are installed.
     #
     # go to your fpm package test/ directory.
     # here, we will make one up
     fpm new /tmp/tryit  # create test project
     cd /tmp/tryit/test
     # so lets say you plan on adding procedures "a","b",and "c" to your src/tryit.f90
     # project code. Set up individual skeleton tests for each procedure.
     unit_test a b c			     # a file for each test
     test_suite a b c > test_suite_tryit.f90 # or a single file
     cd ..  # go to the top of the project
     # add M_framework to the developer dependencies
     cat >> fpm.toml <<\EOF
     [dev-dependencies]
     M_framework    = { git = "https://github.com/urbanjost/M_framework.git" }

   EOF
  # # test the package fpm test # if will say the procedures are untested. Put
  real calls # in to unit_test(3f) and see how the default report # changes #
  # so now to run the default tests is as simple as fpm test # run just one
  test fpm test unit_test_a # run tests using globbing; eg. all tests
  beginning with "unit\_" fpm test 'unit_*' # display help on the interactive
  command options fpm test -- --help

  # you can pass parameters and/or change the unit_test_mode(3f) # calls to
  change some of the test behavior

  So once you want to use this on your own projects, you would normally just
  add M\_framework(3f) as a developer dependency in your fpm.toml project file
  and start making tests that call M\_framework(3f).

    The optional programs demonstrated ("unit\_test", "test\_suite") are just
    simple stand-alone programs that make skeleton programs to run tests that
    you can customize (and rename too to avoid confusion).

       # some useful things to try. Check out the man-pages for all the unit_test_*(3f)
       # procedures.
       # Then look at
       unit_test --help
       fpm test -- help
       # run the demo bookkeeper script
       fpm test -- command=bookkeeper
       # and look at the bookkeeper*.* files in the top of the project


DOCUMENTATION
   USER
  •  An [index](https://urbanjost.github.io/M_framework/man3.html) to HTML
     versions of the manpages

  •  single pages that uses javascript to combine all the HTML descriptions of
     the man-pages is at

     •	[BOOK_M_framework__verify](https://urbanjost.github.io/M_framework/BOOK_M_framework__verify.html)

     •	[BOOK_M_framework__approx](https://urbanjost.github.io/M_framework/BOOK_M_framework__approx.html)

     •	[BOOK_M_framework__journal](https://urbanjost.github.io/M_framework/BOOK_M_framework__journal.html)

     •	[BOOK_M_framework__msg](https://urbanjost.github.io/M_framework/BOOK_M_framework__msg.html)

  •  man-pages in

     •	[manpages.zip](https://urbanjost.github.io/M_framework/manpages.zip)

     •	[manpages.tgz](https://urbanjost.github.io/M_framework/manpages.tgz)

   DEVELOPER
  •  [ford-generated developers'
     document](https://urbanjost.github.io/M_framework/fpm-ford/index.html)

  •  [github action status](docs/STATUS.md)

ADDITIONAL DIRECTORY DESCRIPTIONS
  •  src/ is where the source for the M_framework(3f) module code resides

  •  docs/ contains HTML documentation and the manpage archives

  •  test/ contains simple test programs

  •  example/ has demos

REFERENCES
  •  See the .github directory in [easy](https://github.com/urbanjost/easy)

  •  for examples of CD/CI scripts that assume your package can be tested with
     an "fpm test" command.

  •  examples that use M_framework in github fpm packages:

     •	[M_strings](https://github.com/urbanjost/M_strings)

     •	[M_process](https://github.com/urbanjost/M_process)

  These packages used a different reincarnation of the testing harness and are
  in the process of being changed to use M_framework(3f) more appropriately,
  but still contain some useful examples.

  •  [Fortran Package Manager](https://github.com/fortran-lang/fpm)

  •  [fpm(1) registry](https://github.com/fortran-lang/fpm-registry)

  •  [Fortran Wiki: unit testing
     list](https://fortranwiki.org/fortran/show/Unit+testing+frameworks)

  •  [ford(1)](https://politicalphysicist.github.io/ford-fortran-
     documentation.html) for generating documentation for your projects

   NOTE
  M_framework(3f) is subject to interface changes so the generally recommended
  practice of using a specific commit when using it an an external fpm(1)
  dependency is highly encouraged.

  Any feedback (features, performance, ease of use, ...) is appreciated,
  particularly in the ongoing development phase.

QUOTE
  Do not let your victories go to your head, nor let your failures go to your
  heart.

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024      M_framework(3m_framework)
almost(3m_framework__approx)			  almost(3m_framework__approx)



NAME
  almost(3f) - [M_framework__approx] return true or false if two numbers agree
  up to specified number of digits (LICENSE:PD)

SYNOPSIS
  elemental impure function almost(x,y,digits,verbose)

      class(*),intent(in)	  :: x,y
      class(*),intent(in)	  :: rdigits
      logical,intent(in),optional :: verbose
      logical			  :: almost


DESCRIPTION
  Returns true or false depending on whether the two numbers given agree to
  within the specified number of digits as calculated by ACCDIG(3f).

OPTIONS
  x,y
    expected and calculated values to be compared. May be of type REAL,
    INTEGER, or DOUBLEPRECISION.

  rdigits
    number of digits of precision to compare. May be INTEGER or REAL.

  verbose
    optional value that specifies to print the results of the comparison when
    set to .TRUE..

RETURNS
  almost
    TRUE if the input values compare up to the specified number of values

EXAMPLE
  sample:

     program demo_almost
     use M_framework__approx, only : almost
     implicit none
     real    :: x, y
     logical :: z
     integer :: i
     x=1.2345678
     y=1.2300000
     do i=1,8
	z=almost(x,y,i,verbose=.true.)
	write(*,*)i,z
     enddo
     end program demo_almost

  Results:

      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 1.00000000
      > 	   1 T
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 2.00000000
      > 	   2 T
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 3.00000000
      > 	   3 F
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 4.00000000
      > 	   4 F
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 5.00000000
      > 	   5 F
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 6.00000000
      > 	   6 F
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 7.00000000
      > 	   7 F
      > *sp_accdig* significant digit request too high= 8.00000000
      > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
      > digits out of requested 8.00000000
      > 	   8 F


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024   almost(3m_framework__approx)
in_margin(3m_framework__approx) 	       in_margin(3m_framework__approx)



NAME
  in_margin(3f) - [M_framework__approx] check if two reals are approximately
  equal using a relative margin


SYNOPSIS
  elemental pure function in_margin( expected_value, measured_value,
  allowed_margin )

       real, intent(in)    :: expected_value
       real, intent(in)    :: measured_value
       real, intent(in)    :: allowed_margin
       class(*),intent(in) :: invalue


DESCRIPTION
  Compare two values to see if they are relatively equal using the specified
  allowed margin. That is, see if VALUE_MEASURED is in the range
  VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error varies with the
  magnitude of the values, such that the allowed error is margin * average
  magnitude of measured and expected).

  So the allowed error is smaller when the magnitudes are smaller.

OPTIONS
  expected_value
    First value

  measured_value
    Second value

  allowed_margin
    Allowed relative margin

EXAMPLE
  Sample program:

     program demo_in_margin
     use :: M_framework__approx, only : in_margin
     implicit none
     write(*,*) in_margin(4.00000,3.99999,0.000000001)
     write(*,*) in_margin(4.00000,3.99999,0.00000001)
     write(*,*) in_margin(4.00000,3.99999,0.0000001)
     write(*,*) in_margin(4.00000,3.99999,0.000001)

     write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
	     & [3.9,39.9,399.9,3999.9,39999.9] ,0.000001)
     write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
	     & [3.9,39.9,399.9,3999.9,39999.9] ,0.00001)

     write(*,*) in_margin(4.00000,3.99999,0.00001)
     write(*,*) in_margin(4.00000,3.99999,0.0001)
     write(*,*) in_margin(4.00000,3.99999,0.001)
     write(*,*) in_margin(4.00000,3.99999,0.01)

     end program demo_in_margin

  Results:

	 > F
	 > F
	 > F
	 > F
	 > F F F F F
	 > F F F F T
	 > T
	 > T
	 > T
	 > T




				August 31, 2024in_margin(3m_framework__approx)
significant(3m_framework__approx)	     significant(3m_framework__approx)



NAME
  significant(3f) - [M_framework__approx] round val to specified number of
  significant digits


SYNOPSIS
  pure elemental function significant(val,digits,round)

       real,intent(in)			    :: val
       integer,intent(in)		    :: digits
       character(len=*),intent(in),optional :: round
       real				    :: significant


DESCRIPTION
  Round real value to specified number of significant digits

OPTIONS
  val
    value to round

  digits
    number of significant digits to produce

  round
    Use the round edit descriptor

	    RU	UP : the value resulting from conversion shall be the
		     smallest representable value that is greater than or
		     equal to the original value
	    RD	DOWN : the value resulting from conversion shall be the
		     largest representable value that is less than or
		     equal to the original value
	    RZ	ZERO : the value resulting from conversion shall be the value
		     closest to the original value and no greater in
		     magnitude than the original value.
	    RN	NEAREST : modeis NEAREST,thevalueresulting from conversion
			 shall be the closer of the two nearest
			 representable values if one is closer than the
			 other. If the two nearest representable values
			 are equidistant from the original value, it is
			 processor dependent which one of them is chosen.
	    RC	COMPATIBLE : the value resulting from conversion shall be
			   the closer of the two nearest representable
			   values or the value away from zero if halfway
			   between them.
	    RP	PROCESSOR_DEFINED : rounding during conversion shall be
				    a processor-dependent default mode,
				    which may correspond to one of the
				    other modes.


EXAMPLE
  Sample program

     program demo_significant
     use M_framework__approx, only : significant
     implicit none
     integer :: i
     real :: r, v
     character(len=*),parameter :: g='(*(g0.7,1x))'

	write(*,g)significant([8765.43210,0.1234567890],5)

	write(*,*)'default:',1.23456789012345
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9])
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RU'),'RU'
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RD'),'RD'
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RZ'),'RZ'
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RN'),'RN'
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RC'),'RC'
	write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RP'),'RP'
     end program demo_significant

  Results:

	> 8765.400 .1234600
	>  default:   1.234568
	> 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
	> 1.234568 1.234568 1.234568
	> 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ...
	> 1.234568 1.234568 1.234568 RU
	> 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
	> 1.234567 1.234568 1.234568 RD
	> 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
	> 1.234567 1.234568 1.234568 RZ
	> 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
	> 1.234568 1.234568 1.234568 RN
	> 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
	> 1.234568 1.234568 1.234568 RC
	> 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
	> 1.234568 1.234568 1.234568 RP




				August 31, 20significant(3m_framework__approx)
compare_float(3m_framework__approx)	   compare_float(3m_framework__approx)



NAME
NAME
  compare_float(3f) - [M_framework__approx] compare floating point values with
  adjustable tolerance.  (LICENSE:PD)


SYNOPSIS
  result = compare_float( x, y,ulp = SCALING_VALUE)

       elemental function (x,y,ulp)
       real(kind=KIND),intent(in) :: x,y
       real|integer,intent(in),optional :: ulp

  Additional convenience operators:

	 X.equalto.Y
	 X.lessthan.Y
	 X.greaterthan.Y


DESCRIPTION
  compare_float(3f) is a function for comparing floating point numbers within
  an automatically adjusted tolerance.

  The test performed is

	 abs( x - y ) < ( ulp * spacing( max(abs(x),abs(y)) ) )

  If the result is .TRUE., the numbers are considered equal.  Both single and
  double precision scalar and array numbers can be compared, as the function
  is elemental.

  As a convenience relational operators .EqualTo., .GreaterThan., and
  .LessThan. are provided. These are based on the compare_float(3f) function
  using the commonly used default scaling of ULP=1.

DETAILS
  It is generally acknowledged that real numbers should not be compared
  directly but within some tolerance. However, the magnitude of an appropriate
  tolerance value will vary depending on the magnitudes of the numbers being
  compared and the precision of the computing environment.

  The Fortran standard does not specify functions or operators specifically
  for comparing float values, but leaves some latitude in how the compilers
  address floating point comparisions. It does specify functions that return
  platform-specific values useful in applying different methods to the problem
  such as

      + digits(3f)	  - Significant digits in the numeric model
      + epsilon(3f)	  - Epsilon function
      + exponent(3f)	  - Exponent of floating-point number
      + fraction(3f)	  - Fractional part of the model representation
      + huge(3f)	  - Largest number of a type and kind
      + maxexponent(3f)   - Maximum exponent of a real kind
      + minexponent(3f)   - Minimum exponent of a real kind
      + nearest(3f)	  - Nearest representable number
      + precision(3f)	  - Decimal precision of a real kind
      + radix(3f)	  - Base of a numeric model
      + range(3f)	  - Decimal exponent range of a numeric kind
      + rrspacing(3f)	  - Reciprocal of the relative spacing of a numeric type
      + scale(3f)	  - Scale a real value by a whole power of the radix
      + set_exponent(3f)  - real value with specified exponent
      + spacing(3f)	  - Smallest distance between two numbers of a given type
      + tiny(3f)	  - Smallest positive number of a real kind

  Books have been written on the behavior of floating point math.

  As is used here, a commonly used simple general floating point comparison
  algorithm is

	 if(abs(x < y) < (ulp * spacing(max(abs(x),abs(y))))) then
	   :
	 endif

  where the intrinsic function SPACING(3f) determines the distance between the
  argument X and the nearest adjacent representable number of the same type
  and ULP is an optional user-supplied scaling factor.

OPTIONS
  x,y
    Two congruent floating point values to compare.

  ulp
    The ULP ("unit in the last place") scaling value allows for users to
    control the scaling of the value returned by SPACING(3f) in order to relax
    or tighten what is considered "equal". That is, the ULP value can be used
    to scale the comparison based on knowledge of the "numerical quality" of
    the values being used in the comparision.

    The value should be positive. The absolute value of the value is taken if
    it is negative.

    The default ULP scaling value is 1.0.

    The value may be of type integer or real.

    A 0.5 ULP maximum error is the best you could hope for, since this
    corresponds to always rounding to the nearest representable floating point
    number.

RESULT
  The return value is a logical value indicating whether the inputs are equal
  to within the requested precision.

OPERATORS
  Additional operators based on compare_float(3f) are included:

  X.equalto.Y
    If the result is .TRUE., the numbers are considered equal.	The test
    performed is

		 abs( x - y ) < spacing( max(abs(x),abs(y)) )


  X.greaterthan.Y
    If the result is .TRUE., x is considered greater than y.  The result is a
    logical value indicating whether the operand x is greater than y by more
    than the spacing between representable floating point numbers.

    The test performed is

		      ( x - y ) >= SPACING( MAX(ABS(x),ABS(y)) )

  X.lessthan.Y
    Test if one operand is less than another.  The result is a logical value
    indicating whether the operand x is less than y by more than the spacing
    between representable floating point numbers.

    The test performed is

		     ( y - x ) >= SPACING( MAX(ABS(x),ABS(y)) )

    If the result is .TRUE., x is considered less than y.

EXAMPLES
  use m_compare_float_numbers real :: x, y if ( compare_float( x, y, ulp=5.0 )
  ) ) then ! what to do when x effectively equals y endif

  For no ULP scaling (ULP=1.0), the relational operators can be used instead

  use m_compare_float_numbers real :: x, y if ( x .equalto. y ) then ! -- x
  effectively equals y, so perform some operation endif



				August 31, compare_float(3m_framework__approx)
accdig(3m_framework__approx)			  accdig(3m_framework__approx)



NAME
  accdig(3f) - [M_framework__approx] compare two numbers only up to a
  specified number of digits (LICENSE:PD)


SYNOPSIS
  elemental impure subroutine accdig(x,y,digio,acurcy,ind)

	 class(*),intent(in)  :: X
	 class(*),intent(in)  :: Y
	 class(*),intent(in)  :: DIGI0
	 real,intent(out)     :: acurcy
	 integer,intent(out)  :: ind


DESCRIPTION
  This procedure is used to check how closely two numbers agree.

	call accdig(X,Y,DIGI0,ACURCY,IND)

  The values X and Y are the numbers to compare, and DIGI0 is the threshold
  number of digits to consider significant in returning IND.

  If X and Y are considered equal within DIGI0 relative tolerance,

	 IND	= 0, if tolerance is	 satisfied.
		= 1, if tolerance is not satisfied.

  The result ACURCY gives a measure of the number of leading digits in X which
  are the same as the number of leading digits in Y.

	  ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0
	  ACURCY=-log10(X-Y)	   if X != Y and Y = 0
	  ACURCY=8		   if X=Y

	  ACURCY is never less than -8 or greater than 8 for 32-bit REAL values

  TOLERANCE ...  X and Y are considered equal within DIGI0 relative tolerance,
  if ACURCY is greater than DIGI0.

  For example, Take some numbers and compare them
    to 1.2345678 ...

	>  ================================================
	>  A number	|    ACURCY	  |   ACURCY
	>		|    1.2345678=Y  |   1.2345678=X
	>  ================================================
	>   1.234680	|    3.7900571	  |   3.7901275
	>   1.2345378	|    4.6144510	  |   4.6144404
	>   2.2234568	|    0.096367393  |   0.35188114
	>   1.2345678	|    8.0000000	  |   8.0000000
	>   1.2345679	|    7.0732967	  |   7.0731968
	>  -1.2345678	|   -0.30103000   |  -0.30103000
	>  76.234567	|   -1.7835463	  |   0.0070906729
	>   2.4691356	|    0.0	  |   0.3010300
	>   0.0 	|    0.0	  |  -0.91514942.

  Due to the typical limits of the log function, the number of significant
  digits in the result is best considered to be three.

  Notice that 1.2345678=Y produces different values than 1.2345678=X

  A negative result indicates the two values being compared either do not
  agree in the first digit or they differ with respect to sign. An example of
  two numbers which do not agree in their leading digit (and actually differ
  in order of magnitude) is given above by X=76.234567 and Y=1.2345678; the
  accuracy reported is -1.7835463. An example of two numbers which do not
  agree in sign in X=-1.2345678 and Y=1.2345678; here the accuracy reported is
  -0.30103000.

EXAMPLE
  Example program:

     program demo_accdig ! fortran 90 example
     use M_framework__approx, only : accdig
     implicit none
     integer	     :: digi
     doubleprecision :: a, b
     integer	     :: i10, i20, i30
     integer	     :: ind, ind1, ind2
     real	     :: acurcy, acurcy1, acurcy2
     doubleprecision :: vals(9)
     data vals/ &
       &1.234680d0,   1.2345378d0,  2.2234568d0, 1.2345678d0, &
       &1.2345679d0, -1.2345678d0, 76.234567d0,  2.4691356d0, &
       &0.0d0/
	write(*,*)'========================='
	do i10=0,16
	   a=1.0d0
	   b=a+1.0d0/(10.0d0**i10)
	   call accdig(a,b,8.0,acurcy,ind)
	   write(*,*)i10,a,b,acurcy,ind
	enddo
	write(*,*)'========================='
	digi=16
	do i20=0,digi
	   a=1.0d0
	   b=a+1.0d0/(10.0d0**i20)
	   call accdig(a,b,dble(digi),acurcy,ind)
	   write(*,*)i20,a,b,acurcy,ind
	enddo
	write(*,*)'========================='
	do i30=1,9
	   call accdig(1.2345678d0,vals(i30),8.0,acurcy1,ind1)
	   call accdig(vals(i30),1.2345678d0,8.0,acurcy2,ind2)
	   write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2
	enddo
     end program demo_accdig


NOTES
REFERENCES
  based on ...

     NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. **
	David Hogben,
	Statistical Engineering Division,
	Center for Computing and Applied Mathematics,
	A337 Administration Building,
	National Institute of Standards and Technology,
	Gaithersburg, MD 20899
		       TELEPHONE 301-975-2845
	    ORIGINAL VERSION -	October, 1969.
	     CURRENT VERSION - February, 1990.
	     JSU     VERSION - February, 1991.


DEPENDENCIES
  •  M_framework__journal(), log10(), abs(1)

AUTHORS
  David Hogben, John S. Urban

LICENSE
  Public Domain



				August 31, 2024   accdig(3m_framework__approx)
attr(3m_framework__attr)			      attr(3m_framework__attr)



NAME
  attr(3f) - [M_framework__attr] substitute escape sequences for HTML-like
  syntax in strings (LICENSE:MIT)


SYNOPSIS
  function attr(string,reset) result (expanded)

	 ! scalar
	 character(len=*),intent(in)  :: string
	 logical,intent(in),optional  :: reset
	 character(len=:),allocatable :: expanded
	 ! or array
	 character(len=*),intent(in)  :: string(:)
	 logical,intent(in),optional  :: reset
	 character(len=:),allocatable :: expanded(:)
	 integer,intent(in),optional  :: chars


DESCRIPTION
  Use HTML-like syntax to add attributes to terminal output such as color on
  devices that recognize ANSI escape sequences.

OPTIONS
  string
    input string  of form

		     "<attribute_name>string</attribute_name> ...".

  where the current attributes are color names, bold, italic, underline, ...

  reset
    By default, a sequence to clear all text attributes is sent at the end of
    each returned line if an escape character appears in the output string.
    This can be turned off by setting RESET to .false. .

    Note if turning off the reset attributes may be continued across lines,
    but if each line is not self-contained attributes may not display properly
    when filtered with commands such as grep(1).

  chars
    For arrays, a reset will be placed after the Nth displayable column count
    in order to make it easier to generate consistent right borders for non-
    default background colors for a text block.

KEYWORDS
  primary default keywords

       colors:
	 r,	    red,       R,  RED
	 g,	    green,     G,  GREEN
	 b,	    blue,      B,  BLUE
	 m,	    magenta,   M,  MAGENTA
	 c,	    cyan,      C,  CYAN
	 y,	    yellow,    Y,  YELLOW
	 e,	    ebony,     E,  EBONY
	 w,	    white,     W,  WHITE

       attributes:
	 it,	    italic
	 bo,	    bold
	 un,	    underline

       basic control characters:
	nul
	bel  (0x07, ^G) beeps;
	bs   (0x08, ^H) backspaces one column (but not past the beginning of
			the line);
	ht   (0x09, ^I) goes to the next tab stop or to the end of the line if
			there is no earlier tab stop;
	lf   (0x0A, ^J),
	vt   (0x0B, ^K)
	ff   (0x0C, ^L) all give a linefeed, and if LF/NL (new-line mode) is
			set also a carriage return
	cr   (0x0D, ^M) gives a carriage return;
	so   (0x0E, ^N) activates the G1 character set;
	si   (0x0F, ^O) activates the G0 character set;
	can  (0x18, ^X) and SUB (0x1A, ^Z) interrupt escape sequences;
	sub
	esc  (0x1B, ^[) starts an escape sequence;
	del  (0x7F) is ignored;

       other:
	 clear
	 default
	 reset
	 gt
	 lt
	 save,DECSC	Save  current state (cursor coordinates, attributes,
			character sets pointed at by G0, G1).
	 restore,DECRC	Restore state most recently saved by ESC 7.
	 CSI		"Control Sequence Introducer"(0x9B) is equivalent to
			"ESC [".

       dual-value (one for color, one for mono):

	 write(*,*)attr('<ERROR>an error message')
	 write(*,*)attr('<WARNING>a warning message')
	 write(*,*)attr('<INFO>an informational message')

  By default, if the color mnemonics (ie. the keywords) are uppercase they
  change the background color. If lowercase, the foreground color.  When
  preceded by a "/" character the attribute is returned to the default.

  The "default" keyword is typically used explicitly when reset=.false, and
  sets all text attributes to their initial defaults.

LIMITATIONS
  •  colors are not nestable, keywords are case-sensitive,

  •  not all terminals obey the sequences. On Windows, it is best if you use
     Windows 10+ and/or the Linux mode; although it has worked with all CygWin
     and MinGW and Putty windows and mintty.

  •  you should use "<gt>" and "<lt>" instead of ">" and "<" in a string
     processed by attr(3f) instead of in any plain text output so that the raw
     mode will create correct input for the attr(3f) function if read back in.

EXAMPLE
  Sample program

      program demo_attr
      use M_framework__attr, only : attr, attr_mode, attr_update
	 call printstuff('defaults')

	 call attr_mode(manner='plain')
	 call printstuff('plain:')

	 call printstuff('raw')

	 call attr_mode(manner='color')
	 call printstuff('')

	 write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:')
	 call attr_update('blink',char(27)//'[5m')
	 call attr_update('/blink',char(27)//'[25m')
	 write(*,'(a)') attr('<blink>Items for Friday</blink>')

      contains
      subroutine printstuff(label)
      character(len=*),intent(in)  :: label
      character(len=:),allocatable :: array(:)
	call attr_mode(manner=label)

	array=[character(len=60) ::    &
	 'TEST MANNER='//label, 		     &
	 '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>',      &
	 '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>', &
	 '<w>WHITE</w> and <e>EBONY</e>']
	write(*,'(a)') attr(array)

	write(*,'(a)') attr('Adding <bo>bold</bo>')
	write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>')
	write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>')
	write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>')

	write(*,'(a)') attr('Adding <ul>underline</ul>')
	write(*,'(a)') attr(&
	 &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>')
	write(*,'(a)') attr(&
	 &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>')
	write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>')

	write(*,'(a)') attr('Adding <ul>italic</ul>')
	write(*,'(a)') attr(&
	 &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>')
	write(*,'(a)') attr(&
	 &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>')
	write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>')

	write(*,'(a)') attr('Adding <in>inverse</in>')
	write(*,'(a)') attr('<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,&
	 &<b>BLUE</b></it></ul></bo></in>')
	write(*,'(a)') attr('<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,&
	 &<y>YELLOW</it></y></ul></bo></in>')
	write(*,'(a)') attr(&
	 &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>')
      end subroutine printstuff
      end program demo_attr


AUTHOR
  John S. Urban, 2021

LICENSE
   MIT
SEE ALSO
  attr_mode(3f), attr_update(3f)



				August 31, 2024       attr(3m_framework__attr)
attr_mode(3m_framework__attr)			 attr_mode(3m_framework__attr)



	      !>

NAME
  attr_mode(3f) - [M_framework__attr] select processing mode for output from
  attr(3f) (LICENSE:MIT)


SYNOPSIS
  subroutine attr_mode(manner)

	 character(len=*),intent(in) :: manner


DESCRIPTION
  Turn off the generation of strings associated with the HTML keywords in the
  string generated by the attr(3f) function, or display the text in raw mode
  as it was passed to attr(3f) or return to ANSI escape control sequence
  generation.

OPTIONS
  MANNER
    The current manners or modes supported via the attr_mode(3f) procedure are

    plain
      suppress the output associated with keywords color(default) commonly
      supported escape sequences

    raw
      echo the input to attr(3f) as its output

    reload
      restore original keyword meanings deleted or replaced by calls to
      attr_update(3f).

EXAMPLE
  Sample program

      program demo_attr_mode
      use M_framework__attr, only : attr, attr_mode
      implicit none
      character(len=:),allocatable :: lines(:)
      character(len=:),allocatable :: outlines(:)
      integer :: i
	 lines=[character(len=110):: &
	 &'<M><y>',&
	 &'<M><y>  Suffice it to say that black and white are also colors',&
	 &'<M><y>  for their simultaneous contrast is as striking as that ',&
	 &'<M><y>  of green and red, for instance. &
	 & --- <y><bo>Vincent van Gogh</bo></y>',&
	 &' ']

	 outlines=attr(lines,chars=57)
	 write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))

	 call attr_mode(manner='plain') ! write as plain text
	 write(*,'(a)')attr(lines)

	 call attr_mode(manner='raw')	! write as-is
	 write(*,'(a)')attr(lines)

	 call attr_mode(manner='ansi')	! return to default mode

      end program demo_attr_mode


AUTHOR
  John S. Urban, 2021

LICENSE
   MIT
				August 31, 2024  attr_mode(3m_framework__attr)
M_framework__attr(3m_framework__attr)	 M_framework__attr(3m_framework__attr)



NAME
  M_framework__attr(3f) - [M_framework__attr::INTRO] control text attributes
  on terminals (LICENSE:MIT)


SYNOPSIS
  use M_framework__attr, only : attr, attr_mode, attr_update

DESCRIPTION
  M_framework__attr(3f) is a Fortran module that uses common ANSI escape
  sequences to control terminal text attributes.

	  use M_framework__attr
	  write(*,*)attr('<red>Red Text!</red> <green>Green Text!</green>')
	  end

  It is designed to use three simple procedures to

      + Specify attributes using simple HTML-like syntax
      + allow the sequences to be suppressed when desired
      + permit the  user program to completely customize the keywords.
	The user can add, delete and replace the sequences associated with
	a keyword without changing the code.

  One advantage of the approach of using formatting directives which are
  replaced with in-band escape sequences is that it is easy to turn off when
  running batch.

  Another important capability is that programs can be run in "raw" mode and
  create a simple text file with the formatting directives in it that can then
  be read back in by a simple filter program that strips it back to plain
  text( see app/plain.f90), or displays it to a screen in color(see
  app/light.f90) or perhaps converts it to another format.

  So this approach makes it trivial to read specially-formatted data from a
  file like a message catalog (perhaps with various versions in different
  languages) and colorize it or display it as plain text

  By making each line self-contained (by default) lines can be filtered by
  external utilities and still display correctly.

ACCESS
  Via git(1):

	 git clone https://github.com/urbanjost/M_framework__attr.git
	 cd M_framework__attr/src
	 # change Makefile if not using one of the listed compilers
	 make clean; make gfortran    # for gfortran
	 make clean; make ifort       # for ifort
	 make clean; make nvfortran   # for nvfortran

  This will compile the M_framework__attr module and example programs.

  Alternatively, via fpm (see https://github.com/fortran-lang/fpm):

	  git clone https://github.com/urbanjost/M_framework__attr.git

  or just list it as a dependency in your fpm.toml project file.

	  [dependencies]
	  M_framework__attr = { git = "https://github.com/urbanjost/M_framework__attr.git" }


LIMITATIONS
  •  colors are not nestable.

  •  keywords are case-sensitive,

  •  ANSI escape sequences are not universally supported by all terminal
     emulators; and normally should be suppressed when not going to a tty
     device. Therefore, you should use M_system::system_istty(3f) or the
     common Fortran extension ISATTY() to set the default to "plain" instead
     of "color" when the output file is not a conforming terminal. On basic
     MSWindows console windows, it is best to use Windows 10+ and/or the Linux
     mode; you may have to enable ANSI escape sequence mode on MSWindows. It
     does work as-is with CygWin and MinGW and Putty windows and mintty(1) as
     tested.

EXAMPLE
  Sample program

      program demo_M_framework__attr
      use M_framework__attr, only : attr, attr_mode, attr_update
      implicit none
      character(len=256) :: line
      character(len=*),parameter :: f='( &
       &"   <bo><w><G> GREAT: </G></w>&
       &The new value <Y><b>",f8.4,1x,"</b></Y> is in range"&
       &)'
      real :: value

	 write(*,'(a)')&
	 &attr('   <r><W><bo> ERROR: </W>red text on a white background</y>')

	 value=3.4567
	 write(line,fmt=f) value
	 write(*,'(a)')attr(trim(line))

	 ! write same string as plain text
	 write(*,*)
	 call attr_mode(manner='plain')
	 write(*,'(a)')attr(trim(line))

	 call attr_mode(manner='color')
	 ! use pre-defined or user defined strings
	 write(*,*)
	 write(*,'(a)')attr('<ERROR> Woe is nigh.')
	 write(*,'(a)')attr('<WARNING> The night is young.')
	 write(*,'(a)')attr('<INFO> It is Monday')

	 ! create a custom mnemonic
	 call attr_update('MYERROR',attr(&
	 ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>'&
	 ))
	 write(*,*)
	 write(*,'(a)')attr('<MYERROR> my custom message style')

      end program demo_M_framework__attr


AUTHOR
  John S. Urban, 2021

LICENSE
   MIT
SEE ALSO
  attr(3f), attr_mode(3f), attr_update(3f)

  Related information:

      terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),
      console_codes(4), ECMA-48,
      https://en.wikipedia.org/wiki/ANSI_escape_code



				August 31M_framework__attr(3m_framework__attr)
attr_update(3m_framework__attr) 	       attr_update(3m_framework__attr)



	      !>

NAME
  attr_update(3f) - [M_framework__attr] update internal dictionary given
  keyword and value (LICENSE:MIT)


SYNOPSIS
  subroutine attr_update(key,val)

      character(len=*),intent(in)	    :: key
      character(len=*),intent(in),optional  :: val
      character(len=*),intent(in),optional  :: mono_val


DESCRIPTION
  Update internal dictionary in M_framework__attr(3fm) module.

OPTIONS
  key
    name of keyword to add, replace, or delete from dictionary

  val
    if present add or replace value associated with keyword. If not present
    remove keyword entry from dictionary.

  mono_val
    if present add or replace second value associated with keyword used for
    plain text mode.  Must only be specified if VAL is also specified.

KEYWORDS
  The following keywords are defined by default

  colors:

       r,red	 c,cyan     w,white
       g,green	 m,magenta  e,ebony
       b,blue	 y,yellow

  If the color keywords are capitalized they control the text background
  instead of the text color.

  attributes:

       ul,underline
       it,italics (often produces inverse colors on many devices


EXAMPLE
  Sample program

       program demo_update
       use M_framework__attr, only : attr, attr_update
	  write(*,'(a)') attr('<clear>TEST CUSTOMIZATIONS:')
	  ! add custom keywords
	  call attr_update('blink',char(27)//'[5m')
	  call attr_update('/blink',char(27)//'[25m')
	  write(*,*)
	  write(*,'(a)') attr('<blink>Items for Friday</blink>')
	  call attr_update('ouch',attr( &
	  ' <R><bo><w>BIG mistake!</R></w> '))
	  write(*,*)
	  write(*,'(a)') attr('<ouch> Did not see that coming.')
	  write(*,*)
	  write(*,'(a)') attr( &
	  'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>')
	  ! delete
	  call attr_update('r')
	  call attr_update('/r')
	  ! replace (or create)
	  call attr_update('b','<<<<')
	  call attr_update('/b','>>>>')
	  write(*,*)
	  write(*,'(a)') attr( &
	  'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>')
       end program demo_update


AUTHOR
  John S. Urban, 2021

LICENSE
   MIT
				August 31, 2024attr_update(3m_framework__attr)
journal(3m_framework__journal)			journal(3m_framework__journal)



NAME
  journal(3f) - [M_framework__journal] provides public message routine, no
  paging or graphic mode change (LICENSE:PD)

SYNOPSIS
  subroutine journal([where,],[VALUE(s)])

      character(len=*),intent(in) :: where
      class(*),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj


   WRITE MESSAGES
  basic messages

	call journal(where,[VALUE(S)])
	call journal(message) # a shortcut for "call journal('sc',message)":

   OPEN OR CLOSE TRAIL FILE
  trail file

	call journal('O',trailfile_name) # open trail file
	call journal('O','')		 # close trail file

   SET OUTPUT TIME PREFIX
  set the function display format for timestamps. See the NOW(3f) procedure
  for allowable timestamp macros

	call journal('%',time_stamp_prefix_specification)


   MODES
  Turn on/off writing DEBUG messages to trail file

	call journal('>','debug on') # turn on debug mode
	call journal('<','debug off') # turn off debug mode


   ASSIGN STDOUT TO AN ALTERNATE FILE
  change stdout to iunit and open filename; or close unit and go back to
  stdout if filename=''

	call journal(iunit,filename)

  change stdout to iunit to use a file already open

	call journal(iunit)


DESCRIPTION
  If a user procedure is used for outputting messages instead of calling
  WRITE(3f) it is easy to provide control of when messages are printed (ie. a
  "verbose" mode, or "quite" mode), creating files to replay program
  execution, duplicating output, ...

OPTIONS
  WHERE
    indicates where messages are written. A combination of the following
    characters can be used...

    Usually one of these to write to the standard output files ...

    S write to stdout or iounit set with journal(unit) or
      journal(unit,filename).

    E write to stderr

    And one of these to write to trail file (ignore if no trail file defined)
    ...

    C write to trail file as a comment (if file is open) Writing output "as a
      comment" means it is preceded by a pound(#) character.

    T write to trail file (if file is open)

    Usually used by itself

    D write to trail file as a comment with "DEBUG:" prefix in front of
      message (if file is open) if debug mode is on. Write to stdout if no
      trail file and debug mode is on.

    Modifier for S|E|C|T|D specifiers

    •  subsequent files are written to with advance='no'. Position is
       important. '+sc' does an advance='no' on both files, 's+c' only does
       the advance='no' for the trail file.

    Mode changing options used by themselves:

    > turn off debug messages

    < turn on debug messages

    O open trail file using value of "message" parameter or close trail file
      if no filename or a blank filename.

    A Auxiliary programs that also want to write to the current log file (a2b,
      z2a, ...) call this routine to see if there is a trail file being
      generated and then add to it so that a program like ush(1f) can call the
      auxiliary programs and still just generate one log file, but if the
      auxiliary program is used as a stand-alone program no trail is
      generated.

  VALUES(S)
    message to write to stdout, stderr, and the trail file.  a numeric or
    character value to optionally be appended to the message. Up to twenty
    values are allowed. The WHERE field is required if there is anything other
    than a single character string or not values at all.

  FILENAME
    when WHERE="O" to turn the trail file on or off, the "message" field
    becomes the trail filename to open. If blank, writing to the trail file is
    turned off.

  TIMEFORMAT
    when WHERE="%" the message is treated as a time format specification as
    described under now(3f).

EXAMPLE
  Sample program:

     program demo_journal
     use M_framework__journal, only : journal
     !! BASIC USAGE
     call journal(&
     & 'write to standard output as-is, and trail file as a comment if open')
     ! since trail file is not yet open, only stdout will display output
     call journal('c','ignored, as trail file is not open')
     ! now open trail file "trail"
     call journal('o','trail')
     call journal('sc','same thing except now trail file is open')
     ! only write to trail file if open
     call journal('c',&
     & 'not ignored, as trail file is open. Written with # suffix')
     call journal('t',&
     & 'not ignored, as trail file is open. Written as-is')
     ! turn off trail file
     call journal('o','')
     end program demo_journal

  Adding intrinsic scalar values to the message:

     program test_journal
     use M_framework__journal, only: journal
     implicit none
	call journal('S','This is a test with no optional value')
	call journal('S','This is a test with a logical value',.true.)
	call journal('S', &
	  & 'This is a test with a double value',1234567890.123456789d0)
	call journal('S', &
	  & 'This is a test with a real value',1234567890.123456789)
	call journal('S','This is a test with an integer value',1234567890)
	call journal('STDC','This is a test using STDC',1234567890)
	call journal('stdc','This is a test using stdc',1234567890)
	call journal('o','journal.txt')  ! open trail file
	call journal('S', &
	  & 1,12.34,56789.111111111d0,.false.,'a bunch of values')
	! the combinations that make sense
	call journal('st','stdout and trail')
	call journal('s' ,'stdout only')
	call journal('t' ,'trail only')
	call journal('sc','stdout and trail_comment')
	call journal('c' ,'trail_comment only ')
	call journal('d' ,'debug only')
	call journal('e' ,'stderr only')
	call journal('o' ,' ') ! closing trail file
     end program test_journal

     program testit
     ! this is a utility program that calls the module routines. It is
     ! typically built using ccall(1).
     use M_framework__journal, only : journal
     character(len=:),allocatable :: time_stamp_prefix
      call journal('s', &
      & '------------------------------------------------------------')
      call journal('s','SIMPLE WRITES')
      call one()
      call two()
      call journal('sc', &
      & 'called ONE() and TWO() but did not generate a log file')
      call journal('s', &
      & '------------------------------------------------------------')
      call journal('s','SIMPLE WRITES WITH LOG FILE')
      call journal('o','journal.txt')	  ! open trail file
      call one()
      call two()
      call journal('sc', &
      & 'called ONE() and TWO() and generated log file journal.txt')
      call journal('','journal.txt')	  ! close trail file
      call journal('s', &
      & '------------------------------------------------------------')
      call journal('s','SIMPLE WRITES WITH TIMING INFORMATION')
      ! change time prefix
      time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b'
      call journal('%',time_stamp_prefix) ! set a message time prefix
      call journal('o','timed.txt')	  ! open trail file
      call one()
      call two()
      call journal('sc', &
      & 'called ONE() and TWO() and generate log file timed.txt')
      call journal('','timed.txt')	  ! close trail file
      call journal('%','')		  ! turn off time prefix
      call journal('o','timed.txt')	  ! open trail file
      call journal('s', &
      & '------------------------------------------------------------')

     contains

	subroutine two()
	   call journal('Entered subroutine two')
	   call journal('Exited subroutine two')
	end subroutine two

	subroutine one()
	   call journal('Entered subroutine one')
	   sum=-HUGE(1.0)
	   do i=1,10000000
	     sum=sum+sqrt(real(i))
	   enddo
	   write(*,*)'SUM=',sum
	   call journal('Exited subroutine one')
	end subroutine one

     end program testit


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024 journal(3m_framework__journal)
M_framework__journal(3m_framework__M_framework__journal(3m_framework__journal)



NAME
  M_framework__journal(3fm) - [M_framework__journal::INTRO] write program
  messages to stdout and/or a log file (LICENSE:PD)

SYNOPSIS
  use, M_framework__journal , only : journal

DESCRIPTION
  For large interactive programs in particular it is useful if all messages go
  thru a JOURNAL(3f) call. This makes it easy to write messages to a log file
  as well as standard output; to toggle time prefixes on and off; to turn on
  and off debug-mode messages; control output paging and create replayable
  input journals.

  The primary use of JOURNAL(3f) is to create journal files for interactive
  programs that

	 + provide various levels of verbosity on demand, often for
	   debugging purposes.
	 + can be replayed even when interactive input was provided
	 + and/or be used to verify program executions

  Typically, you would echo what the user typed to the trail file as-is, and
  write output you write to stdout as comments to the trail file so that the
  trail file can easily be read back in (by ignoring comments).

  Even though there is essentially one procedure (journal(3f) calls that are
  more than just a single message have an action specified as the first
  parameter. This action might specify to open a log file, to change the
  "level" required by messages for them to appear, whether output it written
  as a comment or not, and on what files the output shoud appear. So the
  interface can be used in a very simple manner but has more options than is
  evident at first glance, as detailed in the man-page for journal(3f).

  to stdout is written with WHERE='SC' in the JOURNAL(3f) call.

      >      :
      >      :
      > call journal('O','my_trail_file')  ! open trail file
      > ! write output to stdout as-is and as comment to trail file
      > call journal(output)
      > ! echo message to trail/log file only
      > call journal('T',userline)
      > ! write to stdout as-is and trail as a comment.
      > ! up to twenty scalar values of any intrinsic type are allowed
      > call journal('SC','i1=',i1,'i2=',i2,'i3=',i3)
      > ! for more complex messages you can build them with non-advancing
      > ! I/O journal calls, or build the message with internal writes
      > ! into a string and print that.

	I=10
	R=20.3
	! write to stdout and trail file without advancing I/O
	call journal('+SC','I=',i)
	! write to stdout and trail file without advancing I/O
	call journal('SC','AND R=',r)

  writes to the trail file(s) are ignored unless a trail file was opened, but
  output continues to stdout by default.

  That is, destinations 'T' and 'C' are ignored unless a trail file has been
  requested, allowing journal to be used with programs that do not generate
  trails or journals.

  Note that with no parameters, the trail file is flushed.

EXAMPLES
  The man-page for journal(3f) describes all the options for the

  action field WHERE.
    In addition to being used to generate a journal, the routine can be used
    for producing optional debug messages and timing information.

  Sample program for debug messages:

       program demo_journal
       !! showing creating debug messages
       use M_framework__journal, only : journal
       implicit none
       !! produces no output because trail is not on
       call journal('D','*demo* DEBUG MESSAGE 001 IGNORED')
       !! turn on debug messages
       call journal('>','debug on')
       !! produces output on stdout because debug mode
       !! is on but no named trail file
       call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT')
       !! open trail file
       call journal('O','mytrail.txt')
       !! debug messages now go to the trail file only
       call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL')
       !! or always to stdout and trail file only if on
       call journal('DS','*demo* DEBUG MESSAGE 003 TO TRAIL')
       !! close trail file so messages go only to stdout again
       call journal('O','')
       !! debug on stdout now
       call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT')
       !! turn off debug messages
       call journal('<','debug off')
       !! back to no output from the next message
       call journal('D','*demo* DEBUG MESSAGE 005 IGNORED')
       end program demo_journal


  Sample program for trail messages with optional timing information:

       program testit
       use M_framework__journal,only : journal
       implicit none
       call journal('a single string A -should be on S')

       ! add time prefix to output
       call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b')
       !
       call journal('a single string B -should be on S with prefix')
       ! change to CPU time and number of calls prefix
       call journal('%','CPU_TIME: %c:CALLS: %C: %b')
       !
       call journal('a single string B-1 -should be on S with prefix')
       call journal('a single string B-2 -should be on S with prefix')
       call journal('a single string B-3 -should be on S with prefix')
       !  Other useful time formats:
       !     %E -- Unix Epoch time
       !     %e -- integer value of Unix Epoch time
       !     %C -- number of times this format is used
       !     %c -- CPU_time(3f) output
       !     %S -- seconds since last use of this format
       !     %k -- CPU time in seconds from system_clock
       call journal('%','') ! turn off time prefix
       !
       call journal('a single string C -should be on S')
       !
       call journal('O','aaa.out') ! turn on trail file
       call journal('a single string D -should be on SC')
       call journal('a single string E -should be on SC')
       call journal('a single string F -should be on SC')
       call journal('O','') ! turn off trail file
       !
       call journal('a single string G -should be on S')
       call journal('a single string H -should be on S')
       call journal('a single string I -should be on S')

       ! build one line of output with intrinsic scalar values added
       call journal('+sc','APPEND:')
       call journal('+sc',' integer',	      1234)
       call journal('+sc',' and real',	      1234.5678)
       call journal('+sc',' and double',1234567890.123456d0)
       call journal('+sc',' and logical',    .true.)
       call journal('sc','')
       !
       end program testit


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				AugM_framework__journal(3m_framework__journal)
str(3m_framework__msg)					str(3m_framework__msg)



NAME
  str(3f) - [M_framework__msg] converts up to twenty standard scalar type
  values to a string (LICENSE:PD)


SYNOPSIS
  Syntax:

       pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
		       & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if)
       class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
       class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
       logical,intent(in),optional	    :: if
       character(len=*),intent(in),optional :: sep
       character,len=(:),allocatable	    :: str


DESCRIPTION
  str(3f) builds a space-separated string from up to twenty scalar values.

OPTIONS
  g[0-9a-j]
    Optional value to print the value of after the message. May be of type
    INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.

    Optionally, all the generic values can be single-dimensioned arrays.
    Currently, mixing scalar arguments and array arguments is not supported.

  sep
    separator string used between values. Defaults to a space.	Must be
    specified with a keyword.

  if
    If false return a null string.  Must be specified with a keyword.

RETURNS
  str
    description to print

EXAMPLES
  Sample program:

     program demo_str
     use M_framework__msg, only : str
     implicit none
     character(len=:),allocatable :: pr
     character(len=:),allocatable :: frmt
     integer			  :: biggest

     pr=str('HUGE(3f) integers',huge(0),&
     &'and real',huge(0.0),'and double',huge(0.0d0))
     write(*,'(a)')pr
     pr=str('real	     :',huge(0.0),0.0,12345.6789,tiny(0.0) )
     write(*,'(a)')pr
     pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
     write(*,'(a)')pr
     pr=str('complex	     :',cmplx(huge(0.0),tiny(0.0)) )
     write(*,'(a)')pr

     ! create a format on the fly
     biggest=huge(0)
     ! +0 for gfortran-11 bug
     frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
     write(*,*)'format=',frmt

     ! although it will often work, using str(3f)
     ! in an I/O statement is not recommended
     ! because if an error occurs str(3f) will try
     ! to write while part of an I/O statement
     ! which not all compilers can handle and is currently non-standard
     write(*,*)str('program will now stop')

     end program demo_str

  Output

     HUGE(3f) integers 2147483647 and real 3.40282347E+38 ...
     and double 1.7976931348623157E+308
     real	     : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
     doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...
     12345.678900000001 2.2250738585072014E-308
     complex	     : (3.40282347E+38,1.17549435E-38)
      format=(*(i9:,1x))
      program will now stop


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024 	str(3m_framework__msg)
wrt(3m_framework__msg)					wrt(3m_framework__msg)



NAME
  wrt(3f) - [M_framework__msg] write multiple scalar values to any number of
  files (LICENSE:PD)

SYNOPSIS
  subroutine wrt(luns,generic(s),iostat)

      integer,intent(in)	   :: luns(:)
      class(*),intent(in),optional :: &
		      & generic0,generic1,generic2,generic3,generic4
      class(*),intent(in),optional :: &
		      & generic5,generic6,generic7,generic8,generic9
      class(*),intent(in),optional :: &
		      & generica,genericb,genericc,genericd,generice
      class(*),intent(in),optional :: &
		      & genericf,genericg,generich,generici,genericj
      integer,intent(out),optional :: iostat
      character(len=*),intent(in)  :: types(*)

DESCRIPTION
  WRT(3f) writes a list of scalar values
    to the list of unit numbers in LUNS(:).

OPTIONS
  LUNS
    Unit numbers to write to. If of size zero no output is generated

  generic[1-20]
    optional value to print the value of after the message. May be of type
    INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.

  TYPES
    one for each lun. '' for ASCII, 'CSV' for comma-separated.

RETURNS
  IOSTAT
    The value of the last non-zero IOSTAT value. Returns zero if no errors
    occurred.

EXAMPLES
  Sample program:

     program demo_wrt
     use, intrinsic :: iso_fortran_env, only : &
      & stdin=>input_unit, &
      & stdout=>output_unit, &
      & stderr=>error_unit
     use M_framework__msg, only: wrt, fmt
     implicit none
     integer,allocatable :: luns(:)
     integer :: iostat=0
     integer,parameter :: ints(3)=[1,2,3]

     ! a null list allows for turning off verbose or debug mode output
     luns=[integer ::]
     call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
     write(*,*)'IOSTAT=',iostat

     ! multiple files can be used to create a log file, for example
     luns=[stderr,stdout]
     call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
     write(*,*)'IOSTAT=',iostat

     ! using fmt
     call wrt([stdout,stdout,stdout],'USING FMT :', &
      & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat)


     end program demo_wrt

  TWO FILES: 2147483647 PI= 3.1415926535897931 TWO FILES: 2147483647 PI=
  3.1415926535897931

  IOSTAT=
    USING FMT : 2147483647 PI= 3.1415926535897931 0002 USING FMT : 2147483647
    PI= 3.1415926535897931 0002 USING FMT : 2147483647 PI= 3.1415926535897931
    0002

    IOSTAT=

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024 	wrt(3m_framework__msg)
pdec(3m_framework__msg) 			       pdec(3m_framework__msg)



NAME
  pdec(3f) - [M_framework__msg] write out string with ASCII decimal equivalent
  vertically under it (LICENSE:PD)


SYNOPSIS
  Usage:

      subroutine pdec(string)
      character(len=*),intent(in) :: string


DESCRIPTION
  Given a string to print, PDEC() writes out the ASCII Decimal equivalent of
  the string directly underneath it. This can help you to locate unprintable
  characters or non-standard white-space such as a backspace character or tab
  character in input strings that your program could not interpret. On output,
  non-printable characters are replaced with a space, and trailing spaces are
  ignored.

  You read the numbers vertically.

  1.  ignore trailing spaces

  2.  print the character if it has an ADE of 32 on up

  3.  print a space if it has an ADE of less than 32

  4.  underneath each character print the ADE value vertically

EXAMPLES
  Sample program:

	program demo_pdec
	use M_framework__msg, only : pdec
	call pdec(' ABCDEFG abcdefg    ')
	end program demo_pdec

  would produce (notice trailing space is trimmed):

       > ABCDEFG abcdefg
       >0000000000001111
       >3666667739990000
       >2567890127890123


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024        pdec(3m_framework__msg)
set(3m_framework__msg)					set(3m_framework__msg)



NAME
  set(3f) - [M_msg] set scalars from an array (LICENSE:PD)


SYNOPSIS
  Syntax:

       function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, &
       & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk)
       class(*),intent(in)	     :: g0
       class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga
       class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk


DESCRIPTION
  set(3f) sets up to twenty scalars to elements from an array.

OPTIONS
  g0(:)
    array to read values from. Can be of type INTEGER or REAL

  g[1-9a-k]
    optional values to set to an array element. Can be of type INTEGER or REAL

EXAMPLES
  Sample program:

     program demo_set
     use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
     use,intrinsic :: iso_fortran_env, only : real32, real64, real128
     use M_framework__msg, only : set
     implicit none
     real(kind=real32)	  :: a; namelist /all/a
     real(kind=real64)	  :: b; namelist /all/b
     real(kind=real128)   :: c; namelist /all/c
     integer(kind=int8)   :: i; namelist /all/i
     integer(kind=int16)  :: j; namelist /all/j
     integer(kind=int32)  :: k; namelist /all/k
     integer(kind=int64)  :: l; namelist /all/l
	call set([1,2,3,4,5,6,7],a,b,c,i,j,k,l)
	write(*,nml=all)
	call set(10,a)
	call set(100,l)
	write(*,nml=all)
     end program demo_set

  Results:

      &ALL
      A       =   1.000000    ,
      B       =   2.00000000000000     ,
      C       =   3.00000000000000000000000000000000	  ,
      I       =    4,
      J       =      5,
      K       = 	  6,
      L       = 		    7
      /
      &ALL
      A       =   10.00000    ,
      B       =   2.00000000000000     ,
      C       =   3.00000000000000000000000000000000	  ,
      I       =    4,
      J       =      5,
      K       = 	  6,
      L       = 		  100
      /



AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024 	set(3m_framework__msg)
stderr(3m_framework__msg)			     stderr(3m_framework__msg)



NAME
  stderr(3f) - [M_framework__msg] write message to stderr (LICENSE:PD)

SYNOPSIS
  subroutine stderr(msg,[generic(s)])

      class(*),intent(in),optional :: msg
      class(*),intent(in),optional :: &
		      & generic0,generic1,generic2,generic3,generic4
      class(*),intent(in),optional :: &
		      & generic5,generic6,generic7,generic8,generic9
      class(*),intent(in),optional :: &
		      & generica,genericb,genericc,genericd,generice
      class(*),intent(in),optional :: &
		      & genericf,genericg,generich,generici,genericj

DESCRIPTION
  STDERR(3f) writes a message to standard error using a standard

  f2003 method.
    Up to twenty generic options are available.

OPTIONS
  msg
    - description to print

  generic[0-j]
    - optional value to print the value of after the message. May be of type
    INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.

EXAMPLES
  Sample program:

     program demo_stderr
     use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
     use,intrinsic :: iso_fortran_env, only : real32, real64, real128
     use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32
     use M_framework__msg, only: stderr
     implicit none

     call stderr('A simple message')
     call stderr('error: RVALUE=',3.0/4.0)
     call stderr('error: IVALUE=',123456789)
     call stderr('error: LVALUE=',.true.)

     SEVERAL: block
     integer :: least=10, most=999, ival=-10
     call stderr('error: value',ival, &
	     & 'should be between',least,'and',most)
     endblock SEVERAL

     call stderr('real32  :',huge(0.0_real32),0.0_real32, &
	     & 12345.6789_real32,tiny(0.0_real32))
     call stderr('real64  :',huge(0.0_real64),0.0_real64, &
	     & 12345.6789_real64,tiny(0.0_real64))
     !#ifdef __NVCOMPILER
     !#else
     call stderr('real128 :',huge(0.0_real128),0.0_real128, &
	     & 12345.6789_real128,tiny(0.0_real128))
     !#endif
     call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real)))

     call stderr('error: program will now stop')
     stop 1

     end program demo_stderr

  Results: A simple message error: RVALUE= 0.750000000 error: IVALUE=
  123456789 error: LVALUE= T error: value -10 should be between 10 and 999

    real32
      : 3.40282347E+38 ...  0.00000000 ...  12345.6787 ...  1.17549435E-38

    real64
      : 1.7976931348623157E+308 ...  0.0000000000000000 ...
      12345.678900000001 ...  2.2250738585072014E-308 real128 :
      1.18973149535723176508575932662800702E+4932 ...

      0.00000000000000000000000000000000000
	12345.6789000000000000000000000000002 ...
	3.36210314311209350626267781732175260E-4932 complex :
	(3.40282347E+38,1.17549435E-38) error: program will now stop STOP 1

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024      stderr(3m_framework__msg)
fmt(3m_framework__msg)					fmt(3m_framework__msg)



NAME
  fmt(3f) - [M_framework__msg] convert any intrinsic to a string using
  specified format (LICENSE:PD)

SYNOPSIS
  function fmt(value,format) result(string)

      class(*),intent(in),optional :: value
      character(len=*),intent(in),optional :: format
      character(len=:),allocatable :: string

DESCRIPTION
  FMT(3f) converts any standard intrinsic value to a string using the
  specified format.

OPTIONS
  value
    value to print the value of. May be of type INTEGER, LOGICAL, REAL,
    DOUBLEPRECISION, COMPLEX, or CHARACTER.

  format
    format to use to print value. It is up to the user to use an appropriate
    format. The format does not require being surrounded by parenthesis. If
    not present a default is selected similar to what would be produced with
    free format, with trailing zeros removed.

RETURNS
  string
    A string value

EXAMPLES
  Sample program:

      program demo_fmt
      use :: M_framework__msg, only : fmt
      implicit none
      character(len=:),allocatable :: output

	 output=fmt(10,"'[',i0,']'")
	 write(*,*)'result is ',output

	 output=fmt(10.0/3.0,"'[',g0.5,']'")
	 write(*,*)'result is ',output

	 output=fmt(.true.,"'The final answer is [',g0,']'")
	 write(*,*)'result is ',output

      end program demo_fmt

  Results:

      result is [10]
      result is [3.3333]
      result is The final answer is [T]


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024 	fmt(3m_framework__msg)
assert(3m_framework__msg)			     assert(3m_framework__msg)



NAME
  assert(3f) - [M_framework__msg] print filename, linenumber, and message to
  stderr and stop program (LICENSE:PD)

SYNOPSIS
  function assert(file,linenum,expr,g1,g2,g3,g4,g5,g6,g7,g8,g9, & &
  ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)

    character(len=*),intent(in)
      :: file

    character(len=*),intent(in)
      :: linenum

    logical,intent(in)
      :: expr class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9
      class(*),intent(in),optional :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj

DESCRIPTION
  assert(3f) prints strings to stderr and then stops program with exit code 1
  It labels the first string as the filename, the next integer parameter as
  the linenumber, and then up to twenty scalar values.

  It is primarily intended for use by the prep(1) preprocessor $ASSERT
  directive

OPTIONS
  filename
    a string assumed to be the current filename when compiling

  linenum
    assumed to be the line number of the source code the ASSERT(3f) procedure
    was called at.

  expr
    logical value

  g[1-9a-j]
    optional value(s) to print as a message before stopping. May be of type
    INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.

EXAMPLES
  Sample program:

     program demo_assert
     use M_framework__msg, only : assert
     implicit none
     real :: a, toobig=1024
     a=2000
     call assert('myroutine', 101, a > toobig, &
	     & 'The value is too large', a, ' > ', toobig)
     end program demo_assert


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024      assert(3m_framework__msg)
fstop(3m_framework__utility)			  fstop(3m_framework__utility)



NAME
  fstop(3f) - [M_framework__utility] call stop with both a number and a
  message (LICENSE:PD)

SYNOPSIS
  subroutine fstop(ierr,stdout,stderr)

      integer,intent(in)		   :: ierr
      character(len=*),intent(in),optional :: stdout
      character(len=*),intent(in),optional :: stderr

DESCRIPTION
  FSTOP(3f) call STOP(3f). What a call to STOP does is very system dependent,
  so using an abstraction layer is useful, as it allows just the fstop()
  routine to be changed; and STOP does not allow a variable to be used on the
  numeric access status (this has changed at f2015).

OPTIONS
  ierr
    - value in range 0 to 32

  stdout
    - description to be printed to standard output

  stderr
    - description to be printed to standard error

EXAMPLES
  Sample program:

     program demo_fstop
     use M_framework__utility, only: fstop
     implicit none
     integer :: int
     !*!write(*,*)'Enter stop value'
     !*!read(*,*) int
     int=25
     select case(int)
     case(10) ; call fstop(int)
     case(20) ; call fstop(int,stderr='error: program will now stop')
     case(25) ; call fstop(int,stdout='stdout message', &
		     & stderr='stderr message')
     case(30) ; call fstop(int,stdout='error: program will now stop')
     case default
		call fstop(int)
     endselect

     end program demo_fstop

  Results:

SEE ALSO
  Look for common extensions, such as abort(3f), backtrace(3f)

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024   fstop(3m_framework__utility)
unit_test(3m_framework__verify) 	       unit_test(3m_framework__verify)



NAME
  unit_test(3f) - [M_framework__verify] report if logical expression is true
  or false, optionally call command and/or stop program.  (LICENSE:PD)


SYNOPSIS
  subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,& &
  ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail)

      character(len=*),intent(in) :: name
      logical,intent(in) :: expression
      class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
      logical,intent(in),optional :: only_on_fail


DESCRIPTION
  unit_test(3f) tests the expression and displays a message composed of the
  generic intrinsic values msg, and g1 thorough gj. Additionally, if the
  expression is false

  •  if unit_test_mode(command) is not blank calls the specified shell command

	$COMMAND name="NAME" type="check" passed="passed|failed" ...
	msg="all messages"


  •  if keep_going = .false. stop the program on a failed test

OPTIONS
  NAME
    the unit test name

  EXPRESSION
    the logical expression to evaluate

  msg,g1...gj
    optional message to display when performing test, composed of any scalar
    intrinsics of type INTEGER, REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or
    CHARACTER. A space is placed between each value.

  wordy
    If .false. The message MSG is only displayed if the expression is .false.
    . Must be used as a keyword. Default is .true. .

EXAMPLES
  Sample program:

	program demo_unit_test
	use M_framework, only: &
	   & unit_test_mode,	 &
	   & unit_test_start,	 &
	   & unit_test, 	 &
	   & unit_test_end,	 &
	   & unit_test_stop
	use M_framework, only: almost

	implicit none
	integer :: i
	integer :: x
	integer,allocatable :: arr(:)
	real,allocatable :: arr1(:)
	real,allocatable :: arr2(:)

	   call unit_test_mode(keep_going=.true.,debug=.false.,command='')

	   x=10
	   arr1=[1.0,10.0,100.0]
	   arr2=[1.0001,10.001,100.01]
	   call unit_test_start('myroutine')

	   call unit_test('myroutine', x > 3 ,' if big enough')
	   call unit_test('myroutine', x < 100 ,' if small enough')

	   do i=1,size(arr1)
	      call unit_test('myroutine', &
	      & almost(arr1(i),arr2(i),3.9,verbose=.true.) )
	   enddo

	   arr=[10,20,30]
	   call unit_test('myroutine', .not.any(arr < 0) , &
	   & 'fail if any negative values in array ARR')
	   call unit_test('myroutine', all(arr < 100) , &
	   & 'fail unless all values are less than 100 in array ARR')

	   call unit_test_end('myroutine', &
	   & msg='checks on "myroutine" all passed')

	   call unit_test_stop()

	end program demo_unit_test

  Results:

   Sample output (varies with what optional command or modes is used):

       >check_start: myroutine		  START   :
       >check:	     myroutine		  SUCCESS :  if big enough
       >check:	     myroutine		  SUCCESS :  if small enough
       >*almost* for values 1.00000000 1.00010002 agreement of 3.99997139 ...
       >digits out of requested 3.90000010
       >check:	     myroutine		  SUCCESS :
       >*almost* for values 10.0000000 10.0010004 agreement of 3.99986792 ...
       >digits out of requested 3.90000010
       >check:	     myroutine		  SUCCESS :
       >*almost* for values 100.000000 100.010002 agreement of 3.99995065 ...
       >digits out of requested 3.90000010
       >check:	     myroutine		  SUCCESS :
       >check:	     myroutine		  SUCCESS : fail if any negative ...
       >values in array ARR
       >check:	     myroutine		  SUCCESS : fail unless all values ...
       >are less than 100 in array ARR
       >check_end:   myroutine		  PASSED  : GOOD:7	   BAD: ...
       >0 DURATION:00000000294709: checks on "myroutine" all passed
       >check_stop:  TALLY		  PASSED  : GOOD:7	   BAD: ...
       >0 DURATION:00000000267059


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, 2024unit_test(3m_framework__verify)
unit_test_end(3m_framework__verify)	   unit_test_end(3m_framework__verify)



NAME
  unit_test_end(3f) - [M_framework__verify] end test of procedure started by
  unit_test_start(3f) (LICENSE:PD)


SYNOPSIS
  subroutine unit_test_end(name,msg,opts)

      character(len=*),intent(in) :: name
      character(len=*),intent(in),optional :: msg
      character(len=*),intent(in),optional :: opts


DESCRIPTION
  A message is shown including the duration of the tests If there have been no
  failures the optional shell command

	 $COMMAND name="name" type="end" passed="passed|failed|untested" ...
	 clicks=NNNN msg="message" opts

  is executed

EXAMPLES
  Sample program:

      program demo_unit_test_end
      use M_framework, only: unit_test_start
      use M_framework, only: unit_test
      use M_framework, only: unit_test_end
      implicit none
      integer :: x
      x=10
      call unit_test_start('myroutine')

      call unit_test('myroutine', x > 3 ,'if big enough')
      call unit_test('myroutine', x < 100 ,'if small enough')

      ! program execution stopped
      call unit_test_end ('myroutine',msg='checks on "myroutine"' )

      end program demo_unit_test_end

AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, unit_test_end(3m_framework__verify)
unit_test_expected(3m_framework__verifunit_test_expected(3m_framework__verify)



NAME
  unit_test_expected(3f) - [M_framework__verify] report if two scalar values
  of like type and kind are equal.  (LICENSE:PD)


SYNOPSIS
  impure elemental subroutine unit_test_example(name,result,expected)

      character(len=*),intent(in)  :: name
      class(*),intent(in)	   :: result
      class(*),intent(in),optional :: expected


DESCRIPTION
  A shortcut for a common call to unit_test(3f) tests the two values of like
  type and kind. It is equivalent to

	 call unit_test(name,result,expected,'result=',result,'expected=',.true.)


OPTIONS
  RESULT
    A generated value or expression of integer, real, character, or complex
    type.

  EXPECTED
    The expected value for RESULT, of the same type and kind as RESULT. If not
    present, it is equivalent to .TRUE.

EXAMPLES
  Sample program:

	program demo_unit_test_expected
	use, intrinsic :: iso_fortran_env, only: &
	& stdin => input_unit, stdout => output_unit, stderr => error_unit
	use M_framework, only:		      &
	&  unit_test_mode,		      &
	&  start     =>  unit_test_start,     &
	&  expected  =>  unit_test_expected,  &
	&  stop      =>  unit_test_stop,      &
	& unit_test_level, unit_test_flags
	implicit none
	logical, parameter :: T=.true., F=.false.
	! optional call to change default modes
	   call unit_test_mode(  &
	       keep_going=T,	 &
	       flags=[0],	 &
	       luns=[stderr],	 &
	       command='',	 &
	       brief=F, 	 &
	       match='',	 &
	       interactive=F,	 &
	       CMDLINE=T,	 &
	       debug=F)

	   unit_test_level=0
	   ! unit tests for ABS(3f) intrinsic
	   call start('abs')
	   ! integer
	   call expected('abs',abs(-10),10)
	   call expected('abs',abs( 10),10)
	   ! real and elemental
	   call expected('abs',abs( [-10.0, 10.0]),10.0)
	   ! complex
	   call expected('abs',abs(( 3.0,-4.0)),5.0)
	   call expected('abs',abs((-3.0, 4.0)),5.0)
	   call expected('abs',abs((-3.0,-4.0)),5.0)
	   call expected('abs',abs(( 3.0, 4.0)),5.0)
	   call stop('abs')
	end program demo_unit_test_expected


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				Augustunit_test_expected(3m_framework__verify)
unit_test_mode(3m_framework__verify)	  unit_test_mode(3m_framework__verify)



NAME
  unit_test_mode(3f) - [M_framework__verify] set testing modes (LICENSE:PD)

SYNOPSIS
  subroutine unit_test_mode( keep_going, flags, luns, command, & brief,
  interactive, CMDLINE, debug, match)

  logical,intent(in) :: keep_going, brief, interactive,debug
  integer,intent(in),allocatable :: luns(:), flags(:)
  character(len=*),intent(in) :: command

DESCRIPTION
  unit_test_mode(3f) changes testing mode defaults

OPTIONS
  keep_going
    keep running if a test fails. Default to TRUE

  flags
    a list of integer values that can be accessed from M_framework as
    unit_test_flags(:) for use in selecting various tests conditionally

  luns
    list of Fortran units to unit test messages to. Defaults to the the value
    of ERROR_UNIT from the intrinsic module ISO_FORTRAN_ENV (ie. defaults to
    "stderr"). It is Assumed the units have been opened by the program.

  match
    the string that is tested against the name and msg specified on
    unit_test_start() to set the "matched" argument.

  command
    filter command, typically to generate reports. It is passed data on the
    command line. See the example filter "bookkeeper" for examples.

  brief
    If present only "FAIL" messages are produced.

  brief
    Only display FAIL messages and related information

  verbose
    verbose mode displays compiler version and options and all standard
    messages.

  silent
    no output from unit_test_*(3f) procedures

  interactive
    prompt as each test case starts as to continue.

  cmdline
    If set to .false. do not parse command line for options.

  debug
    Debug mode for the M_framework package

EXAMPLES
  Sample program:

     program demo_unit_test_mode
     use M_framework
     implicit none

     call unit_test_mode(keep_going=.false.,luns=[6], &
	     & brief=.true.)

     end program demo_unit_test_mode


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31,unit_test_mode(3m_framework__verify)
unit_test_msg(3m_framework__verify)	   unit_test_msg(3m_framework__verify)



NAME
  unit_test_msg(3f) - [M_framework__verify] converts up to twenty standard
  scalar values to a message for unit testing (LICENSE:PD)

SYNOPSIS
  function unit_test_msg(name, msg, & &
  g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,if)

      character(len=*),intent(in)  :: name
      class(*),intent(in),optional :: msg, &
      & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj

DESCRIPTION
  unit_test_msg(3f) builds a string from up to twenty scalar values and prints
  it to the error log.

OPTIONS
  name
    name of unit being tested

  msg,g[1-j]
    optional values to print the value of. May be of type INTEGER, LOGICAL,
    REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.

  if
    expression must be true or message is not output.  Must be specified by
    keyword as "if=expression".

EXAMPLES
  Sample program:

     program demo_unit_test_msg
     use M_framework, only : unit_test_start,unit_test_msg, &
	     & unit_test_end
     implicit none

     call unit_test_start('myroutine')
     call unit_test_msg('myroutine','HUGE(3f) integers', &
	     & huge(0),'and real',huge(0.0),'and double',huge(0.0d0))
     call unit_test_msg('myroutine','real	     :', &
	     & huge(0.0),0.0,12345.6789,tiny(0.0) )
     call unit_test_msg('myroutine','doubleprecision :', &
	     & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
     call unit_test_msg('myroutine','complex	     :', &
	     & cmplx(huge(0.0),tiny(0.0)) )
     call unit_test_end('myroutine')

     end program demo_unit_test_msg


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31, unit_test_msg(3m_framework__verify)
unit_test_start(3m_framework__verify)	 unit_test_start(3m_framework__verify)



NAME
  unit_test_start(3f) - [M_framework__verify] reset counters and start a new
  test block (LICENSE:PD)


SYNOPSIS
  subroutine unit_test_start(name,msg,opts,matched)

      character(len=*),intent(in)	   :: name
      character(len=*),intent(in),optional :: msg
      character(len=*),intent(in),optional :: opts
      logical,intent(out),optional	   :: matched


DESCRIPTION
  unit_test_start(3f) is an initialization procedure for starting a new
  procedure test.

OPTIONS
  NAME
    name of the procedure to test

  MSG
    message to print

  OPTS
    pass additional options to the optional shell command that can be assigned
    on the command line or by unit_test_mode(3f).

  MATCHED
    if the match string has been set with unit_test_mode(3f) or on the command
    line this will return true if the name and msg concatenated with a space
    match the entire match string, where "*" matches any string and "?"
    matches any single character. This allows you to skip a test set if you
    wish by exiting.

EXAMPLES
  Sample program:

      program demo_unit_test_start
      use M_framework, only: unit_test_start, unit_test, &
       & unit_test_end, unit_test_mode, unit_test_stop
      implicit none
      integer :: ival
      logical :: matched
      call unit_test_mode()
      call test_mysub1()
      call test_mysub2()
      call unit_test_stop()
      contains
      subroutine test_mysub1() ! first test
      call unit_test_start('mysub1')
      ! the example goodbad(1) command called here takes many options
      ! used to build an SQLite3 entry
      ival=10
      call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
      call unit_test('mysub1', ival < 100 , msg=' if small enough')
      call unit_test_end('mysub1',msg='completed checks of "mysub1"')
      end subroutine test_mysub1

      subroutine test_mysub2() ! second test
      call unit_test_start('mysub1','',matched=matched)
      ival=200
	 if(.not.matched)return ! makes it skippable
	 call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
	 call unit_test('mysub1', ival < 100 , msg=' if small enough')
	 call unit_test_end('mysub1',msg='completed checks of "mysub2"')
      end subroutine test_mysub2

      end program demo_unit_test_start


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31unit_test_start(3m_framework__verify)
unit_test_stop(3m_framework__verify)	  unit_test_stop(3m_framework__verify)



NAME
  unit_test_stop(3f) - [M_framework__verify] report tally of all checks and
  stop program (LICENSE:PD)


SYNOPSIS
  subroutine unit_test_stop(msg,opts)

      character(len=*),intent(in),optional :: msg
      character(len=*),intent(in),optional :: opts


DESCRIPTION
  give a tally of all calls to unit_test(3f) and stop program.

  Tally up the test result totals and stop the program.  If a command is set
  via unit_test_mode(3f) or the command line call it appending OPTS to the end
  of the command.

OPTIONS
  MSG
    additional message to display OPTS add string to filter command line if
    any is specified.

EXAMPLES
  Sample program:

      program demo_unit_test_stop
      use M_framework, only: unit_test_start, unit_test_end, &
      & unit_test, unit_test_stop, unit_test_mode
      use,intrinsic :: iso_fortran_env, stdout=>OUTPUT_UNIT
      implicit none
      integer :: x
      x=10
      call unit_test_mode(luns=[stdout])
      ! do a test
      call unit_test_start('proc1')
      call unit_test('proc1', x > 3 , 'if big enough')
      call unit_test('proc1', x < 100 , 'if small enough')
      call unit_test_end  ('proc1',msg='checks all done' )
      ! do another test
      call unit_test_start('proc2')
      call unit_test('proc2', x > 3 , 'if big enough')
      call unit_test('proc2', x < 100 , 'if small enough')
      call unit_test_end  ('proc2',msg='checks all done' )

      ! tally up test results and stop program
      call unit_test_stop()

      end program demo_unit_test_stop


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 31,unit_test_stop(3m_framework__verify)
unit_test_system(3m_framework__verify)	unit_test_system(3m_framework__verify)



NAME
  unit_test_system(3f) - [M_framework__verify] return status from system
  command (LICENSE:PD)

SYNOPSIS
  function unit_test_system(cmd,verbose)

      character(len=*),intent(in)  :: cmd
      logical,intent(in),optional  :: verbose

DESCRIPTION
  unit_test_system(3f) executes a system command and returns the exit status
  of the command.

OPTIONS
  command
    system command to execute. If it starts with "* " the asterisk is replaced
    by the name of the current command.  If it starts with "** " the asterisks
    are replaced by the current command including arguments.

  verbose
    if .true. the executed command is echoed to output. The default is .false.

EXAMPLES
  Sample program:

     program demo_unit_test_system
     use M_framework, only: &
	unit_test_start,  &
	unit_test,	  &
	unit_test_system, &
	unit_test_end
     implicit none
     if (command_argument_count()  ==  0) then
	call unit_test_start('myroutine')
	call unit_test('false', unit_test_system('false') == 0, 'check false')
	call unit_test('true', unit_test_system('true') == 0, 'check true')
	call unit_test('notthere', unit_test_system('notthere') == 0, &
	& 'check notthere')
	call unit_test('*',&
	& unit_test_system('* and options', verbose=.true.) == 0, 'check "*"')
	call unit_test_end('myroutine')
     else
	write (*, *) 'called with an option'
     endif
     end program demo_unit_test_system


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				August 3unit_test_system(3m_framework__verify)
M_framework__verify(3m_framework__verM_framework__verify(3m_framework__verify)



NAME
  M_framework__verify(3f) - [M_framework__verify::INTRO] unit test framework
  (LICENSE:PD)

SYNOPSIS
  Module procedures

     use M_framework, only : unit_test, unit_test_start,    &
			     unit_test_end, unit_test_stop, &
			     unit_test_msg, unit_test_mode, &
			     unit_test_system,		    &
			     unit_test_expected
  Module values

     use M_framework, only : unit_test_level, unit_test_flags


QUOTE
  Do not let your victories go to your head, nor let your failures go to your
  heart.

DESCRIPTION
  The M_framework(3f) module is a collection of Fortran routines for
  supporting code development by providing logging, error processing,
  debugging, comparison and unit testing procedures.

  The M_framework__verify(3f) module specifically brings together a few
  procedures for creating unit testing. It ...

    •  allows for a user-defined command to be called to collect results or
       produce mail alerts, or other custom bookkeeping operations.

    •  supports easily composing a message from up to twenty scalar intrinsic
       values and different strings

    •  allows stopping on failure or continuing

    •  provides for a non-zero exit code if any tests fail

    •  is designed for with integration with the fpm (Fortran Package Manager)
       "test" subcommand.

  If default modes need changed it can be done via the unit_test_mode(3f)
  procedure or as command line options.

  messages by default are writting to stderr, but may be written to any list
  of LUNs of preassigned or open files.

   SET MODES
  Some of the most common options are

	call unit_test_mode(command,keep_going,level,luns=[K,L,M,N,...])

	 keep_going  logical variable that can be used to turn on or off
		     program termination on errors.
	 luns	     array of Fortran LUNs to write messages to
	 level	     An integer that can be used to specify
		     different debug levels
	 command     name of optional command to execute for a start,
		     check, or finish.


   PROCEDURES
  The unit test procedures are

	unit_test_start()     start tests of a procedure
	unit_test()	      report if expression is false or true
			       and if .false. stop program when keep_going=.false.
	unit_test_end()       ends test of a procedure
	unit_test_msg()       write message
	unit_test_stop()      stop program with exit value of 0 if no failures
			       else with an exit value of 1
	unit_test_system()    execute system command, recursively if requested.

  The unit test short-cut procedures are

	unit_test_expected()  report if two values are equal

  For custom unit testing reports, a command can be given that will be passed
  information on the command line in NAMELIST format.

    This command is generally a script that makes entries for each unit,
    perhaps in an SQLite data file for example.

    It might also send an email if a test fails in batch environments.

    It could also convert the information to CSV for use in spreadsheets, or
    generate an HTML report, for example.

    A sample command written in the bash(1) shell and using the sqlite3(1)
    command should be included in this distribution as an example.

    The flexibility introduced by calling an external script or program is
    that the command can be changed as desired without changing the test
    programs.

   RELATED FUNCTIONS
  The routines in M_framework__verify(3f) are often combined with other small
  modules such as Comparisons of real values can be done with a tolerance with
  M_Compare_Float_Numbers(3f) and M_framework__approx(3f).  M_hashkeys(3f)
  routines and various math and statistical routines can be helpful to quickly
  create unit tests.

  The intrinsics ANY(3f) and ALL(3f) are particularly useful in calls to
  unit_test(3f).

EXAMPLES
  Sample program

      !! program demo_M_framework__verify
      module M_framework__verify_demo
      private
      public one ! some regular routine
      public two ! some regular routine
      contains

      subroutine one(array)
      integer,intent(out),allocatable :: array(:)
	 array=[21,51,14,45]
      end subroutine one

      subroutine two(array)
      integer,intent(inout),allocatable :: array(:)
	 array=2*array
      end subroutine two

      end module M_framework__verify_demo

      program demo_M_framework__verify
      use M_framework, only: unit_test_start, unit_test,   &
	  & unit_test_end, unit_test_msg, unit_test_stop, &
	  & unit_test_system, unit_test_mode
      use M_framework__verify_demo,   only: one, two
      ! set-up
      call unit_test_mode(command='',flags=[0],keep_going=.true.)
      ! call a test procedure for each routine to test
	 call test_one()
	 call test_two()
      ! tear-down
      call unit_test_stop()
      contains

      subroutine test_one()
      integer,allocatable :: results(:)
      integer,parameter   :: expected(*)=[21,51,14,45]
      call unit_test_start('one')
      call one(results)
      call unit_test('one',all(expected>0), &
	 & 'testing if everyone greater than zero')
      call unit_test('one',all(expected==results), &
	 & 'testing if all values are expected')
      call unit_test_end('one','checks on "one" ended')
      end subroutine test_one

      subroutine test_two
      integer,allocatable :: results(:)
      integer,parameter   :: expected(*)=[2,20,200]
      results=[1,10,100]
      call two(results)
      call unit_test_start('two','check procedure "two" ')
      call unit_test('two', all(expected == results) .and. &
	 & all(expected > 0) .and. maxval(expected) <201,msg='long expression')
      call unit_test_end('two','checks on "two" ended')
      end subroutine test_two

      end program demo_M_framework__verify

  Expected output:

     check_start: one	START	:
     check:	  one	SUCCESS : testing if everyone greater than zero
     check:	  one	SUCCESS : testing if all values are expected
     check_end:   one	PASSED	: GOOD:  2 BAD:  0 DURATION:00000001
     check_start: two	START	:
     check:	  two	SUCCESS : long expression
     check_end:   two	PASSED	: GOOD:   1 BAD:  0 DURATION:00000000
     check_stop:  TALLY PASSED	: GOOD:    3 BAD:  0 DURATION:00000001


AUTHOR
  John S. Urban

LICENSE
  Public Domain



				AugusM_framework__verify(3m_framework__verify)
