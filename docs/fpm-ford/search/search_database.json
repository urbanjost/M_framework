var tipuesearch = {"pages":[{"title":" M_framework ","text":"M_framework M_framework Synopsis M_framework(3f) is an aggregate of Fortran modules useful for creating\nand performing unit tests for Fortran. The support modules are useful on their own for terminal messages,\ncomparing expected values to results, writing logfiles and playback\njournals. It supports easy integration with the fpm(1) “test” subcommand,\nin particular. basic timing is included messages can be composed almost like list-directed I/O when calling the\n   unit test procedures. hooks are provided to external local applications\n   M_framework(3f) comes with a hook that allows calling your own programs to\n   integrate with local logging tools, report generators, spreadsheets or other\n   local infrastructure. The example program “bookkeeper” is included that\n   uses the hook to write example report data files: CSV , HTML NAMELIST The hook can call any local program with an interface similar to\n   “bookkeeper”.  Modify the program for local needs such as sending e-mail\n   alerts and so on without having to change the tests. designed for integration with fpm(1).\n   In conjunction with fpm(1) it is easy to run the tests with the –runner\n   option, allowing for integration with other utilities as well such as\n   the GNU debugger gdb(1), valgrind(1), and other tools. programs included to generate skeleton test program Example programs are provided to create unit test skeleton programs to\nease usage. Easily used with github CD/CI Example CD/CI scripts that can be used with github are in the .github/\ndirectory that assume your tests can by run by using “fpm test”. program M_test_suite_M_intrinsics use , intrinsic :: iso_fortran_env , only : & & stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT ! use M_framework , only : unit_test_start , unit_test , unit_test_end , & unit_test_mode , unit_test_level , unit_test_stop use M_framework , only : TEST_PREFIX ! change column one of messages ! !use M_mymodule ! load any modules you will be testing implicit none double precision , allocatable :: expected (:), answers (:), input (:) double precision , parameter :: PI = atan ( 1.0d0 ) * 4 !! setup !--------------------------------------------------- !OPTIONAL: !  values used in prefix column for various messages !  the default is to set them all to the basename of !  the executable running tests, but they can be !  altered. For example: TEST_PREFIX = prefix ( & TEST_MSG = 'test_msg:   ' , & TEST = 'test:       ' , & TEST_START = 'test_start: ' , & TEST_STOP = 'test_stop:  ' , & TEST_END = 'test_end:   ' & ) !--------------------------------------------------- !OPTIONAL: ! the options available at run-time on the command ! line can have their defaults selected. See the ! man-page for the procedure for details. call unit_test_mode ( ( keep_going = . true . , flags = [ character ( len = 0 ) :: ], luns = [ stdout ], command , & brief = . false . , interactive = . false . , CMDLINE = '' , debug = . false . , match ) !--------------------------------------------------- !! test each subroutine call test_sqrt () call test_cos () call test_sin () !! teardown call unit_test_stop () contains subroutine test_sqrt () integer :: i call unit_test_start ( 'sqrt' , msg = 'calculate the square root' ) input = [ 1.0d0 , 4.0d0 , 9.0d0 ] expected = [ 1.0d0 , 2.0d0 , 3.0d0 ] answers = [( sqrt ( input ( i )), i = 1 , size ( input ))] call unit_test ( 'sqrt' , all ( expected . eq . answers ),& & 'check table of values' ) call unit_test ( 'sqrt' , sqrt ( 2 5.0d0 ). eq . 5.0d0 ,& & 'got' , sqrt ( 2 5.0d0 ), 'expected' , 5.0d0 ) call unit_test_end ( 'sqrt' , msg = '' ) end subroutine test_sqrt subroutine test_sin () call unit_test_start ( 'sin' , msg = 'calculate the sine of a value' ) call unit_test_end ( 'sin' , msg = '' ) end subroutine test_sin subroutine test_cos () call unit_test_start ( 'cos' , msg = 'calculate the cosine of a value' ) call unit_test_end ( 'cos' , msg = '' ) end subroutine test_cos end program M_test_suite_M_intrinsics Example output files from an fpm(1) package that uses\nM_framework illustrate the different types of output that can be \ngenerated.\n + CSV .\n   Generally. comma-separated files can be read directly into spreadsheet\n   programs, sqlite3, and several common databases.\n + CSV runtimes Another CSV file that is a record of the runtimes between a\n   unit test start and end.\n + HTML An example of a formatted report that can be displayed in a browser.\n + NAMELIST .\n   Essentially this is a metafile that records the unit test calls.\n   It is very easy for a custom Fortran program to read back a NAMELIST\n   file and generate custom outputs instead of modifying bookkeeper(1). The bookkeeper(1) program is an example program that is expected to\nbe customized. It provides for parsing the parameters passed to a\nM_frame external program. Supports FPM The impatient can try this, assuming git(1) and fpm(1) are installed. Download the github repository and build it with fpm(1) \nand create a test fpm(1) project: #!/bin/bash # first you need to install a few example programs cd /tmp\ngit clone https://github.com/urbanjost/M_framework.git cd M_framework # install the \"unit_test\", \"bookkeeper\", and \"test_suite\" # example programs; assuming the default install puts # them in your path: fpm install # \"fpm help install\" describes how to customize where the # programs are installed. # # go to your fpm package test/ directory. # here, we will make one up fpm new /tmp/tryit # create test project cd /tmp/tryit/test # so lets say you plan on adding procedures \"a\",\"b\",and \"c\" to your src/tryit.f90 # project code. Set up individual skeleton tests for each procedure. unit_test a b c # a file for each test test_suite a b c > test_suite_tryit.f90 # or a single file cd .. # go to the top of the project # add M_framework to the developer dependencies cat >> fpm.toml <<\\EOF [dev-dependencies] M_framework    = { git = \"https://github.com/urbanjost/M_framework.git\" } EOF # # test the package fpm test # if will say the procedures are untested. Put real calls # in to unit_test(3f) and see how the default report # changes # # so now to run the default tests is as simple as fpm test # run just one test fpm test unit_test_a # run tests using globbing; eg. all tests beginning with \"unit\\_\" fpm test 'unit_*' # display help on the interactive command options fpm test -- --help # you can pass parameters and/or change the unit_test_mode(3f) # calls to change some of the test behavior So once you want to use this on your own projects, you would normally\njust add M_framework(3f) as a developer dependency\nin your fpm.toml project file and start making tests that call M_framework(3f). The optional programs demonstrated (“unit_test”, “test_suite”) are just simple\nstand-alone programs that make skeleton programs to run tests that you can \ncustomize (and rename too to avoid confusion). # some useful things to try. Check out the man-pages for all the unit_test_*(3f) # procedures. # Then look at unit_test --help\nfpm test -- help # run the demo bookkeeper script fpm test -- command = bookkeeper # and look at the bookkeeper*.* files in the top of the project Documentation User An index to HTML versions\n   of the manpages single pages that uses javascript to combine all the HTML descriptions\n   of the man-pages is at BOOK_M_framework BOOK_M_framework__verify BOOK_M_framework__approx BOOK_M_framework__journal BOOK_M_framework__msg man-pages in manpages.zip manpages.tgz Developer ford-generated developers’ document github action status Additional Directory Descriptions src/ is where the source for the M_framework(3f) module code resides docs/ contains HTML documentation and the manpage archives test/ contains simple test programs example/ has demos References See the .github directory in easy for examples of CD/CI scripts that assume your package can be tested with an “fpm test” command. examples that use M_framework in github fpm packages: M_strings M_process These packages used a different reincarnation of the testing harness and are in the process of\n   being changed to use M_framework(3f) more appropriately, but still contain some useful examples. Fortran Package Manager fpm(1) registry Fortran Wiki: unit testing list ford(1) for generating documentation for your projects Note M_framework(3f) is subject to interface changes so the generally recommended\npractice of using a specific commit when using it an an external\nfpm(1) dependency is highly encouraged. Any feedback (features, performance, ease of use, …) is appreciated,\nparticularly in the ongoing development phase. <!–\nOf course any user-supplied method such as a file listing which tests to\nexecute or skip or build the tests conditionally with a preprocessor or\nusing procedure pointers in clever ways to point to a no-op procedure\nare just a few examples of alternate methods. Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"timer – M_framework ","text":"type, public :: timer Components Type Visibility Attributes Name Initial integer(kind=int64), public :: clock_end integer(kind=int64), public :: clock_start real(kind=real64), public :: cpu_end real(kind=real64), public :: cpu_start Constructor public        interface timer private  function clock_new(this) Arguments Type Intent Optional Attributes Name type( timer ), intent(in), optional :: this Return Value type( timer ) Type-Bound Procedures procedure, public :: cputime => clock_cputime private  function clock_cputime(this) result(cpu_time) Arguments Type Intent Optional Attributes Name class( timer ) :: this Return Value real procedure, public :: print => clock_print private  subroutine clock_print(this, string, lun) Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in), optional :: string integer(kind=int64), intent(in), optional :: lun procedure, public :: tic => clock_tic private  subroutine clock_tic(this) Arguments Type Intent Optional Attributes Name class( timer ) :: this procedure, public :: toc => clock_toc private  subroutine clock_toc(this) Arguments Type Intent Optional Attributes Name class( timer ) :: this procedure, public :: wallclock => clock_wallclock private  function clock_wallclock(this) result(elapsed_time) Arguments Type Intent Optional Attributes Name class( timer ) :: this Return Value real","tags":"","url":"type/timer.html"},{"title":"one – M_framework","text":"public  subroutine one(array) Arguments Type Intent Optional Attributes Name integer, intent(out), allocatable :: array (:) Source Code subroutine one ( array ) integer , intent ( out ), allocatable :: array (:) array = [ 21 , 51 , 14 , 45 ] end subroutine one","tags":"","url":"proc/one.html"},{"title":"two – M_framework","text":"public  subroutine two(array) Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: array (:) Source Code subroutine two ( array ) integer , intent ( inout ), allocatable :: array (:) array = 2 * array end subroutine two","tags":"","url":"proc/two.html"},{"title":"test_one – M_framework","text":"subroutine test_one() Arguments None Variables Type Visibility Attributes Name Initial integer, public, parameter :: expected (*) = [21, 51, 14, 45] integer, public, allocatable :: results (:) Source Code subroutine test_one () integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 21 , 51 , 14 , 45 ] call unit_test_start ( 'one' ) call one ( results ) call unit_test ( 'one' , all ( expected > 0 ), & & 'testing if everyone greater than zero' ) call unit_test ( 'one' , all ( expected == results ), & & 'testing if all values are expected' ) call unit_test_end ( 'one' , 'checks on \"one\" ended' ) end subroutine test_one","tags":"","url":"proc/test_one.html"},{"title":"test_two – M_framework","text":"subroutine test_two() Arguments None Variables Type Visibility Attributes Name Initial integer, public, parameter :: expected (*) = [2, 20, 200] integer, public, allocatable :: results (:) Source Code subroutine test_two integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 2 , 20 , 200 ] results = [ 1 , 10 , 100 ] call two ( results ) call unit_test_start ( 'two' , 'check procedure \"two\" ' ) call unit_test ( 'two' , all ( expected == results ) . and . & & all ( expected > 0 ) . and . maxval ( expected ) < 201 , msg = 'long expression' ) call unit_test_end ( 'two' , 'checks on \"two\" ended' ) end subroutine test_two","tags":"","url":"proc/test_two.html"},{"title":"timer – M_framework","text":"public interface timer Module Procedures private  function clock_new(this) Arguments Type Intent Optional Attributes Name type( timer ), intent(in), optional :: this Return Value type( timer )","tags":"","url":"interface/timer.html"},{"title":"test_unit_test – M_framework","text":"subroutine test_unit_test() Arguments None Source Code subroutine test_unit_test () call unit_test_start ( 'unit_test' , msg = '' ) !      call unit_test('unit_test', .true.,'expression is true') !      call unit_test('unit_test', .false.,'expression is false') call unit_test_end ( 'unit_test' , msg = '' ) end subroutine test_unit_test","tags":"","url":"proc/test_unit_test.html"},{"title":"test_unit_test_bad – M_framework","text":"subroutine test_unit_test_bad() Arguments None Source Code subroutine test_unit_test_bad () call unit_test_start ( 'unit_test_bad' , msg = '' ) !      call unit_test('unit_test_bad', .true.,'expression is true') !      call unit_test('unit_test_bad', .false.,'expression is false') call unit_test_end ( 'unit_test_bad' , msg = '' ) end subroutine test_unit_test_bad","tags":"","url":"proc/test_unit_test_bad.html"},{"title":"test_unit_test_end – M_framework","text":"subroutine test_unit_test_end() Arguments None Source Code subroutine test_unit_test_end () call unit_test_start ( 'unit_test_end' , msg = '' ) !      call unit_test('unit_test_end', .true.,'expression is true') !      call unit_test('unit_test_end', .false.,'expression is false') call unit_test_end ( 'unit_test_end' , msg = '' ) end subroutine test_unit_test_end","tags":"","url":"proc/test_unit_test_end.html"},{"title":"test_unit_test_good – M_framework","text":"subroutine test_unit_test_good() Arguments None Source Code subroutine test_unit_test_good () call unit_test_start ( 'unit_test_good' , msg = '' ) !      call unit_test('unit_test_good', .true.,'expression is true') !      call unit_test('unit_test_good', .false.,'expression is false') call unit_test_end ( 'unit_test_good' , msg = '' ) end subroutine test_unit_test_good","tags":"","url":"proc/test_unit_test_good.html"},{"title":"test_unit_test_start – M_framework","text":"subroutine test_unit_test_start() Arguments None Source Code subroutine test_unit_test_start () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_unit_test_start","tags":"","url":"proc/test_unit_test_start.html"},{"title":"test_unit_test_stop – M_framework","text":"subroutine test_unit_test_stop() Arguments None Source Code subroutine test_unit_test_stop () call unit_test_start ( 'unit_test_stop' , msg = '' ) !      call unit_test_stop('unit_test_stop', .true.,'expression is true') !      call unit_test_stop('unit_test_stop', .false.,'expression is false') call unit_test_end ( 'unit_test_stop' , msg = '' ) end subroutine test_unit_test_stop","tags":"","url":"proc/test_unit_test_stop.html"},{"title":"test_flush_trail – M_framework","text":"subroutine test_flush_trail() call unit_test(‘flush_trail’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_flush_trail () implicit none call unit_test_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_test('flush_trail', 0.eq.0, 'checking',100) call unit_test_end ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail","tags":"","url":"proc/test_flush_trail.html"},{"title":"test_set_stdout_lun – M_framework","text":"subroutine test_set_stdout_lun() call unit_test(‘set_stdout_lun’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_set_stdout_lun () implicit none call unit_test_start ( 'set_stdout_lun' , msg = '' ) !!call unit_test('set_stdout_lun', 0.eq.0, 'checking',100) call unit_test_end ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun","tags":"","url":"proc/test_set_stdout_lun.html"},{"title":"test_where_write_message_all – M_framework","text":"subroutine test_where_write_message_all() call unit_test(‘where_write_message_all’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_where_write_message_all () implicit none call unit_test_start ( 'where_write_message_all' , msg = '' ) !!call unit_test('where_write_message_all', 0.eq.0, 'checking',100) call unit_test_end ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all","tags":"","url":"proc/test_where_write_message_all.html"},{"title":"test_write_message_only – M_framework","text":"subroutine test_write_message_only() call unit_test(‘write_message_only’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_write_message_only () implicit none call unit_test_start ( 'write_message_only' , msg = '' ) !!call unit_test('write_message_only', 0.eq.0, 'checking',100) call unit_test_end ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only","tags":"","url":"proc/test_write_message_only.html"},{"title":"test_compare_float_double – M_framework","text":"subroutine test_compare_float_double() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'compare_float double' Source Code subroutine test_compare_float_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float double' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( xd , dfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( yd1 , dfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( yd2 , dfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( yd3 , dfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( yd4 , dfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( xd , yd1 ), \"Compare_Float(xd, yd1)      =\" , compare_float ( xd , yd1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( xd , yd1 , ulp = 2 ), \"Compare_Float(xd, yd1,ulp=2)=\" , compare_float ( xd , yd1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( xd , yd2 ), \"Compare_Float(xd, yd2)      =\" , compare_float ( xd , yd2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( xd , yd3 ), \"Compare_Float(xd, yd3)      =\" , compare_float ( xd , yd3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( xd , yd3 , ulp = 2 ), \"Compare_Float(xd, yd3,ulp=2)=\" , compare_float ( xd , yd3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( xd , yd4 ), \"Compare_Float(xd, yd4)      =\" , compare_float ( xd , yd4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_double","tags":"","url":"proc/test_compare_float_double.html"},{"title":"test_compare_float_single – M_framework","text":"subroutine test_compare_float_single() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'compare_float single' Source Code subroutine test_compare_float_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float single' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( x , sfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( y1 , sfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( y2 , sfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( y3 , sfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( y4 , sfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , x . eq . y4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( x , y1 ), \"Compare_Float(x, y1)       = \" , compare_float ( x , y1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( x , y1 , ulp = 2 ), \"Compare_Float(x, y1,ulp=2) = \" , compare_float ( x , y1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( x , y2 ), \"Compare_Float(x, y2)       = \" , compare_float ( x , y2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( x , y3 ), \"Compare_Float(x, y3)       = \" , compare_float ( x , y3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( x , y3 , ulp = 2 ), \"Compare_Float(x, y3,ulp=2) = \" , compare_float ( x , y3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( x , y4 ), \"Compare_Float(x, y4)       = \" , compare_float ( x , y4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_single","tags":"","url":"proc/test_compare_float_single.html"},{"title":"test_elemental_double – M_framework","text":"subroutine test_elemental_double() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: title real(kind=real64), public, dimension(nums,2) :: xad real(kind=real64), public, dimension(nums) :: xvd real(kind=real64), public, dimension(nums,2) :: yad1 real(kind=real64), public, dimension(nums,2) :: yad2 real(kind=real64), public, dimension(nums,2) :: yad3 real(kind=real64), public, dimension(nums,2) :: yad4 real(kind=real64), public, dimension(nums) :: yvd1 real(kind=real64), public, dimension(nums) :: yvd2 real(kind=real64), public, dimension(nums) :: yvd3 real(kind=real64), public, dimension(nums) :: yvd4 Source Code subroutine test_elemental_double () real ( kind = real64 ), dimension ( nums ) :: xvd , yvd1 , yvd2 , yvd3 , yvd4 real ( kind = real64 ), dimension ( nums , 2 ) :: xad , yad1 , yad2 , yad3 , yad4 character ( len = :), allocatable :: title title = 'equalto double' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xvd = double_number yvd1 = nearest ( xvd , ( / ( 1.0_real64 , i = 1 , nums ) / ) ) yvd2 = yvd1 - spacing ( xvd ) yvd3 = nearest ( xvd , ( / ( - 1.0_real64 , i = 1 , nums ) / ) ) yvd4 = yvd3 + spacing ( xvd ) call unit_test_msg ( title , \"    xvd  = \" , str ( xvd ) ) call unit_test_msg ( title , \"    yvd1 = \" , str ( yvd1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yvd2 = \" , str ( yvd2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yvd3 = \" , str ( yvd3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yvd4 = \" , str ( yvd4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xvd , yvd1 )), \"Compare_Float(xvd, yvd1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd1 , ulp = 2 )), \"Compare_Float(xvd, yvd1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd2 )), \"Compare_Float(xvd, yvd2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xvd , yvd3 )), \"Compare_Float(xvd, yvd3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd3 , ulp = 2 )), \"Compare_Float(xvd, yvd3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd4 )), \"Compare_Float(xvd, yvd4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . equalto . yvd1 )), \"( xvd .equalto. yvd1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd2 )), \"( xvd .equalto. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xvd . equalto . yvd3 )), \"( xvd .equalto. yvd3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd4 )), \"( xvd .equalto. yvd4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd1 )), \"( xvd .greaterthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd2 )), \"( xvd .greaterthan. yvd2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xvd . greaterthan . yvd3 )), \"( xvd .greaterthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd4 )), \"( xvd .greaterthan. yvd4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . lessthan . yvd1 )), \"( xvd .lessthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd2 )), \"( xvd .lessthan. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd3 )), \"( xvd .lessthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd4 )), \"( xvd .lessthan. yvd4 )\" ) call unit_test_msg ( title , 'matrix' ) xad = reshape (( / double_number , double_number + ( dten * spacing ( double_number )) / ),( / nums , 2 / )) yad1 = nearest ( xad , reshape (( / ( 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad2 = yad1 - spacing ( xad ) yad3 = nearest ( xad , reshape (( / ( - 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad4 = yad3 + spacing ( xad ) call unit_test_msg ( title , \"    xad  = \" , str ([ xad ]) ) call unit_test_msg ( title , \"    yad1 = \" , str ([ yad1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yad2 = \" , str ([ yad2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yad3 = \" , str ([ yad3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yad4 = \" , str ([ yad4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 )), \"Compare_Float(xad,yad1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 , ulp = 2 )), \"Compare_Float(xad,yad1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad2 )), \"Compare_Float(xad,yad2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 )), \"Compare_Float(xad,yad3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 , ulp = 2 )), \"Compare_Float(xad,yad3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad4 )), \"Compare_Float(xad,yad4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad1 )), \"( xad .equalto. yad1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad2 )), \"( xad .equalto. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad3 )), \"( xad .equalto. yad3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad4 )), \"( xad .equalto. yad4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad1 )), \"( xad .greaterthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad2 )), \"( xad .greaterthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . greaterthan . yad3 )), \"( xad .greaterthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad4 )), \"( xad .greaterthan. yad4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . lessthan . yad1 )), \"( xad .lessthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad2 )), \"( xad .lessthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad3 )), \"( xad .lessthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad4 )), \"( xad .lessthan. yad4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_double","tags":"","url":"proc/test_elemental_double.html"},{"title":"test_elemental_single – M_framework","text":"subroutine test_elemental_single() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: title real(kind=real32), public, dimension(nums,2) :: xa real(kind=real32), public, dimension(nums) :: xv real(kind=real32), public, dimension(nums,2) :: ya1 real(kind=real32), public, dimension(nums,2) :: ya2 real(kind=real32), public, dimension(nums,2) :: ya3 real(kind=real32), public, dimension(nums,2) :: ya4 real(kind=real32), public, dimension(nums) :: yv1 real(kind=real32), public, dimension(nums) :: yv2 real(kind=real32), public, dimension(nums) :: yv3 real(kind=real32), public, dimension(nums) :: yv4 Source Code subroutine test_elemental_single () real ( kind = real32 ), dimension ( nums ) :: xv , yv1 , yv2 , yv3 , yv4 real ( kind = real32 ), dimension ( nums , 2 ) :: xa , ya1 , ya2 , ya3 , ya4 character ( len = :), allocatable :: title title = 'equalto single' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xv = single_number yv1 = nearest ( xv , ( / ( 1.0_real32 , i = 1 , nums ) / ) ) yv2 = yv1 - spacing ( xv ) yv3 = nearest ( xv , ( / ( - 1.0_real32 , i = 1 , nums ) / ) ) yv4 = yv3 + spacing ( xv ) call unit_test_msg ( title , \"    xv  = \" , str ( xv ) ) call unit_test_msg ( title , \"    yv1 = \" , str ( yv1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yv2 = \" , str ( yv2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yv3 = \" , str ( yv3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yv4 = \" , str ( yv4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xv , yv1 )), \"Compare_Float(xv, yv1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv1 , ulp = 2 )), \"Compare_Float(xv, yv1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv2 )), \"Compare_Float(xv, yv2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xv , yv3 )), \"Compare_Float(xv, yv3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv3 , ulp = 2 )), \"Compare_Float(xv, yv3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv4 )), \"Compare_Float(xv, yv4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . equalto . yv1 )), \"( xv .equalto. yv1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv2 )), \"( xv .equalto. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xv . equalto . yv3 )), \"( xv .equalto. yv3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv4 )), \"( xv .equalto. yv4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv1 )), \"( xv .greaterthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv2 )), \"( xv .greaterthan. yv2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xv . greaterthan . yv3 )), \"( xv .greaterthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv4 )), \"( xv .greaterthan. yv4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . lessthan . yv1 )), \"( xv .lessthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv2 )), \"( xv .lessthan. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv3 )), \"( xv .lessthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv4 )), \"( xv .lessthan. yv4 )\" ) call unit_test_msg ( title , 'matrix' ) xa = reshape (( / single_number , single_number + ( sten * spacing ( single_number )) / ),( / nums , 2 / )) ya1 = nearest ( xa , reshape (( / ( 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya2 = ya1 - spacing ( xa ) ya3 = nearest ( xa , reshape (( / ( - 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya4 = ya3 + spacing ( xa ) call unit_test_msg ( title , \"    xa  = \" , str ([ xa ]) ) call unit_test_msg ( title , \"    ya1 = \" , str ([ ya1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    ya2 = \" , str ([ ya2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    ya3 = \" , str ([ ya3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    ya4 = \" , str ([ ya4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 )), \"Compare_Float(xa,ya1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 , ulp = 2 )), \"Compare_Float(xa,ya1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya2 )), \"Compare_Float(xa,ya2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 )), \"Compare_Float(xa,ya3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 , ulp = 2 )), \"Compare_Float(xa,ya3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya4 )), \"Compare_Float(xa,ya4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya1 )), \"( xa .equalto. ya1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya2 )), \"( xa .equalto. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya3 )), \"( xa .equalto. ya3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya4 )), \"( xa .equalto. ya4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya1 )), \"( xa .greaterthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya2 )), \"( xa .greaterthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . greaterthan . ya3 )), \"( xa .greaterthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya4 )), \"( xa .greaterthan. ya4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . lessthan . ya1 )), \"( xa .lessthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya2 )), \"( xa .lessthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya3 )), \"( xa .lessthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya4 )), \"( xa .lessthan. ya4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_single","tags":"","url":"proc/test_elemental_single.html"},{"title":"test_equalto_double – M_framework","text":"subroutine test_equalto_double() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'equalto double' Source Code subroutine test_equalto_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . equalto . yd1 ), \"( x .equalto. y1 ) =\" , xd . equalto . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . equalto . yd2 ), \"( x .equalto. y2 ) =\" , xd . equalto . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . equalto . yd3 ), \"( x .equalto. y3 ) =\" , xd . equalto . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . equalto . yd4 ), \"( x .equalto. y4 ) =\" , xd . equalto . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_double","tags":"","url":"proc/test_equalto_double.html"},{"title":"test_equalto_single – M_framework","text":"subroutine test_equalto_single() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'equalto single' Source Code subroutine test_equalto_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , xd . eq . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . equalto . y1 ), \"( x .equalto. y1 ) =\" , x . equalto . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . equalto . y2 ), \"( x .equalto. y2 ) =\" , x . equalto . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . equalto . y3 ), \"( x .equalto. y3 ) =\" , x . equalto . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . equalto . y4 ), \"( x .equalto. y4 ) =\" , x . equalto . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_single","tags":"","url":"proc/test_equalto_single.html"},{"title":"test_greaterthan_double – M_framework","text":"subroutine test_greaterthan_double() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'greaterthan double' Source Code subroutine test_greaterthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . gt . yd1 , xd . gt . yd1 , xd . gt . yd2 , xd . gt . yd3 , xd . gt . yd3 , xd . gt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . greaterthan . yd1 ), \"( x .greaterthan. y1 ) =\" , xd . greaterthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . greaterthan . yd2 ), \"( x .greaterthan. y2 ) =\" , xd . greaterthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . greaterthan . yd3 ), \"( x .greaterthan. y3 ) =\" , xd . greaterthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . greaterthan . yd4 ), \"( x .greaterthan. y4 ) =\" , xd . greaterthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_double","tags":"","url":"proc/test_greaterthan_double.html"},{"title":"test_greaterthan_single – M_framework","text":"subroutine test_greaterthan_single() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'greaterthan single' Source Code subroutine test_greaterthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . gt . y1 , x . gt . y1 , x . gt . y2 , x . gt . y3 , x . gt . y3 , x . gt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . greaterthan . y1 ), \"( x .greaterthan. y1 ) =\" , x . greaterthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . greaterthan . y2 ), \"( x .greaterthan. y2 ) =\" , x . greaterthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . greaterthan . y3 ), \"( x .greaterthan. y3 ) =\" , x . greaterthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . greaterthan . y4 ), \"( x .greaterthan. y4 ) =\" , x . greaterthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_single","tags":"","url":"proc/test_greaterthan_single.html"},{"title":"test_lessthan_double – M_framework","text":"subroutine test_lessthan_double() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'lessthan double' Source Code subroutine test_lessthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . lt . yd1 , xd . lt . yd1 , xd . lt . yd2 , xd . lt . yd3 , xd . lt . yd3 , xd . lt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . lessthan . yd1 ), \"( x .lessthan. y1 ) =\" , xd . lessthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . lessthan . yd2 ), \"( x .lessthan. y2 ) =\" , xd . lessthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . lessthan . yd3 ), \"( x .lessthan. y3 ) =\" , xd . lessthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . lessthan . yd4 ), \"( x .lessthan. y4 ) =\" , xd . lessthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_double","tags":"","url":"proc/test_lessthan_double.html"},{"title":"test_lessthan_single – M_framework","text":"subroutine test_lessthan_single() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: expected (:) character(len=*), public, parameter :: title = 'lessthan single' Source Code subroutine test_lessthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . lt . y1 , x . lt . y1 , x . lt . y2 , x . lt . y3 , x . lt . y3 , x . lt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . lessthan . y1 ), \"( x .lessthan. y1 ) =\" , x . lessthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . lessthan . y2 ), \"( x .lessthan. y2 ) =\" , x . lessthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . lessthan . y3 ), \"( x .lessthan. y3 ) =\" , x . lessthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . lessthan . y4 ), \"( x .lessthan. y4 ) =\" , x . lessthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_single","tags":"","url":"proc/test_lessthan_single.html"},{"title":"fstop – M_framework","text":"public  subroutine fstop(ierr, stdout, stderr) NAME fstop ( 3 f ) - [ M_framework__utility ] call stop with both a number and a message ( LICENSE : PD ) SYNOPSIS subroutine fstop(ierr,stdout,stderr)\n\n integer,intent(in)                   :: ierr\n character(len=*),intent(in),optional :: stdout\n character(len=*),intent(in),optional :: stderr DESCRIPTION FSTOP ( 3 f ) call STOP ( 3 f ) . What a call to STOP does is very system dependent , so using an abstraction layer is useful , as it allows just the fstop () routine to be changed ; and STOP does not allow a variable to be used on the numeric access status ( this has changed at f2015 ) . OPTIONS ierr    - value in range 0 to 32\nstdout  - description to be printed to standard output\nstderr  - description to be printed to standard error EXAMPLES Sample program: program demo_fstop use M_framework__utility , only : fstop implicit none integer :: int !*! write (*,*) 'Enter stop value' !*! read (*,*) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = 'error: program will now stop' ) case ( 25 ) ; call fstop ( int , stdout = 'stdout message' , & & stderr = 'stderr message' ) case ( 30 ) ; call fstop ( int , stdout = 'error: program will now stop' ) case default call fstop ( int ) endselect end program demo_fstop Results: SEE ALSO Look for common extensions, such as abort(3f), backtrace(3f) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: stdout character(len=*), intent(in), optional :: stderr Source Code subroutine fstop ( ierr , stdout , stderr ) ! ident_1=\"@(#) M_framework__utility fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message\" integer , intent ( in ) :: ierr character ( len =* ), optional , intent ( in ) :: stdout character ( len =* ), optional , intent ( in ) :: stderr character ( len = 132 ) :: message ! The standard states: !   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the !   processor supports that concept. If the integer stop-code is used as the process exit status, the processor !   might be able to interpret only values within a limited range, or only a limited portion of the integer value !   (for example, only the least-significant 8 bits). !   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed, !   it is recommended that the value zero be supplied as the process exit status, if the processor supports that !   concept. !   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement. ! ! Conforming variants I have encountered include !    o printing a message such as 'STOP nnn' when the integer value is called !    o having a limit on the length of the message string passed !    o prefixing the message with the string 'STOP ' !    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument !      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...) !    o whether messages appear on stdout or stderr. !    o no value being returned to the system at all. ! !  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported. !  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated? ! !  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value. !  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system, !  but I sometimes want to return variables. ! !  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message !  to appear when using integer values ! !  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky !  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran !  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a !  value to the system and Fortran does not, but I do not recommend it. ! !  Note that the C function \"exit(int signal)\" not only works more consistently but that the global values EXIT_SUCCESS and !  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant. ! !  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure. !----------------------------------------------------------------------------------------------------------------------------------- !STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab' !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( stderr )) then ! write message to stderr, assuming string length is allowed if ( stderr /= '' ) then write ( error_unit , '(a)' ) trim ( stderr ) endif !f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED) !f2015!      case(0); allstop 0 !f2015!      case(1); allstop 1 !f2015!      case(2); allstop 2 !f2015!      case(3); allstop 3 !f2015!      case(4); allstop 4 !f2015!      case(5); allstop 5 !f2015!      case(6); allstop 6 !f2015!      case(7); allstop 7 !f2015!      case(8); allstop 8 !f2015!      case(9); allstop 8 !f2015!      case(10); allstop 10 !f2015!      case(11); allstop 11 !f2015!      case(12); allstop 12 !f2015!      case(13); allstop 13 !f2015!      case(14); allstop 14 !f2015!      case(15); allstop 15 !f2015!      case(16); allstop 16 !f2015!      case(17); allstop 17 !f2015!      case(18); allstop 18 !f2015!      case(19); allstop 19 !f2015!      case(20); allstop 20 !f2015!      case(21); allstop 21 !f2015!      case(22); allstop 22 !f2015!      case(23); allstop 23 !f2015!      case(24); allstop 24 !f2015!      case(25); allstop 25 !f2015!      case(26); allstop 26 !f2015!      case(27); allstop 27 !f2015!      case(28); allstop 28 !f2015!      case(29); allstop 29 !f2015!      case(30); allstop 30 !f2015!      case(31); allstop 31 !f2015!      case(32); allstop 32 !f2015!   case default !f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system' !f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error !f2015!      allstop 1 !f2015!   end select endif if ( present ( stdout )) then ! write message to stdout, assuming string length is allowed if ( stdout /= '' ) then write ( * , '(a)' ) trim ( stdout ) endif endif select case ( ierr ) ! have executable return an exit status to the system (IF SUPPORTED) case ( 0 ); stop 0 case ( 1 ); stop 1 case ( 2 ); stop 2 case ( 3 ); stop 3 case ( 4 ); stop 4 case ( 5 ); stop 5 case ( 6 ); stop 6 case ( 7 ); stop 7 case ( 8 ); stop 8 case ( 9 ); stop 8 case ( 10 ); stop 10 case ( 11 ); stop 11 case ( 12 ); stop 12 case ( 13 ); stop 13 case ( 14 ); stop 14 case ( 15 ); stop 15 case ( 16 ); stop 16 case ( 17 ); stop 17 case ( 18 ); stop 18 case ( 19 ); stop 19 case ( 20 ); stop 20 case ( 21 ); stop 21 case ( 22 ); stop 22 case ( 23 ); stop 23 case ( 24 ); stop 24 case ( 25 ); stop 25 case ( 26 ); stop 26 case ( 27 ); stop 27 case ( 28 ); stop 28 case ( 29 ); stop 29 case ( 30 ); stop 30 case ( 31 ); stop 31 case ( 32 ); stop 32 case default write ( message , '(a,i0,a)' ) '*fstop*: stop value of ' , ierr , ' returning 1 to system' write ( error_unit , '(a)' ) trim ( message ) ! write message to standard error stop 1 end select end subroutine fstop","tags":"","url":"proc/fstop.html"},{"title":"unit_test_system – M_framework","text":"public  function unit_test_system(command, verbose) result(istat) NAME unit_test_system ( 3 f ) - [ M_framework__verify ] return status from system command ( LICENSE : PD ) SYNOPSIS function unit_test_system ( cmd,verbose ) character ( len = * ), intent ( in ) :: cmd logical , intent ( in ), optional :: verbose DESCRIPTION unit_test_system ( 3 f ) executes a system command and returns the exit status of the command . OPTIONS command system command to execute . If it starts with \" * \" the asterisk is replaced by the name of the current command . If it starts with \" ** \" the asterisks are replaced by the current command including arguments . verbose if . true . the executed command is echoed to output . The default is . false . EXAMPLES Sample program: program demo_unit_test_system use M_framework , only : & unit_test_start , & unit_test , & unit_test_system , & unit_test_end implicit none if ( command_argument_count () == 0 ) then call unit_test_start ( ' myroutine ' ) call unit_test ( ' false ' , unit_test_system ( ' false ' ) == 0 , ' check false ' ) call unit_test ( ' true ' , unit_test_system ( ' true ' ) == 0 , ' check true ' ) call unit_test ( ' notthere ' , unit_test_system ( ' notthere ' ) == 0 , & & ' check notthere ' ) call unit_test ( ' * ' , & & unit_test_system ( ' * and options ' , verbose = . true . ) == 0 , ' check \"*\" ' ) call unit_test_end ( ' myroutine ' ) else write ( * , * ) ' called with an option ' endif end program demo_unit_test_system AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command logical, intent(in), optional :: verbose Return Value integer Source Code function unit_test_system ( command , verbose ) result ( istat ) !  EXITSTAT contains the integer exit code of the command, as returned by SYSTEM. !  CMDSTAT is set to zero if the command line was executed (whatever its exit status was). !          If an error condition occurs and CMDSTAT is not present, error termination of execution of the image is initiated. !     It is assigned !      + the value -1 if the processor does not support command line execution, !      + a processor-dependent positive value if an error condition occurs !      + the value -2 if no error condition occurs but WAIT is present !        with the value false and the processor does not support asynchronous !        execution. !      + Otherwise it is assigned the value 0. !  CMDMSG is assigned an error message if an error has occurred. (exitstat or cmdstat or both?) !         If an error condition occurs, it is assigned a processor- dependent explanatory message. Otherwise, it is unchanged. character ( len =* ), intent ( in ) :: command logical , intent ( in ), optional :: verbose logical :: verbose_ integer :: istat logical , parameter :: wait = . true . integer :: exitstat integer :: cmdstat character ( len = 256 ) :: cmdmsg character ( len = :), allocatable :: command_ if ( present ( verbose )) then verbose_ = verbose else verbose_ = . false . endif command_ = adjustl ( command ) // '   ' if ( index ( command_ , '* ' ) == 1 ) then command_ = getarg0_ () // command_ ( 2 :) elseif ( index ( command_ , '** ' ) == 1 ) then command_ = getall_ () // command_ ( 2 :) endif if ( verbose_ ) call wrt ( G_luns , \"command: \" , command_ ) cmdmsg = ' ' call execute_command_line ( command_ , wait , exitstat , cmdstat , cmdmsg ) flush ( unit = 6 ) if ( cmdstat /= 0 ) then call wrt ( G_luns , \"cmdstat: \" , cmdmsg , 'for command :' , command_ ) elseif ( cmdmsg /= '' ) then call wrt ( G_luns , \"exitstat: \" , cmdmsg , 'for command :' , command_ ) endif istat = merge ( - cmdstat , exitstat , exitstat == 0. and . cmdstat /= 0 ) end function unit_test_system","tags":"","url":"proc/unit_test_system.html"},{"title":"unit_test – M_framework","text":"public  subroutine unit_test(name, logical_expression, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, wordy) NAME unit_test ( 3 f ) - [ M_framework__verify ] report if logical expression is true or false , optionally call command and / or stop program . ( LICENSE : PD ) SYNOPSIS subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&\n& ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail)\n\n character(len=*),intent(in) :: name\n logical,intent(in) :: expression\n class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&\n & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj\n logical,intent(in),optional :: only_on_fail DESCRIPTION unit_test ( 3 f ) tests the expression and displays a message composed of the generic intrinsic values msg , and g1 thorough gj . Additionally , if the expression is false o if unit_test_mode ( command ) is not blank calls the specified shell command $C OMMAND name = \" NAME \" type = \" check \" passed = \" passed|failed \" ... msg = \" all messages \" o if keep_going = . false . stop the program on a failed test OPTIONS NAME the unit test name EXPRESSION the logical expression to evaluate msg , g1 ... gj optional message to display when performing test , composed of any scalar intrinsics of type INTEGER , REAL , DOUBLEPRECISION , COMPLEX , LOGICAL , or CHARACTER . A space is placed between each value . wordy If . false . The message MSG is only displayed if the expression is . false . . Must be used as a keyword . Default is . true . . EXAMPLES Sample program: program demo_unit_test use M_framework , only : & & unit_test_mode , & & unit_test_start , & & unit_test , & & unit_test_end , & & unit_test_stop use M_framework , only : almost implicit none integer :: i integer :: x integer , allocatable :: arr ( : ) real , allocatable :: arr1 ( : ) real , allocatable :: arr2 ( : ) call unit_test_mode ( keep_going = . true ., debug = . false ., command = '' ) x = 10 arr1 = [ 1 . 0 , 10 . 0 , 100 . 0 ] arr2 = [ 1 . 0001 , 10 . 001 , 100 . 01 ] call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) do i = 1 , size ( arr1 ) call unit_test ( ' myroutine ' , & & almost ( arr1 ( i ) , arr2 ( i ) , 3 . 9 , verbose = . true . ) ) enddo arr = [ 10 , 20 , 30 ] call unit_test ( ' myroutine ' , . not . any ( arr < 0 ) , & & ' fail if any negative values in array ARR ' ) call unit_test ( ' myroutine ' , all ( arr < 100 ) , & & ' fail unless all values are less than 100 in array ARR ' ) call unit_test_end ( ' myroutine ' , & & msg = ' checks on \"myroutine\" all passed ' ) call unit_test_stop () end program demo_unit_test Results: Sample output (varies with what optional command or modes is used): > check_start : myroutine START : > check : myroutine SUCCESS : if big enough > check : myroutine SUCCESS : if small enough >* almost * for values 1 . 00000000 1 . 00010002 agreement of 3 . 99997139 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : >* almost * for values 10 . 0000000 10 . 0010004 agreement of 3 . 99986792 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : >* almost * for values 100 . 000000 100 . 010002 agreement of 3 . 99995065 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : > check : myroutine SUCCESS : fail if any negative ... > values in array ARR > check : myroutine SUCCESS : fail unless all values ... > are less than 100 in array ARR > check_end : myroutine PASSED : GOOD : 7 BAD : ... > 0 DURATION : 00000000294709 : checks on \" myroutine \" all passed > check_stop : TALLY PASSED : GOOD : 7 BAD : ... > 0 DURATION : 00000000267059 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: wordy Source Code subroutine unit_test ( name , logical_expression , msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , force_keywd , wordy ) ! ident_2=\"@(#) M_framework__verify unit_test(3f) assert if expression is .true. or .false. and optionally call command or stop on .false.\" character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: logical_expression class ( * ), intent ( in ), optional :: msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( in ), optional :: wordy character ( len = :), allocatable :: msg_all logical :: wordy_local G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( wordy )) then wordy_local = wordy else wordy_local = . true . endif if ( G_virgin % cmdline ) call cmdline_ () msg_all = str ( msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if (. not . logical_expression ) then call wrt ( G_luns , CHECK_PREFIX % check // atleast_ ( name , G_LONGEST ) // ' FAILURE : ' // msg_all ) if ( G_command /= '' ) call run ( G_command // ' type=\"check\" name=\"' // trim ( name ) // '\" passed=\"failed\" msg=\"' // ndq ( msg_all ) // '\"' ) if (. not . G_keep_going ) then call wrt ( G_luns , CHECK_PREFIX % check // 'STOPPING PROGRAM ON FAILED TEST OF ' // trim ( name )) stop 1 endif IFAILED_G = IFAILED_G + 1 IFAILED_ALL_G = IFAILED_ALL_G + 1 else if (. not . G_brief ) then if ( wordy_local ) call wrt ( G_luns , CHECK_PREFIX % check // atleast_ ( name , G_LONGEST ) // ' SUCCESS : ' // msg_all ) endif if ( G_command /= '' ) call run ( G_command // ' type=\"check\" name=\"' // trim ( name ) // '\" passed=\"passed\" msg=\"' // ndq ( msg_all ) // '\"' ) IPASSED_G = IPASSED_G + 1 IPASSED_ALL_G = IPASSED_ALL_G + 1 endif end subroutine unit_test","tags":"","url":"proc/unit_test.html"},{"title":"unit_test_bad – M_framework","text":"public  subroutine unit_test_bad(name, opts, msg) NAME unit_test_bad ( 3 f ) - [ M_framework__verify ] call command \"goodbad NAME bad\" and stop program ( LICENSE : PD ) SYNOPSIS subroutine unit_test_bad(name,msg,opts)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION unit_test_bad ( 3 f ) calls the shell command goodbad NAME bad [ opts ] and stops the program . It is just a shortcut for calling call unit_test ( name ,. false .) call unit_test_end ( name , msg , opts ) EXAMPLES Sample program: program demo_unit_test_bad use M_framework , only : unit_test_start , unit_test use M_framework , only : unit_test_end , unit_test_stop use M_framework , only : unit_test_bad implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) if ( x /= 0 ) then call unit_test_bad ( ' myroutine ' , msg = ' checks on \"myroutine\" failed ' ) ! program execution stopped endif call unit_test_end ( ' myroutine ' ) call unit_test_stop ( ' myroutine ' ) end program demo_unit_test_bad AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg Source Code subroutine unit_test_bad ( name , opts , msg ) ! ident_6=\"@(#) M_framework__verify unit_test_bad(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_test ( name ,. false .) call unit_test_end ( name , opts_local , msg_local ) end subroutine unit_test_bad","tags":"","url":"proc/unit_test_bad.html"},{"title":"unit_test_end – M_framework","text":"public  subroutine unit_test_end(name, msg, opts) Uses iso_fortran_env NAME unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) SYNOPSIS subroutine unit_test_end(name,msg,opts)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION A message is shown including the duration of the tests If there have been no failures the optional shell command $C OMMAND name = \" name \" type = \" end \" passed = \" passed|failed|untested \" ... clicks = NNNN msg = \" message \" opts is executed EXAMPLES Sample program: program demo_unit_test_end use M_framework , only : unit_test_start use M_framework , only : unit_test use M_framework , only : unit_test_end implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) ! program execution stopped call unit_test_end ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_test_end AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts Source Code subroutine unit_test_end ( name , msg , opts ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_5=\"@(#) M_framework__verify unit_test_end(3f) end checking procedure \"name\"\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: msg character ( len =* ), intent ( in ), optional :: opts character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local character ( len = 4096 ) :: out character ( len = 9 ) :: pf integer ( kind = int64 ) :: milliseconds integer ( kind = int64 ) :: clicks_now G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_G == 0 ) then PF = 'UNTESTED:' endif if ( duration /= 0.0d0 ) then call system_clock ( clicks_now ) milliseconds = ( julian () - duration ) * 1000 milliseconds = clicks_now - clicks write ( out , '(\"' // CHECK_PREFIX % check_end // '\",a,  & & 1x,a,                            & & \" GOOD: \",a,                     & & \" BAD: \" ,a,                     & & \" DURATION: \",i20.20             & & )' ) & & atleast_ ( name , G_LONGEST ), & & PF , & & atleast_ ( str ( IPASSED_G ), 9 ), & & atleast_ ( str ( IFAILED_G ), 9 ), & & milliseconds else milliseconds = 0 write ( out , '(\"' // CHECK_PREFIX % check_end // '\",a,1x,a,\" GOOD: \",a,1x,\" BAD: \",a)' ) & & atleast_ ( name , G_LONGEST ), PF , atleast_ ( str ( IPASSED_G ), 9 ), atleast_ ( str ( IFAILED_G ), 9 ) endif if ( present ( msg )) then if (. not . G_brief . or .( IFAILED_G + IPASSED_G . eq . 0 ). or . IFAILED_G . ne . 0 ) then call wrt ( G_luns , trim ( out ) // ': ' // trim ( msg )) call wrt ( G_luns , '' ) endif else if (. not . G_brief . or .( IFAILED_G + IPASSED_G . eq . 0 ). or . IFAILED_G . ne . 0 ) then call wrt ( G_luns , out ) call wrt ( G_luns , '' ) endif endif if ( G_command /= '' ) then ! if system command name is not blank call system command if ( ipassed_G + ifailed_G == 0 ) then call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"untested\" clicks=0' , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) elseif ( ifailed_G == 0 ) then call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"passed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) else call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"failed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) endif endif if ( ifailed_G == 0 ) then if (. not . G_keep_going ) stop 1 ! stop program depending on mode endif IPASSED_G = 0 IFAILED_G = 0 duration = 0.0d0 if ( paws ()) continue end subroutine unit_test_end","tags":"","url":"proc/unit_test_end.html"},{"title":"unit_test_good – M_framework","text":"public  subroutine unit_test_good(name, msg, opts) NAME unit_test_good ( 3 f ) - [ M_framework__verify ] call command \"goodbad NAME good\" ( LICENSE : PD ) SYNOPSIS subroutine unit_test_good(name,msg,opts)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION A shortcut for call unit_test ( name ,. true . ) call unit_test_end ( name , opts , msg ) EXAMPLES Sample program: program demo_unit_test_good use M_framework , only : unit_test_start , unit_test_end use M_framework , only : unit_test , unit_test_good implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) call unit_test_good ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_test_good AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts Source Code subroutine unit_test_good ( name , msg , opts ) ! ident_7=\"@(#) M_framework__verify unit_test_good(3f) call 'goodbad NAME good'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_test ( name ,. true ., msg = msg_local ) call unit_test_end ( name , opts_local ) end subroutine unit_test_good","tags":"","url":"proc/unit_test_good.html"},{"title":"unit_test_mode – M_framework","text":"public  subroutine unit_test_mode(debug, keep_going, level, flags, command, brief, verbose, silent, cmdline, interactive, luns, match) NAME unit_test_mode ( 3 f ) - [ M_framework__verify ] set testing modes ( LICENSE : PD ) SYNOPSIS subroutine unit_test_mode( keep_going, flags, luns, command, &\n  brief, interactive, CMDLINE, debug, match)\n\n  logical,intent(in) :: keep_going, brief, interactive,debug\n  integer,intent(in),allocatable :: luns(:), flags(:)\n  character(len=*),intent(in) :: command DESCRIPTION unit_test_mode(3f) changes testing mode defaults OPTIONS keep_going keep running if a test fails . Default to TRUE flags a list of integer values that can be accessed from M_framework as unit_test_flags (:) for use in selecting various tests conditionally luns list of Fortran units to unit test messages to . Defaults to the the value of ERROR_UNIT from the intrinsic module ISO_FORTRAN_ENV ( ie . defaults to \"stderr\" ) . It is Assumed the units have been opened by the program . match the string that is tested against the name and msg specified on unit_test_start () to set the \"matched\" argument . command filter command , typically to generate reports . It is passed data on the command line . See the example filter \"bookkeeper\" for examples . brief If present only \"FAIL\" messages are produced . brief Only display FAIL messages and related information verbose verbose mode displays compiler version and options and all standard messages . silent no output from unit_test_ * ( 3 f ) procedures interactive prompt as each test case starts as to continue . cmdline If set to . false . do not parse command line for options . debug Debug mode for the M_framework package EXAMPLES Sample program: program demo_unit_test_mode use M_framework implicit none call unit_test_mode ( keep_going = . false ., luns = [ 6 ], & & brief = . true . ) end program demo_unit_test_mode AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: debug logical, intent(in), optional :: keep_going integer, intent(in), optional :: level integer, intent(in), optional :: flags (:) character(len=*), intent(in), optional :: command logical, intent(in), optional :: brief logical, intent(in), optional :: verbose logical, intent(in), optional :: silent logical, intent(in), optional :: cmdline logical, intent(in), optional :: interactive integer, intent(in), optional :: luns (:) character(len=*), intent(in), optional :: match Source Code subroutine unit_test_mode ( debug , keep_going , level , flags , command , brief , verbose , silent , cmdline , interactive , luns , match ) logical , optional , intent ( in ) :: debug logical , optional , intent ( in ) :: keep_going ! logical variable that can be used to turn off program termination on errors. logical , optional , intent ( in ) :: cmdline ! flag whether to parse command line for arguments or not logical , optional , intent ( in ) :: interactive logical , optional , intent ( in ) :: brief ! flag on whether to display SUCCESS: messages logical , optional , intent ( in ) :: verbose ! flag on whether to display all messages including additional information logical , optional , intent ( in ) :: silent ! do not output any messages from unit_test_*(3f) procedures character ( len =* ), optional , intent ( in ) :: command ! name of command to execute. Defaults to the name integer , optional , intent ( in ) :: flags (:) ! an  array that can be used to select different options integer , optional , intent ( in ) :: level ! an  integer that can be used to select different debug levels integer , optional , intent ( in ) :: luns (:) ! logical unit number to write output to character ( len =* ), optional , intent ( in ) :: match if ( G_virgin % preset_globals ) then call preset_globals () endif if ( present ( match )) G_match = match if ( present ( luns )) G_luns = luns if ( present ( command )) G_command = command if ( present ( debug )) G_debug = debug if ( present ( cmdline )) G_cmdline = cmdline if ( present ( interactive )) G_interactive = interactive if ( present ( keep_going )) G_keep_going = keep_going if ( present ( flags )) unit_test_flags = flags if ( present ( level )) unit_test_level = level if ( present ( brief )) G_brief = brief if ( present ( verbose )) G_verbose = verbose if ( present ( silent )) G_silent = silent !integer,parameter,public   :: realtime=kind(0.0d0)    ! type for julian days !integer,parameter,public   :: EXIT_SUCCESS=0 !integer,parameter,public   :: EXIT_FAILURE=1 end subroutine unit_test_mode","tags":"","url":"proc/unit_test_mode.html"},{"title":"unit_test_msg – M_framework","text":"public  subroutine unit_test_msg(name, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, if) NAME unit_test_msg ( 3 f ) - [ M_framework__verify ] converts up to twenty standard scalar values to a message for unit testing ( LICENSE : PD ) SYNOPSIS function unit_test_msg ( name , msg , & & g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , if ) character ( len = * ), intent ( in ) :: name class ( * ), intent ( in ), optional :: msg , & & g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj DESCRIPTION unit_test_msg(3f) builds a string from up to twenty scalar values and\nprints it to the error log. OPTIONS name name of unit being tested msg , g [ 1 - j ] optional values to print the value of . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . if expression must be true or message is not output . Must be specified by keyword as \" if=expression \" . EXAMPLES Sample program: program demo_unit_test_msg use M_framework , only : unit_test_start , unit_test_msg , & & unit_test_end implicit none call unit_test_start ( ' myroutine ' ) call unit_test_msg ( ' myroutine ' , ' HUGE(3f) integers ' , & & huge ( 0 ) , ' and real ' , huge ( 0 . 0 ) , ' and double ' , huge ( 0 . 0 d0 )) call unit_test_msg ( ' myroutine ' , ' real            : ' , & & huge ( 0 . 0 ) , 0 . 0 , 12345 . 6789 , tiny ( 0 . 0 ) ) call unit_test_msg ( ' myroutine ' , ' doubleprecision : ' , & & huge ( 0 . 0 d0 ) , 0 . 0 d0 , 12345 . 6789 d0 , tiny ( 0 . 0 d0 ) ) call unit_test_msg ( ' myroutine ' , ' complex         : ' , & & cmplx ( huge ( 0 . 0 ) , tiny ( 0 . 0 )) ) call unit_test_end ( ' myroutine ' ) end program demo_unit_test_msg AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: if Source Code subroutine unit_test_msg ( name , msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , force_keywd , if ) implicit none ! ident_1=\"@(#) M_framework__verify unit_test_msg(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: name class ( * ), intent ( in ), optional :: msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( in ), optional :: if character ( len = :), allocatable :: msg_all logical :: if_local G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( if )) then if_local = if else if_local = . true . endif if ( G_virgin % cmdline ) call cmdline_ () if ( if_local ) then msg_all = str ( msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if (. not . G_brief ) then ! write message to standard error call wrt ( G_luns , CHECK_PREFIX % check_msg // atleast_ ( name , G_LONGEST ) // ' INFO    : ' // msg_all ) endif if ( G_command /= '' ) call run ( G_command // ' type=\"message\"  name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_all ) // '\"' ) endif end subroutine unit_test_msg","tags":"","url":"proc/unit_test_msg.html"},{"title":"unit_test_start – M_framework","text":"public  subroutine unit_test_start(name, msg, opts, force_keywd, matched) NAME unit_test_start ( 3 f ) - [ M_framework__verify ] reset counters and start a new test block ( LICENSE : PD ) SYNOPSIS subroutine unit_test_start(name,msg,opts,matched)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts\n logical,intent(out),optional         :: matched DESCRIPTION unit_test_start ( 3 f ) is an initialization procedure for starting a new procedure test . OPTIONS NAME name of the procedure to test MSG message to print OPTS pass additional options to the optional shell command that can be assigned on the command line or by unit_test_mode ( 3f ). MATCHED if the match string has been set with unit_test_mode ( 3f ) or on the command line this will return true if the name and msg concatenated with a space match the entire match string , where \"*\" matches any string and \"?\" matches any single character . This allows you to skip a test set if you wish by exiting . EXAMPLES Sample program: program demo_unit_test_start use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_mode , unit_test_stop implicit none integer :: ival logical :: matched call unit_test_mode () call test_mysub1 () call test_mysub2 () call unit_test_stop () contains subroutine test_mysub1 () ! first test call unit_test_start ( ' mysub1 ' ) ! the example goodbad ( 1 ) command called here takes many options ! used to build an SQLite3 entry ival = 10 call unit_test ( ' mysub1 ' , ival > 3 , msg = ' if big enough ' ) call unit_test ( ' mysub1 ' , ival < 100 , msg = ' if small enough ' ) call unit_test_end ( ' mysub1 ' , msg = ' completed checks of \"mysub1\" ' ) end subroutine test_mysub1 subroutine test_mysub2 () ! second test call unit_test_start ( ' mysub1 ' , '' , matched = matched ) ival = 200 if ( . not . matched ) return ! makes it skippable call unit_test ( ' mysub1 ' , ival > 3 , msg = ' if big enough ' ) call unit_test ( ' mysub1 ' , ival < 100 , msg = ' if small enough ' ) call unit_test_end ( ' mysub1 ' , msg = ' completed checks of \"mysub2\" ' ) end subroutine test_mysub2 end program demo_unit_test_start AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(out), optional :: matched Source Code subroutine unit_test_start ( name , msg , opts , force_keywd , matched ) ! ident_3=\"@(#) M_framework__verify unit_test_start(3f) start testing procedure \"name\"\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: msg character ( len =* ), intent ( in ), optional :: opts type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( out ), optional :: matched character ( len = :), allocatable :: msg_local logical , save :: called = . false . G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( msg )) then msg_local = trim ( msg ) else msg_local = '' endif if ( G_virgin % cmdline ) call cmdline_ () ! check optional matched string and return if string is not blank and not matched. ! It is assumed program will skip the subsequent test if ( present ( matched )) then if ( G_match . ne . '' ) then matched = glob_ ( name // ' ' // msg_local , G_match ) if (. not . matched ) return endif matched = . true . endif if ( present ( opts )) then if ( G_command /= '' ) call run ( G_command // ' type=\"start\" name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_local ) // '\" ' // opts ) else if ( G_command /= '' ) call run ( G_command // ' type=\"start\" name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_local ) // '\"' ) endif call system_clock ( clicks ) duration = julian () if (. not . called ) then call system_clock ( clicks_all ) duration_all = julian () called = . true . endif if (. not . G_brief ) then call wrt ( G_luns , CHECK_PREFIX % check_start // atleast_ ( name , G_LONGEST ) // ' START   : ' // msg_local ) endif IPASSED_G = 0 IFAILED_G = 0 end subroutine unit_test_start","tags":"","url":"proc/unit_test_start.html"},{"title":"unit_test_stop – M_framework","text":"public  subroutine unit_test_stop(msg) Uses iso_fortran_env NAME unit_test_stop ( 3 f ) - [ M_framework__verify ] report tally of all checks and stop program ( LICENSE : PD ) SYNOPSIS subroutine unit_test_stop(msg,opts)\n\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION give a tally of all calls to unit_test ( 3 f ) and stop program . Tally up the test result totals and stop the program . If a command is set via unit_test_mode ( 3 f ) or the command line call it appending OPTS to the end of the command . OPTIONS MSG additional message to display OPTS add string to filter command line if any is specified . EXAMPLES Sample program: program demo_unit_test_stop use M_framework , only : unit_test_start , unit_test_end , & & unit_test , unit_test_stop , unit_test_mode use , intrinsic :: iso_fortran_env , stdout => OUTPUT_UNIT implicit none integer :: x x = 10 call unit_test_mode ( luns =[ stdout ] ) ! do a test call unit_test_start ( 'proc1' ) call unit_test ( 'proc1' , x > 3 , 'if big enough' ) call unit_test ( 'proc1' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc1' , msg = 'checks all done' ) ! do another test call unit_test_start ( 'proc2' ) call unit_test ( 'proc2' , x > 3 , 'if big enough' ) call unit_test ( 'proc2' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc2' , msg = 'checks all done' ) ! tally up test results and stop program call unit_test_stop () end program demo_unit_test_stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg Source Code subroutine unit_test_stop ( msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_4=\"@(#) M_framework__verify unit_test_stop(3f) stop program with report on calls to unit_test(3f)\" character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = 4096 ) :: out character ( len = :), allocatable :: PF integer ( kind = int64 ) :: milliseconds integer ( kind = int64 ) :: clicks_now if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif call system_clock ( clicks_now ) milliseconds = ( julian () - duration_all ) * 1000 milliseconds = clicks_now - clicks_all PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_all_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_all_G == 0 ) then PF = 'UNTESTED:' endif write ( out , '(\"' // CHECK_PREFIX % check_stop // '\",a,1x,a,\" GOOD: \",a,\" BAD: \",a,\" DURATION: \",i20.20)' ) & & atleast_ ( \"TALLY\" , G_LONGEST ), & & PF , & & atleast_ ( str ( IPASSED_ALL_G ), 9 ), & & atleast_ ( str ( IFAILED_ALL_G ), 9 ), & & milliseconds if ( present ( msg )) then if (. not . G_brief . or .( IFAILED_ALL_G + IPASSED_ALL_G . eq . 0 ). or . IFAILED_ALL_G . ne . 0 ) & & call wrt ( G_luns , trim ( out ) // ': ' // trim ( msg )) else if (. not . G_brief . or .( IFAILED_ALL_G + IPASSED_ALL_G . eq . 0 ). or . IFAILED_ALL_G . ne . 0 ) & & call wrt ( G_luns , out ) endif if ( PF == 'UNTESTED' ) then if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"untested\" clicks=0 msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop ! EXIT_SUCCESS elseif ( IFAILED_ALL_G == 0 ) then if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"passed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop ! EXIT_SUCCESS else if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"failed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop EXIT_FAILURE endif end subroutine unit_test_stop","tags":"","url":"proc/unit_test_stop.html"},{"title":"unit_check – M_framework","text":"public interface unit_check Module Procedures public  subroutine unit_test (name, logical_expression, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, wordy) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: wordy","tags":"","url":"interface/unit_check.html"},{"title":"unit_check_bad – M_framework","text":"public interface unit_check_bad Module Procedures public  subroutine unit_test_bad (name, opts, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg","tags":"","url":"interface/unit_check_bad.html"},{"title":"unit_check_done – M_framework","text":"public interface unit_check_done Module Procedures public  subroutine unit_test_end (name, msg, opts) unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts","tags":"","url":"interface/unit_check_done.html"},{"title":"unit_check_good – M_framework","text":"public interface unit_check_good Module Procedures public  subroutine unit_test_good (name, msg, opts) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts","tags":"","url":"interface/unit_check_good.html"},{"title":"unit_check_mode – M_framework","text":"public interface unit_check_mode Module Procedures public  subroutine unit_test_mode (debug, keep_going, level, flags, command, brief, verbose, silent, cmdline, interactive, luns, match) Sample program: Read more… Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: debug logical, intent(in), optional :: keep_going integer, intent(in), optional :: level integer, intent(in), optional :: flags (:) character(len=*), intent(in), optional :: command logical, intent(in), optional :: brief logical, intent(in), optional :: verbose logical, intent(in), optional :: silent logical, intent(in), optional :: cmdline logical, intent(in), optional :: interactive integer, intent(in), optional :: luns (:) character(len=*), intent(in), optional :: match","tags":"","url":"interface/unit_check_mode.html"},{"title":"unit_check_msg – M_framework","text":"public interface unit_check_msg Module Procedures public  subroutine unit_test_msg (name, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, if) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: if","tags":"","url":"interface/unit_check_msg.html"},{"title":"unit_check_start – M_framework","text":"public interface unit_check_start Module Procedures public  subroutine unit_test_start (name, msg, opts, force_keywd, matched) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(out), optional :: matched","tags":"","url":"interface/unit_check_start.html"},{"title":"unit_check_stop – M_framework","text":"public interface unit_check_stop Module Procedures public  subroutine unit_test_stop (msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg","tags":"","url":"interface/unit_check_stop.html"},{"title":"unit_test_done – M_framework","text":"public interface unit_test_done Module Procedures public  subroutine unit_test_end (name, msg, opts) unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts","tags":"","url":"interface/unit_test_done.html"},{"title":"unit_test_expected – M_framework","text":"public interface unit_test_expected Module Procedures private impure elemental subroutine unit_test_expected_int32(name, result, expected) NAME unit_test_expected ( 3 f ) - [ M_framework__verify ] report if two scalar values of like type and kind are equal . ( LICENSE : PD ) SYNOPSIS impure elemental subroutine unit_test_example(name,result,expected)\n\n character(len=*),intent(in)  :: name\n class(*),intent(in)          :: result\n class(*),intent(in),optional :: expected DESCRIPTION A shortcut for a common call to unit_test ( 3 f ) tests the two values of like type and kind . It is equivalent to call unit_test ( name , result , expected , ' result= ' , result , ' expected= ' ,. true . ) OPTIONS RESULT A generated value or expression of integer , real , character , or complex type . EXPECTED The expected value for RESULT , of the same type and kind as RESULT . If not present , it is equivalent to . TRUE . EXAMPLES Sample program: program demo_unit_test_expected use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit use M_framework , only : & & unit_test_mode , & & start => unit_test_start , & & expected => unit_test_expected , & & stop => unit_test_stop , & & unit_test_level ! , unit_test_flags implicit none logical , parameter :: T = . true ., F = . false . ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags =[ 0 ] , & luns =[ stderr ] , & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 ! unit tests for ABS ( 3 f ) intrinsic call start ( 'abs' ) ! integer call expected ( 'abs' , abs ( - 10 ), 10 ) call expected ( 'abs' , abs ( 10 ), 10 ) ! real and elemental call expected ( 'abs' , abs ( [ -10.0, 10.0 ] ), 10.0 ) ! complex call expected ( 'abs' , abs (( 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( 3.0 , 4.0 )), 5.0 ) call stop ( 'abs' ) end program demo_unit_test_expected AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: result integer(kind=int32), intent(in) :: expected private impure elemental subroutine unit_test_expected_int64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer(kind=int64), intent(in) :: result integer(kind=int64), intent(in) :: expected private impure elemental subroutine unit_test_expected_char(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: result character(len=*), intent(in) :: expected private impure elemental subroutine unit_test_expected_boolean(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: result logical, intent(in) :: expected private impure elemental subroutine unit_test_expected_onoff(name, result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: result private impure elemental subroutine unit_test_expected_real32(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=real32), intent(in) :: result real(kind=real32), intent(in) :: expected private impure elemental subroutine unit_test_expected_real64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=real64), intent(in) :: result real(kind=real64), intent(in) :: expected private impure elemental subroutine unit_test_expected_cmplx32(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name complex(kind=real32), intent(in) :: result complex(kind=real32), intent(in) :: expected private impure elemental subroutine unit_test_expected_cmplx64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name complex(kind=real64), intent(in) :: result complex(kind=real64), intent(in) :: expected","tags":"","url":"interface/unit_test_expected.html"},{"title":"attr_mode – M_framework","text":"public  subroutine attr_mode(manner) NAME attr_mode ( 3 f ) - [ M_framework__attr ] select processing mode for output from attr ( 3 f ) ( LICENSE : MIT ) SYNOPSIS subroutine attr_mode(manner)\n\n    character(len=*),intent(in) :: manner DESCRIPTION Turn off the generation of strings associated with the HTML keywords in the string generated by the attr ( 3 f ) function , or display the text in raw mode as it was passed to attr ( 3 f ) or return to ANSI escape control sequence generation . OPTIONS MANNER The current manners or modes supported via the attr_mode ( 3 f ) procedure are plain suppress the output associated with keywords color ( default ) commonly supported escape sequences raw echo the input to attr ( 3 f ) as its output reload restore original keyword meanings deleted or replaced by calls to attr_update ( 3 f ) . EXAMPLES Sample program\n\n program demo_attr_mode\n use M_framework__attr, only : attr, attr_mode\n implicit none\n character(len=:),allocatable :: lines(:)\n character(len=:),allocatable :: outlines(:)\n integer :: i\n    lines=[character(len=110):: & & ' <M><y> ', & & ' <M><y> Suffice it to say that black and white are also colors', & & ' <M><y> for their simultaneous contrast is as striking as that ', & & ' <M><y> of green and red, for instance. & & --- <y><bo> Vincent van Gogh </bo></y> ', & & ' ']\n\n    outlines=attr(lines,chars=57)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n    call attr_mode(manner='plain') ! write as plain text\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='raw')   ! write as-is\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='ansi')  ! return to default mode\n\n end program demo_attr_mode AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner Source Code subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode","tags":"","url":"proc/attr_mode.html"},{"title":"attr_update – M_framework","text":"public  subroutine attr_update(key, valin, mono_valin) NAME attr_update ( 3 f ) - [ M_framework__attr ] update internal dictionary given keyword and value ( LICENSE : MIT ) SYNOPSIS subroutine attr_update(key,val)\n\n character(len=*),intent(in)           :: key\n character(len=*),intent(in),optional  :: val\n character(len=*),intent(in),optional  :: mono_val DESCRIPTION Update internal dictionary in M_framework__attr(3fm) module. OPTIONS key name of keyword to add , replace , or delete from dictionary val if present add or replace value associated with keyword . If not present remove keyword entry from dictionary . mono_val if present add or replace second value associated with keyword used for plain text mode . Must only be specified if VAL is also specified . KEYWORDS The following keywords are defined by default colors : r , red c , cyan w , white g , green m , magenta e , ebony b , blue y , yellow If the color keywords are capitalized they control the text background instead of the text color . attributes : ul , underline it , italics ( often produces inverse colors on many devices EXAMPLES Sample program\n\n  program demo_update\n  use M_framework__attr, only : attr, attr_update\n     write(*,'(a)') attr(' <clear> TEST CUSTOMIZATIONS:')\n     ! add custom keywords\n     call attr_update('blink',char(27)//'[5m')\n     call attr_update('/blink',char(27)//'[25m')\n     write(*,*)\n     write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n     call attr_update('ouch',attr( & ' <R><bo><w> BIG mistake! </R></w> '))\n     write(*,*)\n     write(*,'(a)') attr(' <ouch> Did not see that coming.')\n     write(*,*)\n     write(*,'(a)') attr( & 'ORIGINALLY: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n     ! delete\n     call attr_update('r')\n     call attr_update('/r')\n     ! replace (or create)\n     call attr_update('b',' <<<< ')\n     call attr_update('/b','>>>>')\n     write(*,*)\n     write(*,'(a)') attr( & 'CUSTOMIZED: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n  end program demo_update AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin Source Code subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update","tags":"","url":"proc/attr_update.html"},{"title":"attr – M_framework","text":"public interface attr Module Procedures private  function attr_scalar(string, reset) result(expanded) NAME attr ( 3 f ) - [ M_framework__attr ] substitute escape sequences for HTML - like syntax in strings ( LICENSE : MIT ) SYNOPSIS function attr(string,reset) result ( expanded ) ! scalar character ( len = * ), intent ( in ) :: string logical , intent ( in ), optional :: reset character ( len =:), allocatable :: expanded ! or array character ( len = * ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset character ( len =:), allocatable :: expanded (:) integer , intent ( in ), optional :: chars DESCRIPTION Use HTML-like syntax to add attributes to terminal output such as\ncolor on devices that recognize ANSI escape sequences. OPTIONS string        input string  of form\n\n                \" <attribute_name> string </attribute_name> ...\".\n\n               where the current attributes are color names,\n               bold, italic, underline, ...\n\nreset          By default, a sequence to clear all text attributes\n               is sent at the end of each returned line if an escape\n               character appears in the output string. This can be\n               turned off by setting RESET to .false. .\n\n               Note if turning off the reset attributes may be\n               continued across lines, but if each line is not\n               self-contained attributes may not display properly\n               when filtered with commands such as grep(1).\n\nchars          For arrays, a reset will be placed after the Nth\n               displayable column count in order to make it easier\n               to generate consistent right borders for non-default\n               background colors for a text block. KEYWORDS primary default keywords colors: r , red , R , RED g , green , G , GREEN b , blue , B , BLUE m , magenta , M , MAGENTA c , cyan , C , CYAN y , yellow , Y , YELLOW e , ebony , E , EBONY w , white , W , WHITE attributes: it , italic bo , bold un , underline basic control characters: nul bel ( 0 x07 , &#94; G ) beeps ; bs ( 0 x08 , &#94; H ) backspaces one column ( but not past the beginning of the line ); ht ( 0 x09 , &#94; I ) goes to the next tab stop or to the end of the line if there is no earlier tab stop ; lf ( 0 x0A , &#94; J ), vt ( 0 x0B , &#94; K ) ff ( 0 x0C , &#94; L ) all give a linefeed , and if LF / NL ( new - line mode ) is set also a carriage return cr ( 0 x0D , &#94; M ) gives a carriage return ; so ( 0 x0E , &#94; N ) activates the G1 character set ; si ( 0 x0F , &#94; O ) activates the G0 character set ; can ( 0 x18 , &#94; X ) and SUB ( 0 x1A , &#94; Z ) interrupt escape sequences ; sub esc ( 0 x1B , &#94; [) starts an escape sequence ; del ( 0 x7F ) is ignored ; other: clear default reset gt lt save , DECSC Save current state ( cursor coordinates , attributes , character sets pointed at by G0 , G1 ). restore , DECRC Restore state most recently saved by ESC 7. CSI \"Control Sequence Introducer\" ( 0 x9B ) is equivalent to \"ESC [\" . dual - value ( one for color , one for mono ) : write ( * , * ) attr (' < ERROR > an error message ') write ( * , * ) attr (' < WARNING > a warning message ') write ( * , * ) attr (' < INFO > an informational message ') By default , if the color mnemonics ( ie . the keywords ) are uppercase they change the background color . If lowercase , the foreground color . When preceded by a \"/\" character the attribute is returned to the default . The \"default\" keyword is typically used explicitly when reset = . false , and sets all text attributes to their initial defaults . LIMITATIONS o colors are not nestable , keywords are case - sensitive , o not all terminals obey the sequences . On Windows , it is best if you use Windows 10 + and / or the Linux mode ; although it has worked with all CygWin and MinGW and Putty windows and mintty . o you should use \" <gt> \" and \" <lt> \" instead of \" > \" and \" < \" in a string processed by attr ( 3 f ) instead of in any plain text output so that the raw mode will create correct input for the attr ( 3 f ) function if read back in . EXAMPLES Sample program\n\n program demo_attr\n use M_framework__attr, only : attr, attr_mode, attr_update\n    call printstuff('defaults')\n\n    call attr_mode(manner='plain')\n    call printstuff('plain:')\n\n    call printstuff('raw')\n\n    call attr_mode(manner='color')\n    call printstuff('')\n\n    write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:')\n    call attr_update('blink',char(27)//'[5m')\n    call attr_update('/blink',char(27)//'[25m')\n    write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n\n contains\n subroutine printstuff(label)\n character(len=*),intent(in)  :: label\n character(len=:),allocatable :: array(:)\n   call attr_mode(manner=label)\n\n   array=[character(len=60) :: & 'TEST MANNER='//label, & ' <r> RED </r> , <g> GREEN </g> , <b> BLUE </b> ', & ' <c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y> ', & ' <w> WHITE </w> and <e> EBONY </e> ']\n   write(*,'(a)') attr(array)\n\n   write(*,'(a)') attr('Adding <bo> bold </bo> ')\n   write(*,'(a)') attr(' <bo><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></bo> ')\n   write(*,'(a)') attr(' <bo><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y></bo> ')\n   write(*,'(a)') attr(' <bo><w> WHITE </w> and <e> EBONY </e></bo> ')\n\n   write(*,'(a)') attr('Adding <ul> underline </ul> ')\n   write(*,'(a)') attr( & & ' <bo><ul><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></ul></bo> ')\n   write(*,'(a)') attr( & & ' <bo><ul><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y></ul></bo> ')\n   write(*,'(a)') attr(' <bo><ul><w> WHITE </w> and <e> EBONY </e></ul></bo> ')\n\n   write(*,'(a)') attr('Adding <ul> italic </ul> ')\n   write(*,'(a)') attr( & & ' <bo><ul><it><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></it></ul></bo> ')\n   write(*,'(a)') attr( & & ' <bo><ul><it><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </it></y></ul></bo> ')\n   write(*,'(a)') attr(' <bo><ul><it><w> WHITE </w> and <e> EBONY </e></ul></bo> ')\n\n   write(*,'(a)') attr('Adding <in> inverse </in> ')\n   write(*,'(a)') attr(' <in><bo><ul><it><r> RED </r> , <g> GREEN </g> , & & <b> BLUE </b></it></ul></bo></in> ')\n   write(*,'(a)') attr(' <in><bo><ul><it><c> CYAN </c> , <m> MAGENTA </g> , & & <y> YELLOW </it></y></ul></bo></in> ')\n   write(*,'(a)') attr( & & ' <in><bo><ul><it><w> WHITE </w> and <e> EBONY </e></ul></bo></in> ')\n end subroutine printstuff\n end program demo_attr AUTHOR John S. Urban, 2021 LICENSE MIT SEE ALSO attr_mode(3f), attr_update(3f) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:), allocatable private  function attr_matrix(strings, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:), allocatable, (:) private  function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:), allocatable","tags":"","url":"interface/attr.html"},{"title":"almost – M_framework","text":"public impure elemental function almost(x, y, digits, verbose) Uses M_framework__journal NAME almost ( 3 f ) - [ M_framework__approx ] return true or false if two numbers agree up to specified number of digits ( LICENSE : PD ) SYNOPSIS elemental impure function almost(x,y,digits,verbose)\n\n class(*),intent(in)         :: x,y\n class(*),intent(in)         :: rdigits\n logical,intent(in),optional :: verbose\n logical                     :: almost DESCRIPTION Returns true or false depending on whether the two numbers given agree\nto within the specified number of digits as calculated by ACCDIG(3f). OPTIONS x,y      expected and calculated values to be compared. May be of\n         type REAL, INTEGER, or DOUBLEPRECISION.\nrdigits  number of digits of precision to compare. May be INTEGER or\n         REAL.\nverbose  optional value that specifies to print the results of the\n         comparison when set to .TRUE.. RETURNS almost TRUE if the input values compare up to the specified number of values EXAMPLES sample: program demo_almost use M_framework__approx , only : almost implicit none real :: x , y logical :: z integer :: i x = 1 . 2345678 y = 1 . 2300000 do i = 1 , 8 z = almost ( x , y , i , verbose = . true . ) write ( * , * ) i , z enddo end program demo_almost Results: > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 1 . 00000000 > 1 T > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 2 . 00000000 > 2 T > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 3 . 00000000 > 3 F > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 4 . 00000000 > 4 F > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 5 . 00000000 > 5 F > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 6 . 00000000 > 6 F > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 7 . 00000000 > 7 F > * sp_accdig * significant digit request too high = 8 . 00000000 > * almost * for values 1 . 23456776 1 . 23000002 agreement of 2 . 43020344 ... > digits out of requested 8 . 00000000 > 8 F AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digits logical, intent(in), optional :: verbose Return Value logical Source Code elemental impure function almost ( x , y , digits , verbose ) use M_framework__journal , only : journal ! ident_1=\"@(#) M_framework__approx almost(3f) function compares two real numbers up to specified number of digits by calling ACCDIG(3f)\" class ( * ), intent ( in ) :: x , y class ( * ), intent ( in ) :: digits logical , intent ( in ), optional :: verbose logical :: almost logical :: verbose_local real :: acurcy real :: digits_local integer :: ind if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif digits_local = anyscalar_to_realbig_ ( digits ) acurcy = 0.0 select type ( x ) type is ( real ) select type ( y ) type is ( real ) call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif class default call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select class default call accdig ( x , y , digits , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select if ( ind == 0 ) then almost = . true . else almost = . false . endif end function almost","tags":"","url":"proc/almost.html"},{"title":"in_margin – M_framework","text":"public impure elemental function in_margin(expected_value, measured_value, allowed_margin) NAME in_margin(3f) - [M_framework__approx] check if two reals are\n   approximately equal using a relative margin SYNOPSIS elemental pure function in_margin( expected_value, measured_value,\n allowed_margin )\n\n  real, intent(in)    :: expected_value\n  real, intent(in)    :: measured_value\n  real, intent(in)    :: allowed_margin\n  class(*),intent(in) :: invalue DESCRIPTION Compare two values to see if they are relatively equal using the\n   specified allowed margin. That is, see if VALUE_MEASURED is in\n   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error\n   varies with the magnitude of the values, such that the allowed error\n   is margin * average magnitude of measured and expected). So the allowed error is smaller when the magnitudes are smaller. OPTIONS expected_value   First value\n   measured_value   Second value\n   allowed_margin   Allowed relative margin EXAMPLES Sample program: program demo_in_margin use :: M_framework__approx , only : in_margin implicit none write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 000000001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 00000001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 0000001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 000001 ) write ( * , * ) in_margin ( [ 4 . 0 , 40 . 0 , 400 . 0 , 4000 . 0 , 40000 . 0 ], & & [ 3 . 9 , 39 . 9 , 399 . 9 , 3999 . 9 , 39999 . 9 ] , 0 . 000001 ) write ( * , * ) in_margin ( [ 4 . 0 , 40 . 0 , 400 . 0 , 4000 . 0 , 40000 . 0 ], & & [ 3 . 9 , 39 . 9 , 399 . 9 , 3999 . 9 , 39999 . 9 ] , 0 . 00001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 00001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 0001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 001 ) write ( * , * ) in_margin ( 4 . 00000 , 3 . 99999 , 0 . 01 ) end program demo_in_margin Results: > F\n    > F\n    > F\n    > F\n    > F F F F F\n    > F F F F T\n    > T\n    > T\n    > T\n    > T Arguments Type Intent Optional Attributes Name class(*), intent(in) :: expected_value class(*), intent(in) :: measured_value class(*), intent(in) :: allowed_margin Return Value logical Source Code elemental impure function in_margin ( expected_value , measured_value , allowed_margin ) implicit none ! ident_4=\"@(#) M_framework__approx in_margin(3f) check if two reals are approximately equal using a relative margin\" class ( * ), intent ( in ) :: expected_value , measured_value , allowed_margin logical :: in_margin doubleprecision :: expected , measured , margin expected = anyscalar_to_double_ ( expected_value ) measured = anyscalar_to_double_ ( measured_value ) margin = anyscalar_to_double_ ( allowed_margin ) if ( abs ( expected - measured ) > 0.50d0 * margin * ( abs ( expected ) + abs ( measured )) ) then in_margin = . false . ! values not comparable else in_margin = . true . ! values comparable endif end function in_margin","tags":"","url":"proc/in_margin.html"},{"title":"round – M_framework","text":"public  function round(val, idigits0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val integer, intent(in) :: idigits0 Return Value real(kind=dp) Source Code function round ( val , idigits0 ) implicit none ! ident_6=\"@(#) M_framework__approx round(3f) round val to specified number of significant digits\" integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ), intent ( in ) :: val integer , intent ( in ) :: idigits0 integer :: idigits , ipow real ( kind = dp ) :: aval , rnormal real ( kind = dp ) :: round !  this does not work very well because of round-off errors. !  Make a better one, probably have to use machine-dependent bit shifting ! make sure a reasonable number of digits has been requested idigits = max ( 1 , idigits0 ) aval = abs ( val ) !  select a power that will normalize the number !  (put it in the range 1 > abs(val) <= 0) if ( aval >= 1 ) then ipow = int ( log10 ( aval ) + 1 ) else ipow = int ( log10 ( aval )) endif rnormal = val / ( 1 0.0d0 ** ipow ) if ( rnormal == 1 ) then ipow = ipow + 1 endif !normalize, multiply by 10*idigits to an integer, and so on round = real ( anint ( val * 1 0.d0 ** ( idigits - ipow ))) * 1 0.d0 ** ( ipow - idigits ) end function round","tags":"","url":"proc/round.html"},{"title":"round_to_power – M_framework","text":"public pure elemental function round_to_power(val, n) Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: n Return Value real Source Code pure elemental function round_to_power ( val , n ) ! ident_5=\"@(#) M_framework__approx round_to_power(3f) round val to specified given decimal (power) position\" real , intent ( in ) :: val integer , intent ( in ) :: n real :: round_to_power round_to_power = anint ( val * 1 0.0 ** n ) / 1 0.0 ** n end function round_to_power","tags":"","url":"proc/round_to_power.html"},{"title":"accdig – M_framework","text":"public impure elemental subroutine accdig(x, y, digi0, acurcy, ind) Uses M_framework__journal iso_fortran_env NAME accdig ( 3 f ) - [ M_framework__approx ] compare two numbers only up to a specified number of digits ( LICENSE : PD ) SYNOPSIS elemental impure subroutine accdig(x,y,digio,acurcy,ind)\n\n    class(*),intent(in)  :: X\n    class(*),intent(in)  :: Y\n    class(*),intent(in)  :: DIGI0\n    real,intent(out)     :: acurcy\n    integer,intent(out)  :: ind DESCRIPTION This procedure is used to check how closely two numbers agree . call accdig ( X , Y , DIGI0 , ACURCY , IND ) The values X and Y are the numbers to compare , and DIGI0 is the threshold number of digits to consider significant in returning IND . If X and Y are considered equal within DIGI0 relative tolerance , IND = 0 , if tolerance is satisfied . = 1 , if tolerance is not satisfied . The result ACURCY gives a measure of the number of leading digits in X which are the same as the number of leading digits in Y . ACURCY =- log10 (( X - Y ) / Y ) if X != Y and Y != 0 ACURCY =- log10 ( X - Y ) if X != Y and Y = 0 ACURCY = 8 if X = Y ACURCY is never less than - 8 or greater than 8 for 32 - bit REAL values TOLERANCE ... X and Y are considered equal within DIGI0 relative tolerance , if ACURCY is greater than DIGI0 . For example , Take some numbers and compare them to 1 . 2345678 ... > ================================================ > A number | ACURCY | ACURCY > | 1 . 2345678 = Y | 1 . 2345678 = X > ================================================ > 1 . 234680 | 3 . 7900571 | 3 . 7901275 > 1 . 2345378 | 4 . 6144510 | 4 . 6144404 > 2 . 2234568 | 0 . 096367393 | 0 . 35188114 > 1 . 2345678 | 8 . 0000000 | 8 . 0000000 > 1 . 2345679 | 7 . 0732967 | 7 . 0731968 > - 1 . 2345678 | - 0 . 30103000 | - 0 . 30103000 > 76 . 234567 | - 1 . 7835463 | 0 . 0070906729 > 2 . 4691356 | 0 . 0 | 0 . 3010300 > 0 . 0 | 0 . 0 | - 0 . 91514942 . Due to the typical limits of the log function , the number of significant digits in the result is best considered to be three . Notice that 1 . 2345678 = Y produces different values than 1 . 2345678 = X A negative result indicates the two values being compared either do not agree in the first digit or they differ with respect to sign . An example of two numbers which do not agree in their leading digit ( and actually differ in order of magnitude ) is given above by X = 76 . 234567 and Y = 1 . 2345678 ; the accuracy reported is -1.7835463. An example of two numbers which do not agree in sign in X =- 1 . 2345678 and Y = 1 . 2345678 ; here the accuracy reported is - 0 . 30103000 . EXAMPLES Example program: program demo_accdig ! fortran 90 example use M_framework__approx , only : accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1 . 234680 d0 , 1 . 2345378 d0 , 2 . 2234568 d0 , 1 . 2345678 d0 , & & 1 . 2345679 d0 , - 1 . 2345678 d0 , 76 . 234567 d0 , 2 . 4691356 d0 , & & 0 . 0 d0 / write ( * , * ) ' ========================= ' do i10 = 0 , 16 a = 1 . 0 d0 b = a + 1 . 0 d0 / ( 10 . 0 d0 ** i10 ) call accdig ( a , b , 8 . 0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' digi = 16 do i20 = 0 , digi a = 1 . 0 d0 b = a + 1 . 0 d0 / ( 10 . 0 d0 ** i20 ) call accdig ( a , b , dble ( digi ) , acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' do i30 = 1 , 9 call accdig ( 1 . 2345678 d0 , vals ( i30 ) , 8 . 0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ) , 1 . 2345678 d0 , 8 . 0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ) , acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig NOTES REFERENCES based on … NBS OMNITAB 1980 VERSION 6 . 01 1 / 1 / 81 . dp_accdig V 7 . 00 2 / 14 / 90 . ** David Hogben , Statistical Engineering Division , Center for Computing and Applied Mathematics , A337 Administration Building , National Institute of Standards and Technology , Gaithersburg , MD 20899 TELEPHONE 301 - 975 - 2845 ORIGINAL VERSION - October , 1969 . CURRENT VERSION - February , 1990 . JSU VERSION - February , 1991 . DEPENDENCIES o M_framework__journal(), log10(), abs(1) AUTHORS David Hogben, John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind Source Code elemental impure SUBROUTINE accdig ( x , y , digi0 , ACURCY , IND ) #ifdef FLOAT128 use , intrinsic :: iso_fortran_env , only : wp => real128 #else use , intrinsic :: iso_fortran_env , only : wp => real64 #endif use M_framework__journal , only : journal implicit none ! ident_3=\"@(#) M_framework__approx accdig(3f) compare two values only up to a specified number of digits\" !  INPUT ... class ( * ), intent ( in ) :: x ! FIRST  OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: y ! SECOND OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: digi0 ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE. real ( kind = wp ) :: x_local real ( kind = wp ) :: y_local !  OUTPUT ... real , intent ( out ) :: acurcy ! = -LOG10(ABS((x_local-y_local)/y_local))) integer , intent ( out ) :: ind ! = 0, IF TOLERANCE IS     SATISFIED. ! = 1, IF TOLERANCE IS NOT SATISFIED. real ( kind = wp ) :: diff real ( kind = wp ) :: digi ! Maximum number of significant digits in a number of biggest real kind. integer , parameter :: idble_significant_digits = int ( log10 ( 2.0_wp ** digits ( 0.0_wp ))) x_local = anyscalar_to_realbig_ ( x ) y_local = anyscalar_to_realbig_ ( y ) digi = anyscalar_to_realbig_ ( digi0 ) if ( digi <= 0 ) then call journal ( 'sc' , '*accdig* bad number of significant digits=' , real ( digi , kind = wp )) digi = idble_significant_digits elseif ( digi > idble_significant_digits ) then call journal ( 'sc' , '*accdig* significant digit request too high=' , real ( digi , kind = wp )) digi = min ( digi , real ( idble_significant_digits , kind = wp )) endif diff = x_local - y_local if ( diff == 0.0_wp ) then acurcy = idble_significant_digits elseif ( y_local == 0.0_wp ) then acurcy = - log10 ( abs ( x_local )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y_local )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif end subroutine accdig","tags":"","url":"proc/accdig.html"},{"title":"change_default_ulp – M_framework","text":"public  subroutine change_default_ulp(ulp) NAME compare_float ( 3 f ) - [ M_framework__approx ] compare floating point values with adjustable tolerance . ( LICENSE : PD ) SYNOPSIS result = compare_float ( x , y , ulp = SCALING_VALUE ) elemental function ( x , y , ulp ) real ( kind = KIND ) , intent ( in ) :: x , y real | integer , intent ( in ) , optional :: ulp Additional convenience operators : X . equalto . Y X . lessthan . Y X . greaterthan . Y Developer procedure ( Do not use in production ) : change_default_ulp ( ulp ) DESCRIPTION compare_float ( 3 f ) is a function for comparing floating point numbers within an automatically adjusted tolerance . The test performed is abs ( x - y ) < ( ulp * spacing ( max ( abs ( x ) , abs ( y )) ) ) where ULP is a user - selected scaling factor that defaults to 1 . The default is intentionally low so that default behavior is close to that of the default operators . Setting it to zero ( 0 . 0 ) essentially causes no values to compare equal . If the result is . TRUE ., the numbers are considered equal . Both single and double precision scalar and array values can be compared , as the function is elemental . By definition of an elemental function the returned data entity is the same shape as the input array size or scalar if all values are scalar . It can be useful to empirically test your code for numeric sensitivities by changing the value of the ULP scaling factor and noting any result changes . As a convenience relational operators . EqualTo ., . GreaterThan ., and . LessThan . are provided . Note the comparisons return . TRUE > if the difference between the two values is . lt ., . ge ., and . le . . The algorithm for each operator is shown in the following OPERATORS section . The default ULP value is 1 . 0 . A procedure is available to change the default but it should only be used for examining code behavior during development , as it changes the default for calls from all procedures ( even those in other modules or procedures ) . call default_ulp ( ulp = VALUE ) DETAILS It is generally acknowledged that real numbers should not be compared directly but within some tolerance . However , the magnitude of an appropriate tolerance value will vary depending on the magnitudes of the numbers being compared and the precision of the computing environment . The Fortran standard does not specify functions or operators specifically for comparing float values , but leaves some latitude in how the compilers address floating point comparisons . It does specify functions that return platform - specific values useful in applying different methods to the problem such as + epsilon ( 3 f ) - Epsilon function + nearest ( 3 f ) - Nearest representable number + spacing ( 3 f ) - Smallest distance between two numbers of a given type + rrspacing ( 3 f ) - Reciprocal of the relative spacing of a numeric type and in some cases + scale ( 3 f ) - Scale a real value by a whole power of the radix + digits ( 3 f ) - Significant digits in the numeric model + exponent ( 3 f ) - Exponent of floating - point number + fraction ( 3 f ) - Fractional part of the model representation + huge ( 3 f ) - Largest number of a type and kind + maxexponent ( 3 f ) - Maximum exponent of a real kind + minexponent ( 3 f ) - Minimum exponent of a real kind + precision ( 3 f ) - Decimal precision of a real kind + radix ( 3 f ) - Base of a numeric model + range ( 3 f ) - Decimal exponent range of a numeric kind + set_exponent ( 3 f ) - real value with specified exponent + tiny ( 3 f ) - Smallest positive number of a real kind Books have been written on the behavior of floating point math . As is used here , a commonly used simple floating point comparison algorithm is if ( abs ( x < y ) < ( ulp * spacing ( max ( abs ( x ), abs ( y ))))) then : endif where the intrinsic function SPACING ( 3 f ) determines the distance between the argument X and the nearest adjacent representable number of the same type and ULP is an optional user - supplied scaling factor . OPTIONS x , y Two congruent floating point values to compare . ulp The ULP ( \" unit in the last place \" ) scaling value allows for users to control the scaling of the value returned by SPACING ( 3 f ) in order to relax or tighten what is considered \" equal \" . That is , the ULP value can be used to scale the comparison based on knowledge of the \" numerical quality \" of the values being used in the comparison . The value should be positive . The absolute value of the value is taken if it is negative . The default ULP scaling value is 1 . 0 . The value may be of type integer or real . A 0 . 5 ULP maximum error is the best you could hope for , since this corresponds to always rounding to the nearest representable floating point number . RESULT The return value is a logical value indicating whether the inputs are equal to within the requested precision . OPERATORS Additional operators based on compare_float(3f) are included: X.equalto.Y  If the result is .TRUE., the numbers are considered equal.\n              The test performed is abs( x - y ) < spacing( max(abs(x),abs(y)) ) X.greaterthan.Y  If the result is .TRUE., x is considered greater than y.\n                  The result is a logical value indicating whether the\n                  operand x is greater than y by more than the spacing\n                  between representable floating point numbers. The test performed is\n\n               ( x - y ) >= SPACING( MAX(ABS(x),ABS(y)) ) X.lessthan.Y  Test if one operand is less than another.\n               The result is a logical value indicating whether\n               the operand x is less than y by more than the\n               spacing between representable floating point\n               numbers. The test performed is ( y - x ) >= SPACING ( MAX ( ABS ( x ) , ABS ( y )) ) If the result is . TRUE ., x is considered less than y . EXAMPLES Sample programs: program demo_compare_float use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use M_framework__approx , only : compare_float use M_framework__approx , only : & & operator (. equalto .), operator (. greaterthan .), operator (. lessthan .) implicit none integer , parameter :: wp = int32 integer :: i character ( len = 80 ), save :: line = '1 0 * 0.1 ' real ( kind = wp ) :: a ( 10 ), x , y , ulp write ( * , * )' is 10 * 0.1 == 1.0 ? ' ! sum up 0.1 ten times hopefully in a manner compiler does not ! optimize it and in the process make it equal a = 0.1 _wp read ( line , * ) a x = sum ( a ) y = 1.0 _wp write ( * , * ) merge (' EQUAL ',' NOT EQUAL ! ', x . eq . y ) write ( * ,'( * ( g0 , 1 x , z0 , 1 x ))') x , x , y , y ! show decimal and hexadecimal value write ( * , * )' regular ', x . eq . y , x . gt . y , x . lt . y ! standard operators ! For the default ULP = 1.0 , the relational operators can be used write ( * , * )' compare ', x . equalto . y , x . greaterthan . y , x . lessthan . y do i = 0 , 10 ulp = real ( i , kind = wp ) / 2.0 write ( * , * ) i , compare_float ( x , y , ulp = ulp ) ,' ULP = ', ulp enddo end program demo_compare_float Results: > is 10 * 0.1 == 1.0 ? > NOT EQUAL ! > 1.00000012 3F 800001 1.00000000 3F 800000 > regular F T F > compare F T F > 0 F ULP = 0.00000000 > 1 F ULP = 0.500000000 > 2 F ULP = 1.00000000 > 3 T ULP = 1.50000000 > 4 T ULP = 2.00000000 > 5 T ULP = 2.50000000 > 6 T ULP = 3.00000000 > 7 T ULP = 3.50000000 > 8 T ULP = 4.00000000 > 9 T ULP = 4.50000000 > 10 T ULP = 5.00000000 Arguments Type Intent Optional Attributes Name class(*), intent(in) :: ulp Source Code subroutine change_default_ulp ( ulp ) ! developer routine for changing default ulp class ( * ), intent ( in ) :: ulp default_ulp = abs ( anyscalar_to_double_ ( ulp )) end subroutine change_default_ulp","tags":"","url":"proc/change_default_ulp.html"},{"title":"sp_accdig – M_framework","text":"public  subroutine sp_accdig(x, y, digi0, acurcy, ind) Uses M_framework__journal NAME sp_accdig ( 3 f ) - [ M_framework__approx ] compare two real numbers of default kind only up to a specified number of digits ( LICENSE : PD ) SYNOPSIS subroutine sp_accdig(x,y,digio,acurcy,ind)\n\n    real,intent(in)     :: X\n    real,intent(in)     :: Y\n    real,intent(in)     :: DIGI0\n    real,intent(out)    :: acurcy\n    integer,intent(out) :: ind DESCRIPTION This procedure is used to check how closely two numbers agree . call sp_accdig ( X , Y , DIGI0 , ACURCY , IND ) The values X and Y are the numbers to compare , and DIGI0 is the threshold number of digits to consider significant in returning IND . If X and Y are considered equal within DIGI0 relative tolerance , IND = 0 , if tolerance is satisfied . = 1 , if tolerance is not satisfied . The result ACURCY gives a measure of the number of leading digits in X which are the same as the number of leading digits in Y . ACURCY =- log10 (( X - Y ) / Y ) if X != Y and Y != 0 ACURCY =- log10 ( X - Y ) if X != Y and Y = 0 ACURCY = 8 if X = Y ACURCY is never less than - 8 or greater than 8 TOLERANCE ... X and Y are considered equal within DIGI0 relative tolerance , if ACURCY is greater than DIGI0 . For example , Take some numbers and compare them to 1 . 2345678 ... > ================================================ > A number | ACURCY | ACURCY > | 1 . 2345678 = Y | 1 . 2345678 = X > ================================================ > 1 . 234680 | 3 . 7900571 | 3 . 7901275 > 1 . 2345378 | 4 . 6144510 | 4 . 6144404 > 2 . 2234568 | 0 . 096367393 | 0 . 35188114 > 1 . 2345678 | 8 . 0000000 | 8 . 0000000 > 1 . 2345679 | 7 . 0732967 | 7 . 0731968 > - 1 . 2345678 | - 0 . 30103000 | - 0 . 30103000 > 76 . 234567 | - 1 . 7835463 | 0 . 0070906729 > 2 . 4691356 | 0 . 0 | 0 . 3010300 > 0 . 0 | 0 . 0 | - 0 . 91514942 . Due to the typical limits of the log function , the number of significant digits in the result is best considered to be three . Notice that 1 . 2345678 = Y produces different values than 1 . 2345678 = X A negative result indicates the two values being compared either do not agree in the first digit or they differ with respect to sign . An example of two numbers which do not agree in their leading digit ( and actually differ in order of magnitude ) is given above by X = 76 . 234567 and Y = 1 . 2345678 ; the accuracy reported is -1.7835463. An example of two numbers which do not agree in sign in X =- 1 . 2345678 and Y = 1 . 2345678 ; here the accuracy reported is - 0 . 30103000 . EXAMPLES Example program: program demo_sp_accdig ! fortran 90 example use M_framework__approx , only : sp_accdig implicit none integer :: digi integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 real :: a , b real :: vals ( 9 ) data vals / & & 1 . 234680 , 1 . 2345378 , 2 . 2234568 , 1 . 2345678 , & & 1 . 2345679 , - 1 . 2345678 , 76 . 234567 , 2 . 4691356 , & & 0 . 0 / write ( * , * ) ' ========================= ' do i10 = 0 , 16 a = 1 . 0 b = a + 1 . 0 / ( 10 . 0 ** i10 ) call sp_accdig ( a , b , 8 . 0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' digi = 16 do i20 = 0 , digi a = 1 . 0 b = a + 1 . 0 / ( 10 . 0 ** i20 ) call sp_accdig ( a , b , real ( digi ) , acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' do i30 = 1 , 9 call sp_accdig ( 1 . 2345678 , vals ( i30 ) , 8 . 0 , acurcy1 , ind1 ) call sp_accdig ( vals ( i30 ) , 1 . 2345678 , 8 . 0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ) , acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_sp_accdig REFERENCES based on … NBS OMNITAB 1980 VERSION 6 . 01 1 / 1 / 81 . accdig V 7 . 00 2 / 14 / 90 . ** David Hogben , Statistical Engineering Division , Center for Computing and Applied Mathematics , A337 Administration Building , National Institute of Standards and Technology , Gaithersburg , MD 20899 TELEPHONE 301 - 975 - 2845 ORIGINAL VERSION - October , 1969 . CURRENT VERSION - February , 1990 . JSU VERSION - February , 1991 . DEPENDENCIES o M_framework__journal(),log10(), abs(1) AUTHOR David Hogben, John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind Source Code SUBROUTINE sp_accdig ( X , Y , digi0 , ACURCY , IND ) use M_framework__journal , only : journal implicit none ! ident_2=\"@(#) M_framework__approx sp_accdig(3f) compare two real numbers only up to a specified number of digits\" !     INPUT ... real , intent ( in ) :: x ! First  of two real numbers to be compared. real , intent ( in ) :: y ! Second of two real numbers to be compared. real , intent ( in ) :: digi0 ! Number of digits to be satisfied in relative tolerance. !     OUTPUT ... real , intent ( out ) :: acurcy ! = -LOG10(ABS((X-Y)/Y))) integer , intent ( out ) :: ind ! = 0, If tolerance is     satisfied. ! = 1, If tolerance is not satisfied. real :: diff real :: digi integer , parameter :: ireal_significant_digits = int ( log10 ( 2. ** digits ( 0.0 ))) ! maximum number of significant digits in a real number. digi = digi0 if ( digi <= 0 ) then call journal ( 'sc' , '*sp_accdig* bad number of significant digits=' , digi ) digi = ireal_significant_digits elseif ( digi > ireal_significant_digits ) then call journal ( 'sc' , '*sp_accdig* significant digit request too high=' , digi ) digi = min ( digi , real ( ireal_significant_digits )) endif diff = x - y if ( diff == 0.0 ) then acurcy = ireal_significant_digits elseif ( y == 0.0 ) then acurcy = - log10 ( abs ( x )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif END SUBROUTINE sp_accdig","tags":"","url":"proc/sp_accdig.html"},{"title":"compare_float – M_framework","text":"public interface compare_float Module Procedures private elemental function compare_float_real32(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical private elemental function compare_float_real64(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical private elemental function compare_float_real128(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical","tags":"","url":"interface/compare_float.html"},{"title":"dp_accdig – M_framework","text":"public interface dp_accdig Module Procedures public impure elemental subroutine accdig (x, y, digi0, acurcy, ind) Example program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind","tags":"","url":"interface/dp_accdig.html"},{"title":"operator (.equalto.) – M_framework","text":"public interface operator (.equalto.) Module Procedures private elemental function is_equal_to_real32(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_equal_to_real64(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_equal_to_real128(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical","tags":"","url":"interface/operator (.equalto.).html"},{"title":"operator (.greaterthan.) – M_framework","text":"public interface operator (.greaterthan.) Module Procedures private elemental function is_greater_than_real32(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_greater_than_real64(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_greater_than_real128(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical","tags":"","url":"interface/operator (.greaterthan.).html"},{"title":"operator (.lessthan.) – M_framework","text":"public interface operator (.lessthan.) Module Procedures private elemental function is_less_than_real32(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_less_than_real64(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_less_than_real128(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical","tags":"","url":"interface/operator (.lessthan.).html"},{"title":"significant – M_framework","text":"public interface significant Module Procedures private pure elemental function significant_real32(val, digits, round) result(significant) NAME significant(3f) - [M_framework__approx] round val to specified number\n   of significant digits SYNOPSIS pure elemental function significant(val,digits,round)\n\n  real,intent(in)                      :: val\n  integer,intent(in)                   :: digits\n  character(len=*),intent(in),optional :: round\n  real                                 :: significant DESCRIPTION Round real value to specified number of significant digits OPTIONS val     value to round\n digits  number of significant digits to produce\n round   Use the round edit descriptor RU UP : the value resulting from conversion shall be the smallest representable value that is greater than or equal to the original value RD DOWN : the value resulting from conversion shall be the largest representable value that is less than or equal to the original value RZ ZERO : the value resulting from conversion shall be the value closest to the original value and no greater in magnitude than the original value . RN NEAREST : modeis NEAREST , thevalueresulting from conversion shall be the closer of the two nearest representable values if one is closer than the other . If the two nearest representable values are equidistant from the original value , it is processor dependent which one of them is chosen . RC COMPATIBLE : the value resulting from conversion shall be the closer of the two nearest representable values or the value away from zero if halfway between them . RP PROCESSOR_DEFINED : rounding during conversion shall be a processor - dependent default mode , which may correspond to one of the other modes . EXAMPLES Sample program program demo_significant use M_framework__approx , only : significant implicit none character ( len =* ) , parameter :: g = ' (*(g0.7,1x)) ' write ( * , g ) significant ( [ 8765 . 43210 , 0 . 1234567890 ], 5 ) write ( * , * ) ' default: ' , 1 . 23456789012345 write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RU ' ) , ' RU ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RD ' ) , ' RD ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RZ ' ) , ' RZ ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RN ' ) , ' RN ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RC ' ) , ' RC ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RP ' ) , ' RP ' end program demo_significant Results: > 8765.400 .1234600\n   >  default:   1.234568\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568\n   > 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RU\n   > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...\n   > 1.234567 1.234568 1.234568 RD\n   > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...\n   > 1.234567 1.234568 1.234568 RZ\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RN\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RC\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RP Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real(kind=wp) private pure elemental function significant_real64(val, digits, round) result(significant) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real(kind=wp)","tags":"","url":"interface/significant.html"},{"title":"journal – M_framework","text":"public interface journal Module Procedures private  subroutine flush_trail() Arguments None private  subroutine write_message_only(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message private  subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep) NAME where_write_message_all ( 3 f ) - [ M_framework__journal ] converts any standard scalar type to a string and calls journal ( 3 f ) ( LICENSE : PD ) SYNOPSIS subroutine where_write_message_all(where,g0,g1,g2,..,gj,sep) character(len=*),intent(in)   :: where\n class(*),intent(in)           :: g0\n class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9\n class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj\n character,intent(in),optional :: sep DESCRIPTION where_write_message_all(3f) builds and writes a space-separated string\nfrom up to twenty scalar values. OPTIONS where       string designating where to write message, as with journal(3f)\ng0          value to print. May\n            be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,\n            or CHARACTER.\ng[1-9a-j]   optional additional values to print the value of after g0.\nsep         separator to add between values. Default is a space. Should\n            always be called with a keyword, as in \"sep=VALUE\". RETURNS where_write_message_all  description to print EXAMPLES Sample program: program demo_wm_all use M_framework__journal , only : where_write_message_all implicit none end program program demo_wm_all AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: where class(*), intent(in) :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj character(len=1), intent(in), optional :: sep private  subroutine set_stdout_lun(iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit","tags":"","url":"interface/journal.html"},{"title":"get_stack – M_framework","text":"function get_stack() result(args) Arguments None Return Value character(len=:), allocatable, (:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iargs integer, public :: ilength integer, public :: ilongest integer, public :: istatus Source Code function get_stack () result ( args ) character ( len = :), allocatable :: args (:) integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_ARGS end if end do GET_ARGS end function get_stack","tags":"","url":"proc/get_stack.html"},{"title":"get_stack – M_framework","text":"function get_stack() result(args) Arguments None Return Value character(len=:), allocatable, (:) Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg = '' integer, public :: i integer, public :: iargs integer, public :: ilength integer, public :: ilongest integer, public :: istatus Source Code function get_stack () result ( args ) character ( len = :), allocatable :: args (:) character ( len = 256 ) :: errmsg = '' integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) !,errmsg=errmsg)    ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining length for argument ' , i , trim ( errmsg ) exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) !,errmsg=errmsg)  ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i , trim ( errmsg ) exit GET_ARGS end if end do GET_ARGS end function get_stack","tags":"","url":"proc/get_stack~2.html"},{"title":"test_framework – M_framework","text":"subroutine test_framework() Arguments None Source Code subroutine test_framework () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_framework","tags":"","url":"proc/test_framework.html"},{"title":"printstuff – M_framework","text":"subroutine printstuff(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: array (:) Source Code subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","url":"proc/printstuff.html"},{"title":"run – M_framework","text":"subroutine run(command) Arguments Type Intent Optional Attributes Name character(len=*) :: command Variables Type Visibility Attributes Name Initial character(len=256), public :: cmdmsg integer, public :: cmdstat integer, public :: exitstat logical, public, parameter :: wait = .true. Source Code subroutine run ( command ) ! convenience routine so command does not cause program to stop character ( len =* ) :: command logical , parameter :: wait = . true . integer :: exitstat integer :: cmdstat character ( len = 256 ) :: cmdmsg call wrt ([ error_unit ], \"+ \" , command ) cmdmsg = ' ' call execute_command_line ( command , wait , exitstat , cmdstat , cmdmsg ) if ( cmdstat /= 0 ) then call wrt ([ error_unit ], \"cmdstat: \" , cmdmsg , 'for command :' , command ) elseif ( cmdmsg /= '' ) then call wrt ([ error_unit ], \"exitstat: \" , cmdmsg , 'for command :' , command ) endif end subroutine run","tags":"","url":"proc/run~2.html"},{"title":"test_accdig – M_framework","text":"subroutine test_accdig() Arguments None Variables Type Visibility Attributes Name Initial doubleprecision, public :: a doubleprecision, public :: aarr (sz) real, public :: acurcy real, public :: acurcyarr (sz) doubleprecision, public :: b doubleprecision, public :: barr (sz) integer, public :: i integer, public :: ind integer, public :: indarr (sz) integer, public, parameter :: sz = 16 Source Code subroutine test_accdig () integer , parameter :: sz = 16 doubleprecision :: a , b , aarr ( sz ), barr ( sz ) integer :: i , ind , indarr ( sz ) real :: acurcy , acurcyarr ( sz ) call unit_test_start ( 'accdig' , msg = '' ) do i = 1 , sz a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i ) call accdig ( a , b , 8.0 , acurcy , ind ) if ( unit_test_level > 0 ) write ( * , g ) i , a , b , acurcy , ind aarr ( i ) = a barr ( i ) = b enddo call accdig ( aarr , barr , 8.0 , acurcyarr , indarr ) if ( unit_test_level > 0 ) write ( * , g )( aarr ( i ), barr ( i ), acurcyarr ( i ), indarr ( i ), new_line ( 'a' ), i = 1 , sz ) call unit_test ( 'accdig' , all ( indarr . eq .[ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'expected 7 bad, got ' , count ( indarr . eq . 1 ) + 0 ) call unit_test_end ( 'accdig' , msg = '' ) end subroutine test_accdig","tags":"","url":"proc/test_accdig.html"},{"title":"test_almost – M_framework","text":"subroutine test_almost() Arguments None Variables Type Visibility Attributes Name Initial logical, public, parameter :: expected (*) = [.true., .true., .false., .false., .false., .false., .false., .false.] integer, public :: i real, public :: r real, public :: x real, public :: y Source Code subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_test_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_test ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i ), 'for' , x , y , r , 'expected' , expected ( i )) enddo call unit_test_end ( 'almost' , msg = '' ) end subroutine test_almost","tags":"","url":"proc/test_almost.html"},{"title":"test_in_margin – M_framework","text":"subroutine test_in_margin() call unit_test(‘in_margin’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_in_margin () call unit_test_start ( 'in_margin' , msg = '' ) !!call unit_test('in_margin', 0.eq.0, 'checking', 100) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_test ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_test ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_test_end ( 'in_margin' , msg = '' ) end subroutine test_in_margin","tags":"","url":"proc/test_in_margin.html"},{"title":"test_round – M_framework","text":"subroutine test_round() call unit_test(‘round’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_round () call unit_test_start ( 'round' , msg = '' ) !!call unit_test('round', 0.eq.0, 'checking', 100) call unit_test_end ( 'round' , msg = '' ) end subroutine test_round","tags":"","url":"proc/test_round.html"},{"title":"test_significant – M_framework","text":"subroutine test_significant() Arguments None Variables Type Visibility Attributes Name Initial doubleprecision, public, allocatable :: answers (:) doubleprecision, public, allocatable :: expected (:) Source Code subroutine test_significant () doubleprecision , allocatable :: answers (:) doubleprecision , allocatable :: expected (:) call unit_test_start ( 'significant' , msg = '' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ) expected = [ 2.0d0 , 1.3d0 , 1.24d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.2345679d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RU, round up' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RD, round down ' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RZ, round towards zero' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RN, round towards nearest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RC, compatible rounding rounds to closest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RP, processor-dependent rounding ' ) call unit_test_end ( 'significant' , msg = '' ) end subroutine test_significant","tags":"","url":"proc/test_significant.html"},{"title":"fmt – M_framework","text":"public recursive function fmt(generic, format) result(line) Uses iso_fortran_env NAME fmt ( 3 f ) - [ M_framework__msg ] convert any intrinsic to a string using specified format ( LICENSE : PD ) SYNOPSIS function fmt(value,format) result ( string ) class ( * ), intent ( in ), optional :: value character ( len = * ), intent ( in ), optional :: format character ( len =:), allocatable :: string DESCRIPTION FMT(3f) converts any standard intrinsic value to a string using the specified\nformat. OPTIONS value value to print the value of . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . format format to use to print value . It is up to the user to use an appropriate format . The format does not require being surrounded by parenthesis . If not present a default is selected similar to what would be produced with free format , with trailing zeros removed . RETURNS string   A string value EXAMPLES Sample program: program demo_fmt use :: M_framework__msg , only : fmt implicit none character ( len = : ) , allocatable :: output output = fmt ( 10 , \" '[',i0,']' \" ) write ( * , * ) ' result is ' , output output = fmt ( 10 . 0 / 3 . 0 , \" '[',g0.5,']' \" ) write ( * , * ) ' result is ' , output output = fmt ( . true ., \" 'The final answer is [',g0,']' \" ) write ( * , * ) ' result is ' , output end program demo_fmt Results: result is [ 10 ] result is [ 3.3333 ] result is The final answer is [ T ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Source Code recursive function fmt ( generic , format ) result ( line ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 ! ident_4=\"@(#) M_framework__msg fmt(3f) convert any intrinsic to a string using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local character ( len = :), allocatable :: str_re , str_im integer :: iostat character ( len = 255 ) :: iomsg character ( len = 1 ), parameter :: nil = char ( 0 ) integer :: iilen logical :: trimit if ( present ( format )) then fmt_local = format trimit = . false . else fmt_local = '' trimit = . true . endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef FLOAT128 type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable iostat = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil #endif type is ( logical ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( character ( len =* )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( complex ); if ( trimit ) then str_re = fmt ( real ( generic )) ! nvfortran cannot yet do fmt(generic%re) str_im = fmt ( aimag ( generic )) ! nvfortran cannot yet do fmt(generic%im) call trimzeros_ ( str_re ) call trimzeros_ ( str_im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( str_re ), trim ( str_im ), nil trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil endif end select if ( iostat /= 0 ) then line = '<ERROR>' // trim ( iomsg ) else iilen = index ( line , nil , back = . true .) if ( iilen == 0 ) iilen = len ( line ) line = line (: iilen - 1 ) endif if ( index ( line , '.' ) /= 0 . and . trimit ) call trimzeros_ ( line ) end function fmt","tags":"","url":"proc/fmt.html"},{"title":"assert – M_framework","text":"public  subroutine assert(filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) NAME assert ( 3 f ) - [ M_framework__msg ] print filename , linenumber , and message to stderr and stop program ( LICENSE : PD ) SYNOPSIS function assert ( file , linenum , expr , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , & & ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) character ( len = * ), intent ( in ) :: file character ( len = * ), intent ( in ) :: linenum logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj DESCRIPTION assert ( 3 f ) prints strings to stderr and then stops program with exit code 1 It labels the first string as the filename , the next integer parameter as the linenumber , and then up to twenty scalar values . It is primarily intended for use by the prep ( 1 ) preprocessor $ ASSERT directive OPTIONS filename a string assumed to be the current filename when compiling linenum assumed to be the line number of the source code the ASSERT ( 3 f ) procedure was called at . expr logical value g [ 1 - 9 a - j ] optional value ( s ) to print as a message before stopping . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . EXAMPLES Sample program: program demo_assert use M_framework__msg , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( ' myroutine ' , 101 , a > toobig , & & ' The value is too large ' , a , ' > ' , toobig ) end program demo_assert AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: linen logical, intent(in) :: expr class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj Source Code subroutine assert ( filename , linen , expr , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_9=\"@(#) M_framework__msg assert(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: linen logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ! write message to standard error if (. not . expr ) then call stderr ( 'ERROR:filename:' , filename , ':line number:' , linen , ':' , & & str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) ) stop 1 endif end subroutine assert","tags":"","url":"proc/assert.html"},{"title":"pdec – M_framework","text":"public  subroutine pdec(string) NAME pdec ( 3 f ) - [ M_framework__msg ] write out string with ASCII decimal equivalent vertically under it ( LICENSE : PD ) SYNOPSIS Usage : subroutine pdec ( string ) character ( len =*), intent ( in ) :: string DESCRIPTION Given a string to print , PDEC () writes out the ASCII Decimal equivalent of the string directly underneath it . This can help you to locate unprintable characters or non - standard white - space such as a backspace character or tab character in input strings that your program could not interpret . On output , non - printable characters are replaced with a space , and trailing spaces are ignored . You read the numbers vertically . 1 . ignore trailing spaces 2 . print the character if it has an ADE of 32 on up 3 . print a space if it has an ADE of less than 32 4 . underneath each character print the ADE value vertically EXAMPLES Sample program : program demo_pdec use M_framework__msg , only : pdec call pdec ( ' ABCDEFG abcdefg ' ) end program demo_pdec would produce ( notice trailing space is trimmed ) : > ABCDEFG abcdefg > 0000000000001111 > 3666667739990000 > 2567890127890123 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Source Code subroutine pdec ( string ) ! ident_8=\"@(#) M_framework__msg pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string\" character ( len =* ), intent ( in ) :: string ! the string to print integer :: iilen ! number of characters in string to print integer :: i ! counter used to step thru string iilen = len_trim ( string (: len ( string ))) ! get trimmed length of input string write ( * , 101 )( char ( max ( 32 , ichar ( string ( i : i )))), i = 1 , iilen ) ! replace lower unprintable characters with spaces ! print ADE value of character underneath it write ( * , 202 ) ( ichar ( string ( i : i )) / 100 , i = 1 , iilen ) write ( * , 202 )( mod ( ichar ( string ( i : i )), 100 ) / 10 , i = 1 , iilen ) write ( * , 202 )( mod (( ichar ( string ( i : i ))), 10 ), i = 1 , iilen ) ! strings are assumed under 32767+1 characters in length because format integer constants > 32767+1 are not supported on HP-UX ! when newer compilers are available use unlimited !101   format(32767a1:)  ! format for printing string characters !202   format(32767i1:)  ! format for printing ADE values 101 format ( * ( a1 :)) ! format for printing string characters 202 format ( * ( i1 :)) ! format for printing ADE values end subroutine pdec","tags":"","url":"proc/pdec.html"},{"title":"stderr – M_framework","text":"public  subroutine stderr(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) NAME stderr ( 3 f ) - [ M_framework__msg ] write message to stderr ( LICENSE : PD ) SYNOPSIS subroutine stderr(msg,[generic(s)])\n\n class(*),intent(in),optional :: msg\n class(*),intent(in),optional :: &\n                 & generic0,generic1,generic2,generic3,generic4\n class(*),intent(in),optional :: &\n                 & generic5,generic6,generic7,generic8,generic9\n class(*),intent(in),optional :: &\n                 & generica,genericb,genericc,genericd,generice\n class(*),intent(in),optional :: &\n                 & genericf,genericg,generich,generici,genericj DESCRIPTION STDERR(3f) writes a message to standard error using a standard\nf2003 method. Up to twenty generic options are available. OPTIONS msg           - description to print\ngeneric[0-j]  - optional value to print the value of after the\n                message. May be of type INTEGER, LOGICAL, REAL,\n                DOUBLEPRECISION, COMPLEX, or CHARACTER. EXAMPLES Sample program: program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_framework__msg , only : stderr implicit none call stderr ( ' A simple message ' ) call stderr ( ' error: RVALUE= ' , 3 . 0 / 4 . 0 ) call stderr ( ' error: IVALUE= ' , 123456789 ) call stderr ( ' error: LVALUE= ' ,. true . ) SEVERAL : block integer :: least = 10 , most = 999 , ival =- 10 call stderr ( ' error: value ' , ival , & & ' should be between ' , least , ' and ' , most ) endblock SEVERAL call stderr ( ' real32  : ' , huge ( 0 . 0 _real32 ) , 0 . 0 _real32 , & & 12345 . 6789 _real32 , tiny ( 0 . 0 _real32 )) call stderr ( ' real64  : ' , huge ( 0 . 0 _real64 ) , 0 . 0 _real64 , & & 12345 . 6789 _real64 , tiny ( 0 . 0 _real64 )) ! # ifdef __NVCOMPILER ! # else call stderr ( ' real128 : ' , huge ( 0 . 0 _real128 ) , 0 . 0 _real128 , & & 12345 . 6789 _real128 , tiny ( 0 . 0 _real128 )) ! # endif call stderr ( ' complex : ' , cmplx ( huge ( 0 . 0 _real ) , tiny ( 0 . 0 _real ))) call stderr ( ' error: program will now stop ' ) stop 1 end program demo_stderr Results:\n     A simple message\n     error: RVALUE= 0.750000000\n     error: IVALUE= 123456789\n     error: LVALUE= T\n     error: value -10 should be between 10 and 999\n     real32  : 3.40282347E+38 …\n               0.00000000 …\n               12345.6787 …\n               1.17549435E-38\n     real64  : 1.7976931348623157E+308 …\n               0.0000000000000000 …\n               12345.678900000001 …\n               2.2250738585072014E-308\n     real128 : 1.18973149535723176508575932662800702E+4932 …\n               0.00000000000000000000000000000000000  …\n               12345.6789000000000000000000000000002 …\n               3.36210314311209350626267781732175260E-4932\n     complex : (3.40282347E+38,1.17549435E-38)\n     error: program will now stop\n     STOP 1 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj Source Code subroutine stderr ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_6=\"@(#) M_framework__msg stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr","tags":"","url":"proc/stderr.html"},{"title":"wrt – M_framework","text":"public  subroutine wrt(luns, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat) NAME wrt ( 3 f ) - [ M_framework__msg ] write multiple scalar values to any number of files ( LICENSE : PD ) SYNOPSIS subroutine wrt(luns,generic(s),iostat)\n\n integer,intent(in)           :: luns(:)\n class(*),intent(in),optional :: &\n                 & generic0,generic1,generic2,generic3,generic4\n class(*),intent(in),optional :: &\n                 & generic5,generic6,generic7,generic8,generic9\n class(*),intent(in),optional :: &\n                 & generica,genericb,genericc,genericd,generice\n class(*),intent(in),optional :: &\n                 & genericf,genericg,generich,generici,genericj\n integer,intent(out),optional :: iostat\n character(len=*),intent(in)  :: types(*) DESCRIPTION WRT(3f) writes a list of scalar values  to the list of unit numbers\nin LUNS(:). OPTIONS LUNS Unit numbers to write to . If of size zero no output is generated generic [ 1 - 20 ] optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . TYPES one for each lun . '' for ASCII , ' CSV ' for comma - separated . RETURNS IOSTAT The value of the last non - zero IOSTAT value . Returns zero if no errors occurred . EXAMPLES Sample program: program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_framework__msg , only : wrt , fmt implicit none integer , allocatable :: luns ( : ) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , ' NULL LIST : ' , huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , iostat = iostat ) write ( * , * ) ' IOSTAT = ' , iostat ! multiple files can be used to create a log file , for example luns = [ stderr , stdout ] call wrt ( luns , ' TWO FILES : ' , huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , iostat = iostat ) write ( * , * ) ' IOSTAT = ' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], ' USING FMT : ' , & & huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , fmt ( ints ( 2 ), ' i0 .4 ' ), iostat = iostat ) end program demo_wrt TWO FILES: 2147483647 PI= 3.1415926535897931 TWO FILES: 2147483647 PI= 3.1415926535897931 IOSTAT=           0 USING FMT : 2147483647 PI= 3.1415926535897931 0002 USING FMT : 2147483647 PI= 3.1415926535897931 0002 USING FMT : 2147483647 PI= 3.1415926535897931 0002 IOSTAT=           0 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: luns (:) class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj integer, intent(out), optional :: iostat Source Code subroutine wrt ( luns , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , iostat ) implicit none ! ident_7=\"@(#) M_framework__msg write(3f) writes a message to any number of open files with any scalar values\" integer , intent ( in ) :: luns (:) class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer , intent ( out ), optional :: iostat integer :: i integer :: ios , ios2 character ( len = 256 ) :: msg ios2 = 0 do i = 1 , size ( luns ) write ( luns ( i ), '(a)' , iostat = ios , iomsg = msg ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if ( ios /= 0 ) then ios2 = ios call stderr ( '<ERROR>*write*:' , msg ) if (. not . present ( iostat )) stop 1 endif enddo if ( present ( iostat )) iostat = ios2 end subroutine wrt","tags":"","url":"proc/wrt.html"},{"title":"set – M_framework","text":"public interface set Module Procedures private  subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(out), optional :: generic1 class(*), intent(out), optional :: generic2 class(*), intent(out), optional :: generic3 class(*), intent(out), optional :: generic4 class(*), intent(out), optional :: generic5 class(*), intent(out), optional :: generic6 class(*), intent(out), optional :: generic7 class(*), intent(out), optional :: generic8 class(*), intent(out), optional :: generic9 class(*), intent(out), optional :: generica class(*), intent(out), optional :: genericb class(*), intent(out), optional :: genericc class(*), intent(out), optional :: genericd class(*), intent(out), optional :: generice class(*), intent(out), optional :: genericf class(*), intent(out), optional :: genericg class(*), intent(out), optional :: generich class(*), intent(out), optional :: generici class(*), intent(out), optional :: genericj class(*), intent(out), optional :: generick private  subroutine set_single(generic0, generic1) NAME set ( 3 f ) - [ M_msg ] set scalars from an array ( LICENSE : PD ) SYNOPSIS Syntax : function set ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, & & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk ) class (*), intent ( in ) :: g0 class (*), intent ( out ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga class (*), intent ( out ), optional :: gb , gc , gd , ge , gf , gg , gh , gi , gj , gk DESCRIPTION set(3f) sets up to twenty scalars to elements from an array. OPTIONS g0(:)       array to read values from. Can be of type INTEGER or REAL\ng[1-9a-k]   optional values to set to an array element. Can\n            be of type INTEGER or REAL EXAMPLES Sample program: program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_framework__msg , only : set implicit none real ( kind = real32 ) :: a ; namelist /all/a real ( kind = real64 ) :: b ; namelist /all/b real ( kind = real128 ) :: c ; namelist /all/c integer ( kind = int8 ) :: i ; namelist /all/i integer ( kind = int16 ) :: j ; namelist /all/j integer ( kind = int32 ) :: k ; namelist /all/k integer ( kind = int64 ) :: l ; namelist /all/l call set ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set Results: &ALL\n A       =   1.000000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                     7\n /\n &ALL\n A       =   10.00000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                   100\n / AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 class(*), intent(out) :: generic1","tags":"","url":"interface/set.html"},{"title":"str – M_framework","text":"public interface str Module Procedures private pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, force_kwargs, sep, if) NAME str ( 3 f ) - [ M_framework__msg ] converts up to twenty standard scalar type values to a string ( LICENSE : PD ) SYNOPSIS Syntax : pure function str ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if ) class (*), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class (*), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj logical , intent ( in ), optional :: if character ( len =*), intent ( in ), optional :: sep character , len =(:), allocatable :: str DESCRIPTION str(3f) builds a space-separated string from up to twenty scalar values. OPTIONS g [ 0 - 9 a - j ] Optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . Optionally , all the generic values can be single - dimensioned arrays . Currently , mixing scalar arguments and array arguments is not supported . sep separator string used between values . Defaults to a space . Must be specified with a keyword . if If false return a null string . Must be specified with a keyword . RETURNS str     description to print EXAMPLES Sample program: program demo_str use M_framework__msg , only : str implicit none character ( len = : ) , allocatable :: pr character ( len = : ) , allocatable :: frmt integer :: biggest pr = str ( ' HUGE(3f) integers ' , huge ( 0 ) , & & ' and real ' , huge ( 0 . 0 ) , ' and double ' , huge ( 0 . 0 d0 )) write ( * , ' (a) ' ) pr pr = str ( ' real            : ' , huge ( 0 . 0 ) , 0 . 0 , 12345 . 6789 , tiny ( 0 . 0 ) ) write ( * , ' (a) ' ) pr pr = str ( ' doubleprecision : ' , huge ( 0 . 0 d0 ) , 0 . 0 d0 , 12345 . 6789 d0 , tiny ( 0 . 0 d0 ) ) write ( * , ' (a) ' ) pr pr = str ( ' complex         : ' , cmplx ( huge ( 0 . 0 ) , tiny ( 0 . 0 )) ) write ( * , ' (a) ' ) pr ! create a format on the fly biggest = huge ( 0 ) ! + 0 for gfortran - 11 bug frmt = str ( ' (*(i ' , int ( log10 ( real ( biggest ))) + 0 , ' :,1x)) ' , sep = '' ) write ( * , * ) ' format= ' , frmt ! although it will often work , using str ( 3 f ) ! in an I / O statement is not recommended ! because if an error occurs str ( 3 f ) will try ! to write while part of an I / O statement ! which not all compilers can handle and is currently non - standard write ( * , * ) str ( ' program will now stop ' ) end program demo_str Output HUGE(3f) integers 2147483647 and real 3.40282347E+38 ...\nand double 1.7976931348623157E+308\nreal            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38\ndoubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...\n12345.678900000001 2.2250738585072014E-308\ncomplex         : (3.40282347E+38,1.17549435E-38)\n format=(*(i9:,1x))\n program will now stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic0 class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 class(*), intent(in), optional :: generica class(*), intent(in), optional :: genericb class(*), intent(in), optional :: genericc class(*), intent(in), optional :: genericd class(*), intent(in), optional :: generice class(*), intent(in), optional :: genericf class(*), intent(in), optional :: genericg class(*), intent(in), optional :: generich class(*), intent(in), optional :: generici class(*), intent(in), optional :: genericj type(force_kwargs_hack), intent(in), optional :: force_kwargs character(len=*), intent(in), optional :: sep logical, intent(in), optional :: if Return Value character(len=:), allocatable private pure function msg_one(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, force_kwargs, sep, if) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(in), optional :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) class(*), intent(in), optional :: generica (:) class(*), intent(in), optional :: genericb (:) class(*), intent(in), optional :: genericc (:) class(*), intent(in), optional :: genericd (:) class(*), intent(in), optional :: generice (:) class(*), intent(in), optional :: genericf (:) class(*), intent(in), optional :: genericg (:) class(*), intent(in), optional :: generich (:) class(*), intent(in), optional :: generici (:) class(*), intent(in), optional :: genericj (:) type(force_kwargs_hack), intent(in), optional :: force_kwargs character(len=*), intent(in), optional :: sep logical, intent(in), optional :: if Return Value character(len=:), allocatable","tags":"","url":"interface/str.html"},{"title":"test_mysub1 – M_framework","text":"subroutine test_mysub1() Arguments None Source Code subroutine test_mysub1 () ! first test call unit_test_start ( 'mysub1' ) ! the example goodbad(1) command called here takes many options ! used to build an SQLite3 entry ival = 10 call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub1\"' ) end subroutine test_mysub1","tags":"","url":"proc/test_mysub1.html"},{"title":"test_mysub2 – M_framework","text":"subroutine test_mysub2() Arguments None Source Code subroutine test_mysub2 () ! second test call unit_test_start ( 'mysub1' , '' , matched = matched ) ival = 200 if (. not . matched ) return ! makes it skippable call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub2\"' ) end subroutine test_mysub2","tags":"","url":"proc/test_mysub2.html"},{"title":"add – M_framework","text":"subroutine add(message, question, answer, answer2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: question character(len=*), intent(in) :: answer character(len=*), intent(in) :: answer2 Variables Type Visibility Attributes Name Initial logical, public :: passed Source Code subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if ( passed ) then call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer , 'got' , question ) else passed = question . eq . answer2 call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer2 , 'got' , question ) endif end subroutine add","tags":"","url":"proc/add.html"},{"title":"test_suite_assert – M_framework","text":"subroutine test_suite_assert() call unit_test(“assert”, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_assert () call unit_test_start ( \"assert\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"assert\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"assert\" , msg = \"\" ) end subroutine test_suite_assert","tags":"","url":"proc/test_suite_assert.html"},{"title":"test_suite_fmt – M_framework","text":"subroutine test_suite_fmt() call unit_test(“fmt   “, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_fmt () call unit_test_start ( \"fmt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"fmt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"fmt\" , msg = \"\" ) end subroutine test_suite_fmt","tags":"","url":"proc/test_suite_fmt.html"},{"title":"test_suite_pdec – M_framework","text":"subroutine test_suite_pdec() call unit_test(“pdec  “, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_pdec () call unit_test_start ( \"pdec\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"pdec  \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"pdec\" , msg = \"\" ) end subroutine test_suite_pdec","tags":"","url":"proc/test_suite_pdec.html"},{"title":"test_suite_set – M_framework","text":"subroutine test_suite_set() call unit_test(“set   “, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_set () call unit_test_start ( \"set\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"set   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"set\" , msg = \"\" ) end subroutine test_suite_set","tags":"","url":"proc/test_suite_set.html"},{"title":"test_suite_stderr – M_framework","text":"subroutine test_suite_stderr() call unit_test(“stderr”, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_stderr () call unit_test_start ( \"stderr\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"stderr\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"stderr\" , msg = \"\" ) end subroutine test_suite_stderr","tags":"","url":"proc/test_suite_stderr.html"},{"title":"test_suite_str – M_framework","text":"subroutine test_suite_str() Arguments None Variables Type Visibility Attributes Name Initial logical, public, allocatable :: tests (:) Source Code subroutine test_suite_str () logical , allocatable :: tests (:) call unit_test_start ( 'str' , 'test building message strings' , matched = matched ) if (. not . matched ) return tests = [ logical :: ] call add ( 'INTEGER' , str ( 10 ), '10' , '10' ) call add ( 'LOGICAL' , str (. false .), 'F' , 'F' ) call add ( 'LOGICAL' , str (. true .), 'T' , 'T' ) call add ( 'REAL' , str ( 10 0.0 ), '100.000000' , '100.0000' ) call add ( 'COMPLEX' , str (( 1 1.0 , 2 2.0 )), '(11.0000000,22.0000000)' , '(11.00000,22.00000)' ) call add ( 'COMPOUND' , str ( 10 , 10 0.0 , \"string\" ,( 1 1.0 , 2 2.0 ),. false .), & & '10 100.000000 string (11.0000000,22.0000000) F' ,& & '10 100.0000 string (11.00000,22.00000) F' ) call unit_test_msg ( 'str' , 'tally is ' , str ( tests ) // '' ) ! //'' for gfortran-11 bug call unit_test_end ( \"str   \" , msg = \"\" ) end subroutine test_suite_str","tags":"","url":"proc/test_suite_str.html"},{"title":"test_suite_wrt – M_framework","text":"subroutine test_suite_wrt() call unit_test(“wrt   “, 0 .eq. 0, “checking”,100) Arguments None Source Code subroutine test_suite_wrt () call unit_test_start ( \"wrt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"wrt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"wrt\" , msg = \"\" ) end subroutine test_suite_wrt","tags":"","url":"proc/test_suite_wrt.html"},{"title":"test_cos – M_framework","text":"subroutine test_cos() Arguments None Source Code subroutine test_cos () call unit_test_start ( 'cos' , msg = '' ) call unit_test_done ( 'cos' , msg = '' ) end subroutine test_cos","tags":"","url":"proc/test_cos.html"},{"title":"test_sin – M_framework","text":"subroutine test_sin() Arguments None Source Code subroutine test_sin () call unit_test_start ( 'sin' , msg = '' ) call unit_test_done ( 'sin' , msg = '' ) end subroutine test_sin","tags":"","url":"proc/test_sin.html"},{"title":"test_sqrt – M_framework","text":"subroutine test_sqrt() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine test_sqrt () integer :: i call unit_test_mode ( luns = [ 0 , 10 ]) call unit_test_start ( 'sqrt' , msg = '' ) call unit_test_mode ( luns = [ 0 , 10 ]) input = [ 1.0d0 , 4.0d0 , 9.0d0 ] expected = [ 1.0d0 , 2.0d0 , 3.0d0 ] answers = [( sqrt ( input ( i )), i = 1 , size ( input ))] call unit_test ( 'sqrt' , & all ( expected . eq . answers ), & 'check table of values' ) call unit_test ( 'sqrt' , & sqrt ( 2 5.0d0 ). eq . 5.0d0 , & 'got' , sqrt ( 2 5.0d0 ), 'expected' , 5.0d0 ) call unit_test_done ( 'sqrt' , msg = '' ) end subroutine test_sqrt","tags":"","url":"proc/test_sqrt.html"},{"title":"fileexists – M_framework","text":"function fileexists(filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: size Source Code logical function fileexists ( filename ) result ( r ) character ( len =* ), intent ( in ) :: filename integer :: size inquire ( file = filename , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function fileexists","tags":"","url":"proc/fileexists.html"},{"title":"here_and_now – M_framework","text":"function here_and_now() Arguments None Return Value character(len=25) Variables Type Visibility Attributes Name Initial character(len=1), public :: date *(8) character(len=1), public :: time *(10) character(len=1), public :: zone *(5) Source Code function here_and_now () ! 2023-05-01 23:05:12 UTC-0400 character :: date * ( 8 ), time * ( 10 ), zone * ( 5 ) character ( len = 25 ) :: here_and_now call date_and_time ( DATE = date , TIME = time , ZONE = zone ) !write(here_and_now,'(*(g0))')date(1:4),'-',date(5:6),'-',date(7:8),' ',time(1:2),':',time(3:4),':',time(5:6),' UTC',zone ! rfc-3339\"   ==> %Y-%M-%DT%h:%m:%s%z  2023-05-02T18:40:25-04:00; except ZONE is in write ( here_and_now , '(*(g0))' )& & date ( 1 : 4 ), '-' , date ( 5 : 6 ), '-' , date ( 7 : 8 ), 'T' , time ( 1 : 2 ), ':' , time ( 3 : 4 ), ':' , time ( 5 : 6 ), zone ( 1 : 3 ), ':' , zone ( 4 : 5 ) end function here_and_now","tags":"","url":"proc/here_and_now.html"},{"title":"unitexists – M_framework","text":"function unitexists(lun) result(r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: size Source Code logical function unitexists ( lun ) result ( r ) integer , intent ( in ) :: lun integer :: size inquire ( unit = lun , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function unitexists","tags":"","url":"proc/unitexists.html"},{"title":"cmdline_ – M_framework","text":"subroutine cmdline_() Arguments None Variables Type Visibility Attributes Name Initial character(len=4096), public, save :: arg integer, public :: equal_pos integer, public :: i integer, public :: iend character(len=4096), public, save :: input (3) = [character(len=4096)::'&long', '', ' /'] integer, public :: ios integer, public :: j character(len=256), public :: message1 character(len=256), public :: message2 Source Code subroutine cmdline_ () ! read arguments from command line as NAMELIST group input character ( len = 4096 ), save :: input ( 3 ) = [ character ( len = 4096 ) :: '&long' , '' , ' /' ], arg character ( len = 256 ) :: message1 , message2 integer :: i , j , ios , equal_pos , iend help = . false . version = . false . do i = 1 , command_argument_count () call get_command_argument ( i , arg ) do j = 1 , len_trim ( arg ) ! blank out leading - or / so \"--name=value\" or \"/name=value\" works if ( index ( '/- ' , arg ( j : j )) == 0 ) exit arg ( j : j ) = ' ' enddo arg = ' ' // adjustl ( arg ) if ( index ( arg , '=' ) == 0 ) arg = trim ( arg ) // '=T' ! if no equal sign add =T iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message1 ) if ( ios /= 0 ) then ! assume first failure might be because of missing quotes equal_pos = index ( arg , '=' ) ! find position of '=' if ( equal_pos /= 0 ) then ! requote and try again arg = arg (: equal_pos ) // '\"' // arg ( equal_pos + 1 : len_trim ( arg )) // '\"' iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message2 ) if ( ios /= 0 ) then write ( stderr , g ) 'BOOKKEEPER:ERROR UNQUOTED:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) if ( message1 . ne . message2 ) write ( stderr , g ) 'BOOKKEEPER:ERROR QUOTED  :' , trim ( message2 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( * , nml = long , delim = 'quote' ) stop 2 endif else write ( stderr , g ) 'ERROR:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( stderr , nml = long , delim = 'quote' ) stop 4 endif endif enddo if ( help ) call printhelp () if ( version ) call printversion () end subroutine cmdline_","tags":"","url":"proc/cmdline_~2.html"},{"title":"get_html_header – M_framework","text":"subroutine get_html_header() Arguments None Source Code subroutine get_html_header () html_header = [ CHARACTER ( LEN = 128 ) :: & '<html>' ,& '<head>' ,& '<title>unit_test_results</title>' ,& '<style>        ' ,& 'body {xfont-style: italic}' ,& 'body {                    ' ,& 'background-color:#FFF; color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }' ,& 'a:visited { color:#666; }                                                                                                ' ,& 'h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }                                              ' ,& 'h1 { font-size:200%; }                                                                                                   ' ,& 'h2 { font-size:173%; }                                                                                                   ' ,& 'h3 { font-size:144%; }                                                                                                   ' ,& 'h4 { font-size:120%; }                                                                                                   ' ,& 'h5,h6 { font-size:100% }                                                                                                 ' ,& 'a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }                                                   ' ,& '/*                                                                                                                       ' ,& 'td { border:thin solid #888; word-break: break-all; width: 1em}                                                          ' ,& '*/                                                                                                                       ' ,& 'td { border:thin solid #888; overflow-wrap: break-word; }                                                                ' ,& 'li { margin-bottom:0.5em; }                                                                                              ' ,& 'blockquote { display:block; font-size:90%; font-style:italic; line-height:1.5em; margin:0 0 1.5em; padding:0 2.5em; }    ' ,& 'pre { background-color:#DDD; font-size:90%; overflow:auto; padding:1em; }                                                ' ,& 'a,li span { color:#000; }                                                                                                ' ,& 'a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }                                                ' ,& '#Container { margin:0 10px; text-align:center; }                                                                         ' ,& '#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:58em; }                   ' ,& 'span.webName { font-size:.5em; }                                                                                         ' ,& 'textarea#content { font-size: 1em; line-height: 1.125em; }                                                               ' ,& 'h1#pageName { line-height:1.4em; margin:0.2em 0 0.2em 0; padding:0; }                                                    ' ,& 'h2{ line-height:1.2em; margin:0.2em 0 0.2em 0; padding:0; color:blue;}                                                   ' ,& '.property { color:#666; font-size:80%; }                                                                                 ' ,& 'a.existingWikiWord[title]{ //border: 1px dashed #BBB; }                                                                  ' ,& '.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; }                           ' ,& '/* table takes its dimensions from the <table> element width and                                                         ' ,& 'the width of the first row of cells (or the <col> elements, if you have them).*/                                         ' ,& 'table { table-layout: fixed ; width: 100% ; border:double #000; border-collapse:collapse; }                              ' ,& 'td { width: 25% ; }                                                                                                      ' ,& 'table#unit_test { table-layout: fixed ; width: 100% ; border-collapse: collapse ; border: 1px black solid ; }            ' ,& 'table#unit_test td { width: 25% ; border: 1px black solid ; padding: 10px ; }                                            ' ,& 'table#unit_test caption { font-style: italic ; font-weight: 600; color: gray;}                                           ' ,& '/*                                                                                                                       ' ,& 'col:nth-child(even) {background: #FFF}                                                                                   ' ,& 'col:nth-child(odd) {background: #CCC}                                                                                    ' ,& '*/                                                                                                                       ' ,& 'tr:nth-child(even) {background: #CCC}                                                                                    ' ,& 'tr:nth-child(odd) {background: #FFF}                                                                                     ' ,& '</style>                                                                                                                 ' ,& '<script language=\"JavaScript1.1\" type=\"text/javascript\">                                                                 ' ,& '//<![CDATA[                                                                                                              ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of class                                                                                    ' ,& '   function toggleHiddenClass(objectClassName) {                                                                         ' ,& '                                                                                                                         ' ,& '      const collection = document.getElementsByClassName(objectClassName);                                               ' ,& '                                                                                                                         ' ,& '      for (let i = 0; i < collection.length; i++) {                                                                      ' ,& '         if(collection[i].style.display == \"none\" ) {                                                                    ' ,& '            collection[i].style.display = \"\";                                                                            ' ,& '         }else{                                                                                                          ' ,& '            collection[i].style.display = \"none\";                                                                        ' ,& '         }                                                                                                               ' ,& '      }                                                                                                                  ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   //alert(\"A1\");                                                                                                        ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of id                                                                                       ' ,& '   function toggleHiddenId(objectIdName) {                                                                               ' ,& '      var TARGET = document.getElementById(objectIdName);                                                                ' ,& '      if(TARGET.style.display == \"none\" ) {                                                                              ' ,& '         TARGET.style.display = \"\";                                                                                      ' ,& '      }else{                                                                                                             ' ,& '         TARGET.style.display = \"none\";                                                                                  ' ,& '      }                                                                                                                  ' ,& '   //alert(TARGET.style.display);                                                                                        ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '</script>                                                                                                                ' ,& '<p>                                                                                                                      ' ,& '   <form>                                                                                                                ' ,& '      <input  type=\"button\"  value=\"passed\"   onclick=\"toggleHiddenClass(''passed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"failed\"   onclick=\"toggleHiddenClass(''failed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"untested\" onclick=\"toggleHiddenClass(''untested'');\" />                              ' ,& '      <input  type=\"button\"  value=\"clicks\"   onclick=\"toggleHiddenClass(''clicks'');\" />                                ' ,& '      <input  type=\"button\"  value=\"message\"  onclick=\"toggleHiddenClass(''message'');\" />                               ' ,& '      <input  type=\"button\"  value=\"caption\"  onclick=\"toggleHiddenClass(''caption'');\" />                               ' ,& '      <input  type=\"button\"  value=\"header\"   onclick=\"toggleHiddenClass(''header'');\" />                                ' ,& '  </form>                                                                                                                ' ,& '</p>                                                                                                                     ' ,& '</head>                                                                                                                  ' ,& '<body>                                                                                                                   ' ,& '<div id=\"Container\">                                                                                                     ' ,& '<div id=\"Content\">                                                                                                       ' ,& '' ] html_footer = [ CHARACTER ( LEN = 128 ) :: & '</div>' ,& '</div>' ,& '</body>' ,& '</html>' ,& '' ] end subroutine get_html_header","tags":"","url":"proc/get_html_header.html"},{"title":"header – M_framework","text":"subroutine header() Arguments None Source Code subroutine header () if ( . not . exists ( 'bookkeeper.csv' ) ) then write ( csvfile , g0 ) '\"name\",\"date\",\"passed\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.html' ) ) then call get_html_header () write ( htmlfile , '(a)' )( trim ( html_header ( i )), i = 1 , size ( html_header )) endif if ( . not . exists ( 'bookkeeper_clicks.csv' ) ) then write ( clicksfile , g0 ) '\"name\",\"date\",\"clicks\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.nml' ) ) then write ( nmlfile , g0 ) ' Fortran NAMELIST group file containing test results' write ( nmlfile , g0 ) ' that may be read with a simple program and used to' write ( nmlfile , g0 ) ' generate reports in other formats.' write ( nmlfile , g0 ) ' ' endif end subroutine header","tags":"","url":"proc/header.html"},{"title":"printhelp – M_framework","text":"subroutine printhelp() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)printhelp(3f): prints help information\" Source Code subroutine printhelp () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& 'NAME                                                                            ' ,& '    bookkeeper-(1f) - example filter program callable from the M_framework(3f)  ' ,& '    unit testing harness.                                                       ' ,& '    (LICENSE:PD)                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' commands:                                                                      ' ,& '                                                                                ' ,& '     bookkeeper [help| version]                                                 ' ,& '     bookkeeper type=\"start\" name=\"NAME\" msg=\"MESSAGE TEXT\" [opts]              ' ,& '     bookkeeper type=\"check\" name=\"NAME\" msg=\"MESSAGE TEXT\" ...                 ' ,& '                passed=\"passed|failed\"                                          ' ,& '     bookkeeper type=\"end\" name=\"NAME\" msg=\"MESSAGE TEXT\" clicks=N ...          ' ,& '                [passed=\"failed|passed|untested\"]                               ' ,& '     bookkeeper type=\"stop\" name=\"NAME\" msg=\"MESSAGE TEXT\"                      ' ,& '                [passed=\"failed|passed|untested\"] clicks=M                      ' ,& '     bookkeeper type=\"message\" name=\"NAME\" msg=\"MESSAGE TEXT\"                   ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& ' This is an example program that shows how to create an external program that   ' ,& ' can be called by the testing harness in the M_framework__verify(3f) module     ' ,& ' for custom processing. Data is based in the form of NAMELIST group data        ' ,& ' for the NAMELIST group                                                         ' ,& '                                                                                ' ,& '     character(len=:),allocatable :: type                                       ' ,& '     character(len=:),allocatable :: name                                       ' ,& '     character(len=:),allocatable :: passed                                     ' ,& '     character(len=:),allocatable :: msg                                        ' ,& '     character(len=25)            :: date                                       ' ,& '     integer(kind=int64)          :: clicks                                     ' ,& '     logical                      :: help                                       ' ,& '     logical                      :: version                                    ' ,& '                                                                                ' ,& ' The data conforms to the Fortran NAMELIST group input syntax with the          ' ,& ' delimiter set to a double-quote except extraneous spaces are not allowed,      ' ,& ' and names may optionally be preceded by \" --\" or \" /\" and if no equal          ' ,& ' appears after a keyword \"=T\" is assumed to appear more like typical            ' ,& ' Unix long options or MSWindows commands. So these would all be                 ' ,& ' equivalent:                                                                    ' ,& '                                                                                ' ,& '      bookkeeper type=\"end\" msg=\"message text\"                                  ' ,& '      bookkeeper /type=\"end\" /msg=\"message text\"                                ' ,& '      bookkeeper --type=\"end\" --msg=\"message text\"                              ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    type     \"start\",\"check\",\"end\",\"stop\",\"message\"                             ' ,& '    name     a label, typically the name of the procedure that was tested.      ' ,& '    passed   \"passed\",\"failed\",\"untested\"                                       ' ,& '    msg      a description of the test, or a descriptive message                ' ,& '    date     YYYY-MM-DDTHH:MM:SS-HH:MM                                          ' ,& '    clicks   for type=\"end\" assumed to be the time in clicks since the          ' ,& '             previous type=\"start\"                                              ' ,& '    silent|brief|verbose   silent produces no output from unit_check_* routines ' ,& '                           brief only shows failed tests, verbose shows all     ' ,& '                           messages including compiler and options.             ' ,& '    help     display this help and exit                                         ' ,& '    version  output version information and exit                                ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '    Sample commands                                                             ' ,& '                                                                                ' ,& '       fpm test -- command=bookkeeper                                           ' ,& '       fpm test --target=''time*'' -- command=bookkeeper luns=6                   ' ,& '                                                                                ' ,& '                                                                                ' ,& 'SEE ALSO                                                                        ' ,& '    M_framework(3f), unit_test(3f), unit_test_mode(3f)                          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printhelp","tags":"","url":"proc/printhelp.html"},{"title":"printversion – M_framework","text":"subroutine printversion() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)printhelp(3f): prints help information\" Source Code subroutine printversion () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& '                                                                                ' ,& 'PRODUCT:        Fortran Unit Testing Harness                                    ' ,& 'PROGRAM:        bookkeeper(1)                                                   ' ,& 'DESCRIPTION:    filter data from M_framework(3f) Unit Testing Framework         ' ,& 'VERSION:        1.0, 20230507                                                   ' ,& 'AUTHOR:         John S. Urban                                                   ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                            ' ,& 'HOME PAGE:      https://github.com/urbanjost/M_framework                        ' ,& 'LICENSE:        Public Domain. This is free software: you are free to change    ' ,& '                and redistribute it. There is NO WARRANTY,                      ' ,& '                to the extent permitted by law.                                 ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printversion","tags":"","url":"proc/printversion.html"},{"title":"exists – M_framework","text":"public interface exists Module Procedures function fileexists (filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical function unitexists (lun) result(r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical","tags":"","url":"interface/exists.html"},{"title":"M_framework__verify_demo – M_framework","text":"Subroutines public  subroutine one (array) Arguments Type Intent Optional Attributes Name integer, intent(out), allocatable :: array (:) public  subroutine two (array) Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: array (:)","tags":"","url":"module/m_framework__verify_demo.html"},{"title":"M_framework__timing – M_framework","text":"Uses iso_fortran_env Interfaces public        interface timer private  function clock_new(this) Arguments Type Intent Optional Attributes Name type( timer ), intent(in), optional :: this Return Value type( timer ) Derived Types type, public :: timer Components Type Visibility Attributes Name Initial integer(kind=int64), public :: clock_end integer(kind=int64), public :: clock_start real(kind=real64), public :: cpu_end real(kind=real64), public :: cpu_start Constructor private\n\n                    \n                    function clock_new (this) Type-Bound Procedures procedure, public :: cputime => clock_cputime procedure, public :: print => clock_print procedure, public :: tic => clock_tic procedure, public :: toc => clock_toc procedure, public :: wallclock => clock_wallclock","tags":"","url":"module/m_framework__timing.html"},{"title":"M_framework__utility – M_framework","text":"Uses iso_fortran_env Subroutines public  subroutine fstop (ierr, stdout, stderr) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: stdout character(len=*), intent(in), optional :: stderr","tags":"","url":"module/m_framework__utility.html"},{"title":"M_framework__verify – M_framework","text":"NAME M_framework__verify(3f) - [M_framework__verify::INTRO] unit test framework\n (LICENSE:PD) SYNOPSIS Module procedures use M_framework, only : unit_test, unit_test_start,    &\n                        unit_test_end, unit_test_stop, &\n                        unit_test_msg, unit_test_mode, &\n                        unit_test_system,              &\n                        unit_test_expected Module values use M_framework, only : unit_test_level, unit_test_flags QUOTE Do not let your victories go to your head , nor let your failures go to your heart . DESCRIPTION The M_framework ( 3 f ) module is a collection of Fortran routines for supporting code development by providing logging , error processing , debugging , comparison and unit testing procedures . The M_framework__verify ( 3 f ) module specifically brings together a few procedures for creating unit testing . It ... o allows for a user - defined command to be called to collect results or produce mail alerts , or other custom bookkeeping operations . o supports easily composing a message from up to twenty scalar intrinsic values and different strings o allows stopping on failure or continuing o provides for a non - zero exit code if any tests fail o is designed for with integration with the fpm ( Fortran Package Manager ) \"test\" subcommand . If default modes need changed it can be done via the unit_test_mode ( 3 f ) procedure or as command line options . messages by default are writing to stderr , but may be written to any list of LUNs of preassigned or open files . SET MODES Some of the most common options are call unit_test_mode ( command , keep_going , level , luns = [ K , L , M , N , ... ]) keep_going logical variable that can be used to turn on or off program termination on errors . luns array of Fortran LUNs to write messages to level An integer that can be used to specify different debug levels command name of optional command to execute for a start , check , or finish . PROCEDURES The unit test procedures are unit_test_start () start tests of a procedure unit_test () report if expression is false or true and if . false . stop program when keep_going = . false . unit_test_end () ends test of a procedure unit_test_msg () write message unit_test_stop () stop program with exit value of 0 if no failures else with an exit value of 1 unit_test_system () execute system command , recursively if requested . The unit test short-cut procedures are unit_test_expected () report if two values are equal For custom unit testing reports , a command can be given that will be passed information on the command line in NAMELIST format . This command is generally a script that makes entries for each unit , perhaps in an SQLite data file for example . It might also send an email if a test fails in batch environments . It could also convert the information to CSV for use in spreadsheets , or generate an HTML report , for example . A sample command written in the bash ( 1 ) shell and using the sqlite3 ( 1 ) command should be included in this distribution as an example . The flexibility introduced by calling an external script or program is that the command can be changed as desired without changing the test programs . RELATED FUNCTIONS The routines in M_framework__verify ( 3 f ) are often combined with other small modules such as Comparisons of real values can be done with a tolerance with M_Compare_Float_Numbers ( 3 f ) and M_framework__approx ( 3 f ) . M_hashkeys ( 3 f ) routines and various math and statistical routines can be helpful to quickly create unit tests . The intrinsics ANY ( 3 f ) and ALL ( 3 f ) are particularly useful in calls to unit_test ( 3 f ) . EXAMPLES Sample program !! program demo_M_framework__verify module M_framework__verify_demo private public one ! some regular routine public two ! some regular routine contains subroutine one ( array ) integer , intent ( out ), allocatable :: array ( : ) array = [ 21 , 51 , 14 , 45 ] end subroutine one subroutine two ( array ) integer , intent ( inout ), allocatable :: array ( : ) array = 2 * array end subroutine two end module M_framework__verify_demo program demo_M_framework__verify use M_framework , only: unit_test_start , unit_test , & & unit_test_end , unit_test_msg , unit_test_stop , & & unit_test_system , unit_test_mode use M_framework__verify_demo , only: one , two ! set - up call unit_test_mode ( command = '', flags = [ 0 ], keep_going = . true .) ! call a test procedure for each routine to test call test_one () call test_two () ! tear - down call unit_test_stop () contains subroutine test_one () integer , allocatable :: results ( : ) integer , parameter :: expected ( * ) = [ 21 , 51 , 14 , 45 ] call unit_test_start (' one ') call one ( results ) call unit_test (' one ', all ( expected > 0 ), & & ' testing if everyone greater than zero ') call unit_test (' one ', all ( expected == results ), & & ' testing if all values are expected ') call unit_test_end (' one ',' checks on \"one\" ended ') end subroutine test_one subroutine test_two integer , allocatable :: results ( : ) integer , parameter :: expected ( * ) = [ 2 , 20 , 200 ] results = [ 1 , 10 , 100 ] call two ( results ) call unit_test_start (' two ',' check procedure \"two\" ') call unit_test (' two ', all ( expected == results ) . and . & & all ( expected > 0 ) . and . maxval ( expected ) < 201 , msg = ' long expression ') call unit_test_end (' two ',' checks on \"two\" ended ') end subroutine test_two end program demo_M_framework__verify Expected output: check_start : one START : check : one SUCCESS : testing if everyone greater than zero check : one SUCCESS : testing if all values are expected check_end : one PASSED : GOOD : 2 BAD : 0 DURATION : 00000001 check_start : two START : check : two SUCCESS : long expression check_end : two PASSED : GOOD : 1 BAD : 0 DURATION : 00000000 check_stop : TALLY PASSED : GOOD : 3 BAD : 0 DURATION : 00000001 AUTHOR John S. Urban LICENSE Public Domain Uses M_framework__msg iso_fortran_env Variables Type Visibility Attributes Name Initial type(prefix), public, save :: CHECK_PREFIX = prefix(null(), null(), null(), null(), null()) integer, public, parameter :: EXIT_FAILURE = 1 integer, public, parameter :: EXIT_SUCCESS = 0 integer, public, parameter :: realtime = kind(0.0d0) integer, public :: unit_check_level integer, public, save, allocatable :: unit_test_flags (:) integer, public, save :: unit_test_level = 0 Interfaces public        interface unit_check public  subroutine unit_test (name, logical_expression, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, wordy) NAME unit_test ( 3 f ) - [ M_framework__verify ] report if logical expression is true or false , optionally call command and / or stop program . ( LICENSE : PD ) SYNOPSIS subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&\n& ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail)\n\n character(len=*),intent(in) :: name\n logical,intent(in) :: expression\n class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&\n & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj\n logical,intent(in),optional :: only_on_fail DESCRIPTION unit_test ( 3 f ) tests the expression and displays a message composed of the generic intrinsic values msg , and g1 thorough gj . Additionally , if the expression is false o if unit_test_mode ( command ) is not blank calls the specified shell command $C OMMAND name = \" NAME \" type = \" check \" passed = \" passed|failed \" ... msg = \" all messages \" o if keep_going = . false . stop the program on a failed test OPTIONS NAME the unit test name EXPRESSION the logical expression to evaluate msg , g1 ... gj optional message to display when performing test , composed of any scalar intrinsics of type INTEGER , REAL , DOUBLEPRECISION , COMPLEX , LOGICAL , or CHARACTER . A space is placed between each value . wordy If . false . The message MSG is only displayed if the expression is . false . . Must be used as a keyword . Default is . true . . EXAMPLES Sample program: program demo_unit_test use M_framework , only : & & unit_test_mode , & & unit_test_start , & & unit_test , & & unit_test_end , & & unit_test_stop use M_framework , only : almost implicit none integer :: i integer :: x integer , allocatable :: arr ( : ) real , allocatable :: arr1 ( : ) real , allocatable :: arr2 ( : ) call unit_test_mode ( keep_going = . true ., debug = . false ., command = '' ) x = 10 arr1 = [ 1 . 0 , 10 . 0 , 100 . 0 ] arr2 = [ 1 . 0001 , 10 . 001 , 100 . 01 ] call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) do i = 1 , size ( arr1 ) call unit_test ( ' myroutine ' , & & almost ( arr1 ( i ) , arr2 ( i ) , 3 . 9 , verbose = . true . ) ) enddo arr = [ 10 , 20 , 30 ] call unit_test ( ' myroutine ' , . not . any ( arr < 0 ) , & & ' fail if any negative values in array ARR ' ) call unit_test ( ' myroutine ' , all ( arr < 100 ) , & & ' fail unless all values are less than 100 in array ARR ' ) call unit_test_end ( ' myroutine ' , & & msg = ' checks on \"myroutine\" all passed ' ) call unit_test_stop () end program demo_unit_test Results: Sample output (varies with what optional command or modes is used): > check_start : myroutine START : > check : myroutine SUCCESS : if big enough > check : myroutine SUCCESS : if small enough >* almost * for values 1 . 00000000 1 . 00010002 agreement of 3 . 99997139 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : >* almost * for values 10 . 0000000 10 . 0010004 agreement of 3 . 99986792 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : >* almost * for values 100 . 000000 100 . 010002 agreement of 3 . 99995065 ... > digits out of requested 3 . 90000010 > check : myroutine SUCCESS : > check : myroutine SUCCESS : fail if any negative ... > values in array ARR > check : myroutine SUCCESS : fail unless all values ... > are less than 100 in array ARR > check_end : myroutine PASSED : GOOD : 7 BAD : ... > 0 DURATION : 00000000294709 : checks on \" myroutine \" all passed > check_stop : TALLY PASSED : GOOD : 7 BAD : ... > 0 DURATION : 00000000267059 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: wordy public        interface unit_check_bad public  subroutine unit_test_bad (name, opts, msg) NAME unit_test_bad ( 3 f ) - [ M_framework__verify ] call command \"goodbad NAME bad\" and stop program ( LICENSE : PD ) SYNOPSIS subroutine unit_test_bad(name,msg,opts)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION unit_test_bad ( 3 f ) calls the shell command goodbad NAME bad [ opts ] and stops the program . It is just a shortcut for calling call unit_test ( name ,. false .) call unit_test_end ( name , msg , opts ) EXAMPLES Sample program: program demo_unit_test_bad use M_framework , only : unit_test_start , unit_test use M_framework , only : unit_test_end , unit_test_stop use M_framework , only : unit_test_bad implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) if ( x /= 0 ) then call unit_test_bad ( ' myroutine ' , msg = ' checks on \"myroutine\" failed ' ) ! program execution stopped endif call unit_test_end ( ' myroutine ' ) call unit_test_stop ( ' myroutine ' ) end program demo_unit_test_bad AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg public        interface unit_check_done public  subroutine unit_test_end (name, msg, opts) NAME unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) SYNOPSIS subroutine unit_test_end(name,msg,opts)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION A message is shown including the duration of the tests If there have been no failures the optional shell command $C OMMAND name = \" name \" type = \" end \" passed = \" passed|failed|untested \" ... clicks = NNNN msg = \" message \" opts is executed EXAMPLES Sample program: program demo_unit_test_end use M_framework , only : unit_test_start use M_framework , only : unit_test use M_framework , only : unit_test_end implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) ! program execution stopped call unit_test_end ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_test_end AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts public        interface unit_check_good public  subroutine unit_test_good (name, msg, opts) NAME unit_test_good ( 3 f ) - [ M_framework__verify ] call command \"goodbad NAME good\" ( LICENSE : PD ) SYNOPSIS subroutine unit_test_good(name,msg,opts)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION A shortcut for call unit_test ( name ,. true . ) call unit_test_end ( name , opts , msg ) EXAMPLES Sample program: program demo_unit_test_good use M_framework , only : unit_test_start , unit_test_end use M_framework , only : unit_test , unit_test_good implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) call unit_test_good ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_test_good AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts public        interface unit_check_mode public  subroutine unit_test_mode (debug, keep_going, level, flags, command, brief, verbose, silent, cmdline, interactive, luns, match) NAME unit_test_mode ( 3 f ) - [ M_framework__verify ] set testing modes ( LICENSE : PD ) SYNOPSIS subroutine unit_test_mode( keep_going, flags, luns, command, &\n  brief, interactive, CMDLINE, debug, match)\n\n  logical,intent(in) :: keep_going, brief, interactive,debug\n  integer,intent(in),allocatable :: luns(:), flags(:)\n  character(len=*),intent(in) :: command DESCRIPTION unit_test_mode(3f) changes testing mode defaults OPTIONS keep_going keep running if a test fails . Default to TRUE flags a list of integer values that can be accessed from M_framework as unit_test_flags (:) for use in selecting various tests conditionally luns list of Fortran units to unit test messages to . Defaults to the the value of ERROR_UNIT from the intrinsic module ISO_FORTRAN_ENV ( ie . defaults to \"stderr\" ) . It is Assumed the units have been opened by the program . match the string that is tested against the name and msg specified on unit_test_start () to set the \"matched\" argument . command filter command , typically to generate reports . It is passed data on the command line . See the example filter \"bookkeeper\" for examples . brief If present only \"FAIL\" messages are produced . brief Only display FAIL messages and related information verbose verbose mode displays compiler version and options and all standard messages . silent no output from unit_test_ * ( 3 f ) procedures interactive prompt as each test case starts as to continue . cmdline If set to . false . do not parse command line for options . debug Debug mode for the M_framework package EXAMPLES Sample program: program demo_unit_test_mode use M_framework implicit none call unit_test_mode ( keep_going = . false ., luns = [ 6 ], & & brief = . true . ) end program demo_unit_test_mode AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: debug logical, intent(in), optional :: keep_going integer, intent(in), optional :: level integer, intent(in), optional :: flags (:) character(len=*), intent(in), optional :: command logical, intent(in), optional :: brief logical, intent(in), optional :: verbose logical, intent(in), optional :: silent logical, intent(in), optional :: cmdline logical, intent(in), optional :: interactive integer, intent(in), optional :: luns (:) character(len=*), intent(in), optional :: match public        interface unit_check_msg public  subroutine unit_test_msg (name, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, if) NAME unit_test_msg ( 3 f ) - [ M_framework__verify ] converts up to twenty standard scalar values to a message for unit testing ( LICENSE : PD ) SYNOPSIS function unit_test_msg ( name , msg , & & g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , if ) character ( len = * ), intent ( in ) :: name class ( * ), intent ( in ), optional :: msg , & & g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj DESCRIPTION unit_test_msg(3f) builds a string from up to twenty scalar values and\nprints it to the error log. OPTIONS name name of unit being tested msg , g [ 1 - j ] optional values to print the value of . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . if expression must be true or message is not output . Must be specified by keyword as \" if=expression \" . EXAMPLES Sample program: program demo_unit_test_msg use M_framework , only : unit_test_start , unit_test_msg , & & unit_test_end implicit none call unit_test_start ( ' myroutine ' ) call unit_test_msg ( ' myroutine ' , ' HUGE(3f) integers ' , & & huge ( 0 ) , ' and real ' , huge ( 0 . 0 ) , ' and double ' , huge ( 0 . 0 d0 )) call unit_test_msg ( ' myroutine ' , ' real            : ' , & & huge ( 0 . 0 ) , 0 . 0 , 12345 . 6789 , tiny ( 0 . 0 ) ) call unit_test_msg ( ' myroutine ' , ' doubleprecision : ' , & & huge ( 0 . 0 d0 ) , 0 . 0 d0 , 12345 . 6789 d0 , tiny ( 0 . 0 d0 ) ) call unit_test_msg ( ' myroutine ' , ' complex         : ' , & & cmplx ( huge ( 0 . 0 ) , tiny ( 0 . 0 )) ) call unit_test_end ( ' myroutine ' ) end program demo_unit_test_msg AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: if public        interface unit_check_start public  subroutine unit_test_start (name, msg, opts, force_keywd, matched) NAME unit_test_start ( 3 f ) - [ M_framework__verify ] reset counters and start a new test block ( LICENSE : PD ) SYNOPSIS subroutine unit_test_start(name,msg,opts,matched)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts\n logical,intent(out),optional         :: matched DESCRIPTION unit_test_start ( 3 f ) is an initialization procedure for starting a new procedure test . OPTIONS NAME name of the procedure to test MSG message to print OPTS pass additional options to the optional shell command that can be assigned on the command line or by unit_test_mode ( 3f ). MATCHED if the match string has been set with unit_test_mode ( 3f ) or on the command line this will return true if the name and msg concatenated with a space match the entire match string , where \"*\" matches any string and \"?\" matches any single character . This allows you to skip a test set if you wish by exiting . EXAMPLES Sample program: program demo_unit_test_start use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_mode , unit_test_stop implicit none integer :: ival logical :: matched call unit_test_mode () call test_mysub1 () call test_mysub2 () call unit_test_stop () contains subroutine test_mysub1 () ! first test call unit_test_start ( ' mysub1 ' ) ! the example goodbad ( 1 ) command called here takes many options ! used to build an SQLite3 entry ival = 10 call unit_test ( ' mysub1 ' , ival > 3 , msg = ' if big enough ' ) call unit_test ( ' mysub1 ' , ival < 100 , msg = ' if small enough ' ) call unit_test_end ( ' mysub1 ' , msg = ' completed checks of \"mysub1\" ' ) end subroutine test_mysub1 subroutine test_mysub2 () ! second test call unit_test_start ( ' mysub1 ' , '' , matched = matched ) ival = 200 if ( . not . matched ) return ! makes it skippable call unit_test ( ' mysub1 ' , ival > 3 , msg = ' if big enough ' ) call unit_test ( ' mysub1 ' , ival < 100 , msg = ' if small enough ' ) call unit_test_end ( ' mysub1 ' , msg = ' completed checks of \"mysub2\" ' ) end subroutine test_mysub2 end program demo_unit_test_start AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(out), optional :: matched public        interface unit_check_stop public  subroutine unit_test_stop (msg) NAME unit_test_stop ( 3 f ) - [ M_framework__verify ] report tally of all checks and stop program ( LICENSE : PD ) SYNOPSIS subroutine unit_test_stop(msg,opts)\n\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION give a tally of all calls to unit_test ( 3 f ) and stop program . Tally up the test result totals and stop the program . If a command is set via unit_test_mode ( 3 f ) or the command line call it appending OPTS to the end of the command . OPTIONS MSG additional message to display OPTS add string to filter command line if any is specified . EXAMPLES Sample program: program demo_unit_test_stop use M_framework , only : unit_test_start , unit_test_end , & & unit_test , unit_test_stop , unit_test_mode use , intrinsic :: iso_fortran_env , stdout => OUTPUT_UNIT implicit none integer :: x x = 10 call unit_test_mode ( luns =[ stdout ] ) ! do a test call unit_test_start ( 'proc1' ) call unit_test ( 'proc1' , x > 3 , 'if big enough' ) call unit_test ( 'proc1' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc1' , msg = 'checks all done' ) ! do another test call unit_test_start ( 'proc2' ) call unit_test ( 'proc2' , x > 3 , 'if big enough' ) call unit_test ( 'proc2' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc2' , msg = 'checks all done' ) ! tally up test results and stop program call unit_test_stop () end program demo_unit_test_stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg public        interface unit_test_done public  subroutine unit_test_end (name, msg, opts) NAME unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) SYNOPSIS subroutine unit_test_end(name,msg,opts)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: msg\n character(len=*),intent(in),optional :: opts DESCRIPTION A message is shown including the duration of the tests If there have been no failures the optional shell command $C OMMAND name = \" name \" type = \" end \" passed = \" passed|failed|untested \" ... clicks = NNNN msg = \" message \" opts is executed EXAMPLES Sample program: program demo_unit_test_end use M_framework , only : unit_test_start use M_framework , only : unit_test use M_framework , only : unit_test_end implicit none integer :: x x = 10 call unit_test_start ( ' myroutine ' ) call unit_test ( ' myroutine ' , x > 3 , ' if big enough ' ) call unit_test ( ' myroutine ' , x < 100 , ' if small enough ' ) ! program execution stopped call unit_test_end ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_test_end AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts public        interface unit_test_expected private impure elemental subroutine unit_test_expected_int32(name, result, expected) NAME unit_test_expected ( 3 f ) - [ M_framework__verify ] report if two scalar values of like type and kind are equal . ( LICENSE : PD ) SYNOPSIS impure elemental subroutine unit_test_example(name,result,expected)\n\n character(len=*),intent(in)  :: name\n class(*),intent(in)          :: result\n class(*),intent(in),optional :: expected DESCRIPTION A shortcut for a common call to unit_test ( 3 f ) tests the two values of like type and kind . It is equivalent to call unit_test ( name , result , expected , ' result= ' , result , ' expected= ' ,. true . ) OPTIONS RESULT A generated value or expression of integer , real , character , or complex type . EXPECTED The expected value for RESULT , of the same type and kind as RESULT . If not present , it is equivalent to . TRUE . EXAMPLES Sample program: program demo_unit_test_expected use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit use M_framework , only : & & unit_test_mode , & & start => unit_test_start , & & expected => unit_test_expected , & & stop => unit_test_stop , & & unit_test_level ! , unit_test_flags implicit none logical , parameter :: T = . true ., F = . false . ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags =[ 0 ] , & luns =[ stderr ] , & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 ! unit tests for ABS ( 3 f ) intrinsic call start ( 'abs' ) ! integer call expected ( 'abs' , abs ( - 10 ), 10 ) call expected ( 'abs' , abs ( 10 ), 10 ) ! real and elemental call expected ( 'abs' , abs ( [ -10.0, 10.0 ] ), 10.0 ) ! complex call expected ( 'abs' , abs (( 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( 3.0 , 4.0 )), 5.0 ) call stop ( 'abs' ) end program demo_unit_test_expected AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: result integer(kind=int32), intent(in) :: expected private impure elemental subroutine unit_test_expected_int64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name integer(kind=int64), intent(in) :: result integer(kind=int64), intent(in) :: expected private impure elemental subroutine unit_test_expected_char(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in) :: result character(len=*), intent(in) :: expected private impure elemental subroutine unit_test_expected_boolean(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: result logical, intent(in) :: expected private impure elemental subroutine unit_test_expected_onoff(name, result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: result private impure elemental subroutine unit_test_expected_real32(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=real32), intent(in) :: result real(kind=real32), intent(in) :: expected private impure elemental subroutine unit_test_expected_real64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=real64), intent(in) :: result real(kind=real64), intent(in) :: expected private impure elemental subroutine unit_test_expected_cmplx32(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name complex(kind=real32), intent(in) :: result complex(kind=real32), intent(in) :: expected private impure elemental subroutine unit_test_expected_cmplx64(name, result, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name complex(kind=real64), intent(in) :: result complex(kind=real64), intent(in) :: expected Functions public  function unit_test_system (command, verbose) result(istat) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command logical, intent(in), optional :: verbose Return Value integer Subroutines public  subroutine unit_test (name, logical_expression, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, wordy) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: wordy public  subroutine unit_test_bad (name, opts, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg public  subroutine unit_test_end (name, msg, opts) unit_test_end(3f) - [M_framework__verify] end test of procedure started\n by unit_test_start(3f)\n    (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts public  subroutine unit_test_good (name, msg, opts) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts public  subroutine unit_test_mode (debug, keep_going, level, flags, command, brief, verbose, silent, cmdline, interactive, luns, match) Sample program: Read more… Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: debug logical, intent(in), optional :: keep_going integer, intent(in), optional :: level integer, intent(in), optional :: flags (:) character(len=*), intent(in), optional :: command logical, intent(in), optional :: brief logical, intent(in), optional :: verbose logical, intent(in), optional :: silent logical, intent(in), optional :: cmdline logical, intent(in), optional :: interactive integer, intent(in), optional :: luns (:) character(len=*), intent(in), optional :: match public  subroutine unit_test_msg (name, msg, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, force_keywd, if) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: msg class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(in), optional :: if public  subroutine unit_test_start (name, msg, opts, force_keywd, matched) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: msg character(len=*), intent(in), optional :: opts type(force_keywd_hack), intent(in), optional :: force_keywd logical, intent(out), optional :: matched public  subroutine unit_test_stop (msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg","tags":"","url":"module/m_framework__verify.html"},{"title":"M_framework__attr – M_framework","text":"NAME M_framework__attr(3f) - [M_framework__attr::INTRO] control text attributes on terminals\n(LICENSE:MIT) SYNOPSIS use M_framework__attr, only : attr, attr_mode, attr_update DESCRIPTION M_framework__attr(3f) is a Fortran module that uses common ANSI escape sequences\nto control terminal text attributes.\n\n     use M_framework__attr\n     write(*,*)attr(' <red> Red Text! </red> <green> Green Text! </green> ')\n     end\n\nIt is designed to use three simple procedures to\n\n + Specify attributes using simple HTML-like syntax\n + allow the sequences to be suppressed when desired\n + permit the  user program to completely customize the keywords.\n   The user can add, delete and replace the sequences associated with\n   a keyword without changing the code.\n\nOne advantage of the approach of using formatting directives which\nare replaced with in-band escape sequences is that it is easy to turn\noff when running batch.\n\nAnother important capability is that programs can be run in \"raw\" mode\nand create a simple text file with the formatting directives in it\nthat can then be read back in by a simple filter program that strips\nit back to plain text( see app/plain.f90), or displays it to a screen\nin color(see app/light.f90) or perhaps converts it to another format.\n\nSo this approach makes it trivial to read specially-formatted data\nfrom a file like a message catalog (perhaps with various versions in\ndifferent languages) and colorize it or display it as plain text\n\nBy making each line self-contained (by default) lines can be filtered\nby external utilities and still display correctly. ACCESS Via git ( 1 ) : git clone https : // github . com / urbanjost / M_framework__attr . git cd M_framework__attr / src # change Makefile if not using one of the listed compilers make clean ; make gfortran # for gfortran make clean ; make ifort # for ifort make clean ; make nvfortran # for nvfortran This will compile the M_framework__attr module and example programs . Alternatively , via fpm ( see https : // github . com / fortran - lang / fpm ) : git clone https : // github . com / urbanjost / M_framework__attr . git or just list it as a dependency in your fpm . toml project file . [ dependencies ] M_framework__attr = { git = \"https://github.com/urbanjost/M_framework__attr.git\" } LIMITATIONS o colors are not nestable.\n   o keywords are case-sensitive,\n   o ANSI escape sequences are not universally supported by\n     all terminal emulators; and normally should be suppressed\n     when not going to a tty device. Therefore, you should use\n     M_system::system_istty(3f) or the common Fortran extension\n     ISATTY() to set the default to “plain” instead of “color”\n     when the output file is not a conforming terminal. On basic\n     MSWindows console windows, it is best to use Windows 10+ and/or\n     the Linux mode; you may have to enable ANSI escape sequence\n     mode on MSWindows. It does work as-is with CygWin and MinGW and\n     Putty windows and mintty(1) as tested. EXAMPLES Sample program\n\n program demo_M_framework__attr\n use M_framework__attr, only : attr, attr_mode, attr_update\n implicit none\n character(len=256) :: line\n character(len=*),parameter :: f='( & & \" <bo><w><G> GREAT: </G></w> & & The new value <Y><b> \",f8.4,1x,\" </b></Y> is in range\" & & )'\n real :: value\n\n    write(*,'(a)') & & attr(' <r><W><bo> ERROR: </W> red text on a white background </y> ')\n\n    value=3.4567\n    write(line,fmt=f) value\n    write(*,'(a)')attr(trim(line))\n\n    ! write same string as plain text\n    write(*,*)\n    call attr_mode(manner='plain')\n    write(*,'(a)')attr(trim(line))\n\n    call attr_mode(manner='color')\n    ! use pre-defined or user defined strings\n    write(*,*)\n    write(*,'(a)')attr(' <ERROR> Woe is nigh.')\n    write(*,'(a)')attr(' <WARNING> The night is young.')\n    write(*,'(a)')attr(' <INFO> It is Monday')\n\n    ! create a custom mnemonic\n    call attr_update('MYERROR',attr( & ' <R><e> E <w> - <e> R <w> - <e> R <w> - <e> O <w> - <e> R: </e></R></bo> ' & ))\n    write(*,*)\n    write(*,'(a)')attr(' <MYERROR> my custom message style')\n\n end program demo_M_framework__attr AUTHOR John S. Urban, 2021 LICENSE MIT SEE ALSO attr(3f), attr_mode(3f), attr_update(3f)\n\nRelated information:\n\n terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),\n console_codes(4), ECMA-48,\n https://en.wikipedia.org/wiki/ANSI_escape_code Uses M_framework__msg iso_fortran_env iso_c_binding Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: bg_black = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_blue = CODE_START//BG//BLUE//CODE_END character(len=*), public, parameter :: bg_cyan = CODE_START//BG//CYAN//CODE_END character(len=*), public, parameter :: bg_default = CODE_START//BG//DEFAULT//CODE_END character(len=*), public, parameter :: bg_ebony = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_green = CODE_START//BG//GREEN//CODE_END character(len=*), public, parameter :: bg_magenta = CODE_START//BG//MAGENTA//CODE_END character(len=*), public, parameter :: bg_red = CODE_START//BG//RED//CODE_END character(len=*), public, parameter :: bg_white = CODE_START//BG//WHITE//CODE_END character(len=*), public, parameter :: bg_yellow = CODE_START//BG//YELLOW//CODE_END character(len=*), public, parameter :: bold = CODE_START//ON//AT_BOLD//CODE_END character(len=*), public, parameter :: clear = HOME_DISPLAY//CLEAR_DISPLAY character(len=*), public, parameter :: fg_black = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_blue = CODE_START//FG//BLUE//CODE_END character(len=*), public, parameter :: fg_cyan = CODE_START//FG//CYAN//CODE_END character(len=*), public, parameter :: fg_default = CODE_START//FG//DEFAULT//CODE_END character(len=*), public, parameter :: fg_ebony = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_green = CODE_START//FG//GREEN//CODE_END character(len=*), public, parameter :: fg_magenta = CODE_START//FG//MAGENTA//CODE_END character(len=*), public, parameter :: fg_red = CODE_START//FG//RED//CODE_END character(len=*), public, parameter :: fg_white = CODE_START//FG//WHITE//CODE_END character(len=*), public, parameter :: fg_yellow = CODE_START//FG//YELLOW//CODE_END character(len=*), public, parameter :: inverse = CODE_START//ON//AT_INVERSE//CODE_END character(len=*), public, parameter :: italic = CODE_START//ON//AT_ITALIC//CODE_END character(len=*), public, parameter :: reset = CODE_RESET character(len=*), public, parameter :: unbold = CODE_START//'22'//CODE_END character(len=*), public, parameter :: underline = CODE_START//ON//AT_UNDERLINE//CODE_END character(len=*), public, parameter :: uninverse = CODE_START//OFF//AT_INVERSE//CODE_END character(len=*), public, parameter :: unitalic = CODE_START//OFF//AT_ITALIC//CODE_END character(len=*), public, parameter :: ununderline = CODE_START//OFF//AT_UNDERLINE//CODE_END Interfaces public        interface attr private  function attr_scalar(string, reset) result(expanded) NAME attr ( 3 f ) - [ M_framework__attr ] substitute escape sequences for HTML - like syntax in strings ( LICENSE : MIT ) SYNOPSIS function attr(string,reset) result ( expanded ) ! scalar character ( len = * ), intent ( in ) :: string logical , intent ( in ), optional :: reset character ( len =:), allocatable :: expanded ! or array character ( len = * ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset character ( len =:), allocatable :: expanded (:) integer , intent ( in ), optional :: chars DESCRIPTION Use HTML-like syntax to add attributes to terminal output such as\ncolor on devices that recognize ANSI escape sequences. OPTIONS string        input string  of form\n\n                \" <attribute_name> string </attribute_name> ...\".\n\n               where the current attributes are color names,\n               bold, italic, underline, ...\n\nreset          By default, a sequence to clear all text attributes\n               is sent at the end of each returned line if an escape\n               character appears in the output string. This can be\n               turned off by setting RESET to .false. .\n\n               Note if turning off the reset attributes may be\n               continued across lines, but if each line is not\n               self-contained attributes may not display properly\n               when filtered with commands such as grep(1).\n\nchars          For arrays, a reset will be placed after the Nth\n               displayable column count in order to make it easier\n               to generate consistent right borders for non-default\n               background colors for a text block. KEYWORDS primary default keywords colors: r , red , R , RED g , green , G , GREEN b , blue , B , BLUE m , magenta , M , MAGENTA c , cyan , C , CYAN y , yellow , Y , YELLOW e , ebony , E , EBONY w , white , W , WHITE attributes: it , italic bo , bold un , underline basic control characters: nul bel ( 0 x07 , &#94; G ) beeps ; bs ( 0 x08 , &#94; H ) backspaces one column ( but not past the beginning of the line ); ht ( 0 x09 , &#94; I ) goes to the next tab stop or to the end of the line if there is no earlier tab stop ; lf ( 0 x0A , &#94; J ), vt ( 0 x0B , &#94; K ) ff ( 0 x0C , &#94; L ) all give a linefeed , and if LF / NL ( new - line mode ) is set also a carriage return cr ( 0 x0D , &#94; M ) gives a carriage return ; so ( 0 x0E , &#94; N ) activates the G1 character set ; si ( 0 x0F , &#94; O ) activates the G0 character set ; can ( 0 x18 , &#94; X ) and SUB ( 0 x1A , &#94; Z ) interrupt escape sequences ; sub esc ( 0 x1B , &#94; [) starts an escape sequence ; del ( 0 x7F ) is ignored ; other: clear default reset gt lt save , DECSC Save current state ( cursor coordinates , attributes , character sets pointed at by G0 , G1 ). restore , DECRC Restore state most recently saved by ESC 7. CSI \"Control Sequence Introducer\" ( 0 x9B ) is equivalent to \"ESC [\" . dual - value ( one for color , one for mono ) : write ( * , * ) attr (' < ERROR > an error message ') write ( * , * ) attr (' < WARNING > a warning message ') write ( * , * ) attr (' < INFO > an informational message ') By default , if the color mnemonics ( ie . the keywords ) are uppercase they change the background color . If lowercase , the foreground color . When preceded by a \"/\" character the attribute is returned to the default . The \"default\" keyword is typically used explicitly when reset = . false , and sets all text attributes to their initial defaults . LIMITATIONS o colors are not nestable , keywords are case - sensitive , o not all terminals obey the sequences . On Windows , it is best if you use Windows 10 + and / or the Linux mode ; although it has worked with all CygWin and MinGW and Putty windows and mintty . o you should use \" <gt> \" and \" <lt> \" instead of \" > \" and \" < \" in a string processed by attr ( 3 f ) instead of in any plain text output so that the raw mode will create correct input for the attr ( 3 f ) function if read back in . EXAMPLES Sample program\n\n program demo_attr\n use M_framework__attr, only : attr, attr_mode, attr_update\n    call printstuff('defaults')\n\n    call attr_mode(manner='plain')\n    call printstuff('plain:')\n\n    call printstuff('raw')\n\n    call attr_mode(manner='color')\n    call printstuff('')\n\n    write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:')\n    call attr_update('blink',char(27)//'[5m')\n    call attr_update('/blink',char(27)//'[25m')\n    write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n\n contains\n subroutine printstuff(label)\n character(len=*),intent(in)  :: label\n character(len=:),allocatable :: array(:)\n   call attr_mode(manner=label)\n\n   array=[character(len=60) :: & 'TEST MANNER='//label, & ' <r> RED </r> , <g> GREEN </g> , <b> BLUE </b> ', & ' <c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y> ', & ' <w> WHITE </w> and <e> EBONY </e> ']\n   write(*,'(a)') attr(array)\n\n   write(*,'(a)') attr('Adding <bo> bold </bo> ')\n   write(*,'(a)') attr(' <bo><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></bo> ')\n   write(*,'(a)') attr(' <bo><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y></bo> ')\n   write(*,'(a)') attr(' <bo><w> WHITE </w> and <e> EBONY </e></bo> ')\n\n   write(*,'(a)') attr('Adding <ul> underline </ul> ')\n   write(*,'(a)') attr( & & ' <bo><ul><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></ul></bo> ')\n   write(*,'(a)') attr( & & ' <bo><ul><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </y></ul></bo> ')\n   write(*,'(a)') attr(' <bo><ul><w> WHITE </w> and <e> EBONY </e></ul></bo> ')\n\n   write(*,'(a)') attr('Adding <ul> italic </ul> ')\n   write(*,'(a)') attr( & & ' <bo><ul><it><r> RED </r> , <g> GREEN </g> , <b> BLUE </b></it></ul></bo> ')\n   write(*,'(a)') attr( & & ' <bo><ul><it><c> CYAN </c> , <m> MAGENTA </g> , <y> YELLOW </it></y></ul></bo> ')\n   write(*,'(a)') attr(' <bo><ul><it><w> WHITE </w> and <e> EBONY </e></ul></bo> ')\n\n   write(*,'(a)') attr('Adding <in> inverse </in> ')\n   write(*,'(a)') attr(' <in><bo><ul><it><r> RED </r> , <g> GREEN </g> , & & <b> BLUE </b></it></ul></bo></in> ')\n   write(*,'(a)') attr(' <in><bo><ul><it><c> CYAN </c> , <m> MAGENTA </g> , & & <y> YELLOW </it></y></ul></bo></in> ')\n   write(*,'(a)') attr( & & ' <in><bo><ul><it><w> WHITE </w> and <e> EBONY </e></ul></bo></in> ')\n end subroutine printstuff\n end program demo_attr AUTHOR John S. Urban, 2021 LICENSE MIT SEE ALSO attr_mode(3f), attr_update(3f) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:), allocatable private  function attr_matrix(strings, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:), allocatable, (:) private  function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:), allocatable Subroutines public  subroutine attr_mode (manner) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner public  subroutine attr_update (key, valin, mono_valin) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin","tags":"","url":"module/m_framework__attr.html"},{"title":"M_framework__approx – M_framework","text":"Uses iso_fortran_env Interfaces public        interface compare_float private elemental function compare_float_real32(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical private elemental function compare_float_real64(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical private elemental function compare_float_real128(x, y, ulp) result(compare) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y class(*), intent(in), optional :: ulp Return Value logical public        interface dp_accdig public impure elemental subroutine accdig (x, y, digi0, acurcy, ind) NAME accdig ( 3 f ) - [ M_framework__approx ] compare two numbers only up to a specified number of digits ( LICENSE : PD ) SYNOPSIS elemental impure subroutine accdig(x,y,digio,acurcy,ind)\n\n    class(*),intent(in)  :: X\n    class(*),intent(in)  :: Y\n    class(*),intent(in)  :: DIGI0\n    real,intent(out)     :: acurcy\n    integer,intent(out)  :: ind DESCRIPTION This procedure is used to check how closely two numbers agree . call accdig ( X , Y , DIGI0 , ACURCY , IND ) The values X and Y are the numbers to compare , and DIGI0 is the threshold number of digits to consider significant in returning IND . If X and Y are considered equal within DIGI0 relative tolerance , IND = 0 , if tolerance is satisfied . = 1 , if tolerance is not satisfied . The result ACURCY gives a measure of the number of leading digits in X which are the same as the number of leading digits in Y . ACURCY =- log10 (( X - Y ) / Y ) if X != Y and Y != 0 ACURCY =- log10 ( X - Y ) if X != Y and Y = 0 ACURCY = 8 if X = Y ACURCY is never less than - 8 or greater than 8 for 32 - bit REAL values TOLERANCE ... X and Y are considered equal within DIGI0 relative tolerance , if ACURCY is greater than DIGI0 . For example , Take some numbers and compare them to 1 . 2345678 ... > ================================================ > A number | ACURCY | ACURCY > | 1 . 2345678 = Y | 1 . 2345678 = X > ================================================ > 1 . 234680 | 3 . 7900571 | 3 . 7901275 > 1 . 2345378 | 4 . 6144510 | 4 . 6144404 > 2 . 2234568 | 0 . 096367393 | 0 . 35188114 > 1 . 2345678 | 8 . 0000000 | 8 . 0000000 > 1 . 2345679 | 7 . 0732967 | 7 . 0731968 > - 1 . 2345678 | - 0 . 30103000 | - 0 . 30103000 > 76 . 234567 | - 1 . 7835463 | 0 . 0070906729 > 2 . 4691356 | 0 . 0 | 0 . 3010300 > 0 . 0 | 0 . 0 | - 0 . 91514942 . Due to the typical limits of the log function , the number of significant digits in the result is best considered to be three . Notice that 1 . 2345678 = Y produces different values than 1 . 2345678 = X A negative result indicates the two values being compared either do not agree in the first digit or they differ with respect to sign . An example of two numbers which do not agree in their leading digit ( and actually differ in order of magnitude ) is given above by X = 76 . 234567 and Y = 1 . 2345678 ; the accuracy reported is -1.7835463. An example of two numbers which do not agree in sign in X =- 1 . 2345678 and Y = 1 . 2345678 ; here the accuracy reported is - 0 . 30103000 . EXAMPLES Example program: program demo_accdig ! fortran 90 example use M_framework__approx , only : accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1 . 234680 d0 , 1 . 2345378 d0 , 2 . 2234568 d0 , 1 . 2345678 d0 , & & 1 . 2345679 d0 , - 1 . 2345678 d0 , 76 . 234567 d0 , 2 . 4691356 d0 , & & 0 . 0 d0 / write ( * , * ) ' ========================= ' do i10 = 0 , 16 a = 1 . 0 d0 b = a + 1 . 0 d0 / ( 10 . 0 d0 ** i10 ) call accdig ( a , b , 8 . 0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' digi = 16 do i20 = 0 , digi a = 1 . 0 d0 b = a + 1 . 0 d0 / ( 10 . 0 d0 ** i20 ) call accdig ( a , b , dble ( digi ) , acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) ' ========================= ' do i30 = 1 , 9 call accdig ( 1 . 2345678 d0 , vals ( i30 ) , 8 . 0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ) , 1 . 2345678 d0 , 8 . 0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ) , acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig NOTES REFERENCES based on … NBS OMNITAB 1980 VERSION 6 . 01 1 / 1 / 81 . dp_accdig V 7 . 00 2 / 14 / 90 . ** David Hogben , Statistical Engineering Division , Center for Computing and Applied Mathematics , A337 Administration Building , National Institute of Standards and Technology , Gaithersburg , MD 20899 TELEPHONE 301 - 975 - 2845 ORIGINAL VERSION - October , 1969 . CURRENT VERSION - February , 1990 . JSU VERSION - February , 1991 . DEPENDENCIES o M_framework__journal(), log10(), abs(1) AUTHORS David Hogben, John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind public        interface operator (.equalto.) private elemental function is_equal_to_real32(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_equal_to_real64(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_equal_to_real128(x, y) result(equal_to) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical public        interface operator (.greaterthan.) private elemental function is_greater_than_real32(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_greater_than_real64(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_greater_than_real128(x, y) result(greater_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical public        interface operator (.lessthan.) private elemental function is_less_than_real32(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_less_than_real64(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical private elemental function is_less_than_real128(x, y) result(less_than) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value logical public        interface significant private pure elemental function significant_real32(val, digits, round) result(significant) NAME significant(3f) - [M_framework__approx] round val to specified number\n   of significant digits SYNOPSIS pure elemental function significant(val,digits,round)\n\n  real,intent(in)                      :: val\n  integer,intent(in)                   :: digits\n  character(len=*),intent(in),optional :: round\n  real                                 :: significant DESCRIPTION Round real value to specified number of significant digits OPTIONS val     value to round\n digits  number of significant digits to produce\n round   Use the round edit descriptor RU UP : the value resulting from conversion shall be the smallest representable value that is greater than or equal to the original value RD DOWN : the value resulting from conversion shall be the largest representable value that is less than or equal to the original value RZ ZERO : the value resulting from conversion shall be the value closest to the original value and no greater in magnitude than the original value . RN NEAREST : modeis NEAREST , thevalueresulting from conversion shall be the closer of the two nearest representable values if one is closer than the other . If the two nearest representable values are equidistant from the original value , it is processor dependent which one of them is chosen . RC COMPATIBLE : the value resulting from conversion shall be the closer of the two nearest representable values or the value away from zero if halfway between them . RP PROCESSOR_DEFINED : rounding during conversion shall be a processor - dependent default mode , which may correspond to one of the other modes . EXAMPLES Sample program program demo_significant use M_framework__approx , only : significant implicit none character ( len =* ) , parameter :: g = ' (*(g0.7,1x)) ' write ( * , g ) significant ( [ 8765 . 43210 , 0 . 1234567890 ], 5 ) write ( * , * ) ' default: ' , 1 . 23456789012345 write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RU ' ) , ' RU ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RD ' ) , ' RD ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RZ ' ) , ' RZ ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RN ' ) , ' RN ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RC ' ) , ' RC ' write ( * , g ) significant ( 1 . 23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RP ' ) , ' RP ' end program demo_significant Results: > 8765.400 .1234600\n   >  default:   1.234568\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568\n   > 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RU\n   > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...\n   > 1.234567 1.234568 1.234568 RD\n   > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...\n   > 1.234567 1.234568 1.234568 RZ\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RN\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RC\n   > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...\n   > 1.234568 1.234568 1.234568 RP Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real(kind=wp) private pure elemental function significant_real64(val, digits, round) result(significant) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real(kind=wp) Functions public impure elemental function almost (x, y, digits, verbose) sample: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digits logical, intent(in), optional :: verbose Return Value logical public impure elemental function in_margin (expected_value, measured_value, allowed_margin) in_margin(3f) - [M_framework__approx] check if two reals are\n   approximately equal using a relative margin Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: expected_value class(*), intent(in) :: measured_value class(*), intent(in) :: allowed_margin Return Value logical public  function round (val, idigits0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val integer, intent(in) :: idigits0 Return Value real(kind=dp) public pure elemental function round_to_power (val, n) Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: n Return Value real Subroutines public impure elemental subroutine accdig (x, y, digi0, acurcy, ind) Example program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind public  subroutine change_default_ulp (ulp) Additional operators based on compare_float(3f) are included: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: ulp public  subroutine sp_accdig (x, y, digi0, acurcy, ind) Example program: Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind","tags":"","url":"module/m_framework__approx.html"},{"title":"M_framework – M_framework","text":"Uses M_framework__approx M_framework__timing M_framework__journal M_framework__msg M_framework__verify M_framework__utility","tags":"","url":"module/m_framework.html"},{"title":"M_framework__journal – M_framework","text":"NAME M_framework__journal(3fm) - [M_framework__journal::INTRO] write\n program messages to stdout and/or\n a log file\n (LICENSE:PD) SYNOPSIS use, M_framework__journal , only : journal DESCRIPTION For large interactive programs in particular it is useful if all messages go thru a JOURNAL ( 3 f ) call . This makes it easy to write messages to a log file as well as standard output ; to toggle time prefixes on and off ; to turn on and off debug - mode messages ; control output paging and create replayable input journals . The primary use of JOURNAL ( 3 f ) is to create journal files for interactive programs that + provide various levels of verbosity on demand , often for debugging purposes . + can be replayed even when interactive input was provided + and / or be used to verify program executions Typically , you would echo what the user typed to the trail file as - is , and write output you write to stdout as comments to the trail file so that the trail file can easily be read back in ( by ignoring comments ) . Even though there is essentially one procedure ( journal ( 3 f ) calls that are more than just a single message have an action specified as the first parameter . This action might specify to open a log file , to change the \"level\" required by messages for them to appear , whether output it written as a comment or not , and on what files the output should appear . So the interface can be used in a very simple manner but has more options than is evident at first glance , as detailed in the man - page for journal ( 3 f ) . to stdout is written with WHERE = 'SC' in the JOURNAL ( 3 f ) call . > : > : > call journal ( 'O' , 'my_trail_file' ) ! open trail file > ! write output to stdout as - is and as comment to trail file > call journal ( output ) > ! echo message to trail / log file only > call journal ( 'T' , userline ) > ! write to stdout as - is and trail as a comment . > ! up to twenty scalar values of any intrinsic type are allowed > call journal ( 'SC' , 'i1=' , i1 , 'i2=' , i2 , 'i3=' , i3 ) > ! for more complex messages you can build them with non - advancing > ! I / O journal calls , or build the message with internal writes > ! into a string and print that . I = 10 R = 20.3 ! write to stdout and trail file without advancing I / O call journal ( '+SC' , 'I=' , i ) ! write to stdout and trail file without advancing I / O call journal ( 'SC' , 'AND R=' , r ) writes to the trail file ( s ) are ignored unless a trail file was opened , but output continues to stdout by default . That is , destinations 'T' and 'C' are ignored unless a trail file has been requested , allowing journal to be used with programs that do not generate trails or journals . Note that with no parameters , the trail file is flushed . EXAMPLES The man - page for journal ( 3 f ) describes all the options for the action field WHERE . In addition to being used to generate a journal , the routine can be used for producing optional debug messages and timing information . Sample program for debug messages : program demo_journal !! showing creating debug messages use M_framework__journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , '*demo* DEBUG MESSAGE 001 IGNORED' ) !! turn on debug messages call journal ( '>' , 'debug on' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 002 ON STDOUT' ) !! open trail file call journal ( 'O' , 'mytrail.txt' ) !! debug messages now go to the trail file only call journal ( 'D' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! or always to stdout and trail file only if on call journal ( 'DS' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! close trail file so messages go only to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , '*demo* DEBUG MESSAGE 004 TO STDOUT' ) !! turn off debug messages call journal ( '<' , 'debug off' ) !! back to no output from the next message call journal ( 'D' , '*demo* DEBUG MESSAGE 005 IGNORED' ) end program demo_journal Sample program for trail messages with optional timing information: program testit use M_framework__journal , only : journal implicit none call journal ( 'a single string A -should be on S' ) ! add time prefix to output call journal ( '%' , '%Y-%M-%DT%h:%m:%s.%x%u:%b' ) ! call journal ( 'a single string B -should be on S with prefix' ) ! change to CPU time and number of calls prefix call journal ( '%' , 'CPU_TIME: %c:CALLS: %C: %b' ) ! call journal ( 'a single string B-1 -should be on S with prefix' ) call journal ( 'a single string B-2 -should be on S with prefix' ) call journal ( 'a single string B-3 -should be on S with prefix' ) ! Other useful time formats : ! % E -- Unix Epoch time ! % e -- integer value of Unix Epoch time ! % C -- number of times this format is used ! % c -- CPU_time ( 3 f ) output ! % S -- seconds since last use of this format ! % k -- CPU time in seconds from system_clock call journal ( '%' , '' ) ! turn off time prefix ! call journal ( 'a single string C -should be on S' ) ! call journal ( 'O' , 'aaa.out' ) ! turn on trail file call journal ( 'a single string D -should be on SC' ) call journal ( 'a single string E -should be on SC' ) call journal ( 'a single string F -should be on SC' ) call journal ( 'O' , '' ) ! turn off trail file ! call journal ( 'a single string G -should be on S' ) call journal ( 'a single string H -should be on S' ) call journal ( 'a single string I -should be on S' ) ! build one line of output with intrinsic scalar values added call journal ( '+sc' , 'APPEND:' ) call journal ( '+sc' , ' integer' , 1234 ) call journal ( '+sc' , ' and real' , 1234.5678 ) call journal ( '+sc' , ' and double' , 1234567890.123456 d0 ) call journal ( '+sc' , ' and logical' , . true .) call journal ( 'sc' , '' ) ! end program testit AUTHOR John S. Urban LICENSE Public Domain NAME journal ( 3 f ) - [ M_framework__journal ] provides public message routine , no paging or graphic mode change ( LICENSE : PD ) SYNOPSIS subroutine journal([where,],[VALUE(s)])\n\n character(len=*),intent(in) :: where\n class(*),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj WRITE MESSAGES\n    basic messages call journal ( where ,[ VALUE ( S ) ] ) call journal ( message ) # a shortcut for \" call journal('sc',message) \" : OPEN OR CLOSE TRAIL FILE\n    trail file call journal('O',trailfile_name) # open trail file\n   call journal('O','')             # close trail file SET OUTPUT TIME PREFIX\n    set the function display format for timestamps. See the NOW(3f)\n    procedure for allowable timestamp macros call journal('%',time_stamp_prefix_specification) MODES Turn on/off writing DEBUG messages to trail file\n\n   call journal('>','debug on') # turn on debug mode\n   call journal('<','debug off') # turn off debug mode ASSIGN STDOUT TO AN ALTERNATE FILE\n    change stdout to iunit and open filename; or close unit and go back to stdout if filename=’‘ call journal(iunit,filename)\n\nchange stdout to iunit to use a file already open\n\n   call journal(iunit) DESCRIPTION If a user procedure is used for outputting messages instead of calling WRITE ( 3 f ) it is easy to provide control of when messages are printed ( ie . a \" verbose \" mode , or \" quite \" mode ) , creating files to replay program execution , duplicating output , ... OPTIONS WHERE  indicates where messages are written. A combination of the\n          following characters can be used… Usually one of these to write to the standard output files ... S write to stdout or iounit set with journal ( unit ) or journal ( unit , filename ) . E write to stderr And one of these to write to trail file ( ignore if no trail file defined ) ... C write to trail file as a comment ( if file is open ) Writing output \" as a comment \" means it is preceded by a pound ( # ) character . T write to trail file ( if file is open ) Usually used by itself D write to trail file as a comment with \" DEBUG: \" prefix in front of message ( if file is open ) if debug mode is on . Write to stdout if no trail file and debug mode is on . Modifier for S | E | C | T | D specifiers + subsequent files are written to with advance = ' no ' . Position is important . ' +sc ' does an advance = ' no ' on both files , ' s+c ' only does the advance = ' no ' for the trail file . Mode changing options used by themselves : > turn off debug messages < turn on debug messages O open trail file using value of \" message \" parameter or close trail file if no filename or a blank filename . A Auxiliary programs that also want to write to the current log file ( a2b , z2a , ... ) call this routine to see if there is a trail file being generated and then add to it so that a program like ush ( 1 f ) can call the auxiliary programs and still just generate one log file , but if the auxiliary program is used as a stand - alone program no trail is generated . VALUES(S)   message to write to stdout, stderr, and the trail file.\n               a numeric or character value to optionally be appended\n               to the message. Up to twenty values are allowed. The WHERE\n               field is required if there is anything other than a single\n               character string or not values at all.\n   FILENAME    when WHERE=”O” to turn the trail file on or off, the “message”\n               field becomes the trail filename to open. If blank, writing\n               to the trail file is turned off.\n   TIMEFORMAT  when WHERE=”%” the message is treated as a time format\n               specification as described under now(3f). EXAMPLES Sample program: program demo_journal use M_framework__journal , only : journal !! BASIC USAGE call journal ( & & ' write to standard output as-is, and trail file as a comment if open ' ) ! since trail file is not yet open , only stdout will display output call journal ( ' c ' , ' ignored, as trail file is not open ' ) ! now open trail file \" trail \" call journal ( ' o ' , ' trail ' ) call journal ( ' sc ' , ' same thing except now trail file is open ' ) ! only write to trail file if open call journal ( ' c ' , & & ' not ignored, as trail file is open. Written with # suffix ' ) call journal ( ' t ' , & & ' not ignored, as trail file is open. Written as-is ' ) ! turn off trail file call journal ( ' o ' , '' ) end program demo_journal Adding intrinsic scalar values to the message: program test_journal use M_framework__journal , only : journal implicit none call journal ( ' S ' , ' This is a test with no optional value ' ) call journal ( ' S ' , ' This is a test with a logical value ' ,. true . ) call journal ( ' S ' , & & ' This is a test with a double value ' , 1234567890 . 123456789 d0 ) call journal ( ' S ' , & & ' This is a test with a real value ' , 1234567890 . 123456789 ) call journal ( ' S ' , ' This is a test with an integer value ' , 1234567890 ) call journal ( ' STDC ' , ' This is a test using STDC ' , 1234567890 ) call journal ( ' stdc ' , ' This is a test using stdc ' , 1234567890 ) call journal ( ' o ' , ' journal.txt ' ) ! open trail file call journal ( ' S ' , & & 1 , 12 . 34 , 56789 . 111111111 d0 ,. false ., ' a bunch of values ' ) ! the combinations that make sense call journal ( ' st ' , ' stdout and trail ' ) call journal ( ' s ' , ' stdout only ' ) call journal ( ' t ' , ' trail only ' ) call journal ( ' sc ' , ' stdout and trail_comment ' ) call journal ( ' c ' , ' trail_comment only ' ) call journal ( ' d ' , ' debug only ' ) call journal ( ' e ' , ' stderr only ' ) call journal ( ' o ' , ' ' ) ! closing trail file end program test_journal program testit ! this is a utility program that calls the module routines . It is ! typically built using ccall ( 1 ) . use M_framework__journal , only : journal character ( len = : ) , allocatable :: time_stamp_prefix call journal ( ' s ' , & & ' ------------------------------------------------------------ ' ) call journal ( ' s ' , ' SIMPLE WRITES ' ) call one () call two () call journal ( ' sc ' , & & ' called ONE() and TWO() but did not generate a log file ' ) call journal ( ' s ' , & & ' ------------------------------------------------------------ ' ) call journal ( ' s ' , ' SIMPLE WRITES WITH LOG FILE ' ) call journal ( ' o ' , ' journal.txt ' ) ! open trail file call one () call two () call journal ( ' sc ' , & & ' called ONE() and TWO() and generated log file journal.txt ' ) call journal ( '' , ' journal.txt ' ) ! close trail file call journal ( ' s ' , & & ' ------------------------------------------------------------ ' ) call journal ( ' s ' , ' SIMPLE WRITES WITH TIMING INFORMATION ' ) ! change time prefix time_stamp_prefix = ' CPU_TIME=%c:CALLS=%C:SINCE=%S:%b ' call journal ( ' % ' , time_stamp_prefix ) ! set a message time prefix call journal ( ' o ' , ' timed.txt ' ) ! open trail file call one () call two () call journal ( ' sc ' , & & ' called ONE() and TWO() and generate log file timed.txt ' ) call journal ( '' , ' timed.txt ' ) ! close trail file call journal ( ' % ' , '' ) ! turn off time prefix call journal ( ' o ' , ' timed.txt ' ) ! open trail file call journal ( ' s ' , & & ' ------------------------------------------------------------ ' ) contains subroutine two () call journal ( ' Entered subroutine two ' ) call journal ( ' Exited subroutine two ' ) end subroutine two subroutine one () call journal ( ' Entered subroutine one ' ) sum =- HUGE ( 1 . 0 ) do i = 1 , 10000000 sum = sum + sqrt ( real ( i )) enddo write ( * , * ) ' SUM= ' , sum call journal ( ' Exited subroutine one ' ) end subroutine one end program testit AUTHOR John S. Urban LICENSE Public Domain Uses M_framework__msg iso_fortran_env Interfaces public        interface journal private  subroutine flush_trail() Arguments None private  subroutine write_message_only(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message private  subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep) NAME where_write_message_all ( 3 f ) - [ M_framework__journal ] converts any standard scalar type to a string and calls journal ( 3 f ) ( LICENSE : PD ) SYNOPSIS subroutine where_write_message_all(where,g0,g1,g2,..,gj,sep) character(len=*),intent(in)   :: where\n class(*),intent(in)           :: g0\n class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9\n class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj\n character,intent(in),optional :: sep DESCRIPTION where_write_message_all(3f) builds and writes a space-separated string\nfrom up to twenty scalar values. OPTIONS where       string designating where to write message, as with journal(3f)\ng0          value to print. May\n            be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,\n            or CHARACTER.\ng[1-9a-j]   optional additional values to print the value of after g0.\nsep         separator to add between values. Default is a space. Should\n            always be called with a keyword, as in \"sep=VALUE\". RETURNS where_write_message_all  description to print EXAMPLES Sample program: program demo_wm_all use M_framework__journal , only : where_write_message_all implicit none end program program demo_wm_all AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: where class(*), intent(in) :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj character(len=1), intent(in), optional :: sep private  subroutine set_stdout_lun(iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit","tags":"","url":"module/m_framework__journal.html"},{"title":"M_framework__msg – M_framework","text":"public :: a,i,f,g Uses iso_fortran_env Interfaces public        interface set private  subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(out), optional :: generic1 class(*), intent(out), optional :: generic2 class(*), intent(out), optional :: generic3 class(*), intent(out), optional :: generic4 class(*), intent(out), optional :: generic5 class(*), intent(out), optional :: generic6 class(*), intent(out), optional :: generic7 class(*), intent(out), optional :: generic8 class(*), intent(out), optional :: generic9 class(*), intent(out), optional :: generica class(*), intent(out), optional :: genericb class(*), intent(out), optional :: genericc class(*), intent(out), optional :: genericd class(*), intent(out), optional :: generice class(*), intent(out), optional :: genericf class(*), intent(out), optional :: genericg class(*), intent(out), optional :: generich class(*), intent(out), optional :: generici class(*), intent(out), optional :: genericj class(*), intent(out), optional :: generick private  subroutine set_single(generic0, generic1) NAME set ( 3 f ) - [ M_msg ] set scalars from an array ( LICENSE : PD ) SYNOPSIS Syntax : function set ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, & & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk ) class (*), intent ( in ) :: g0 class (*), intent ( out ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga class (*), intent ( out ), optional :: gb , gc , gd , ge , gf , gg , gh , gi , gj , gk DESCRIPTION set(3f) sets up to twenty scalars to elements from an array. OPTIONS g0(:)       array to read values from. Can be of type INTEGER or REAL\ng[1-9a-k]   optional values to set to an array element. Can\n            be of type INTEGER or REAL EXAMPLES Sample program: program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_framework__msg , only : set implicit none real ( kind = real32 ) :: a ; namelist /all/a real ( kind = real64 ) :: b ; namelist /all/b real ( kind = real128 ) :: c ; namelist /all/c integer ( kind = int8 ) :: i ; namelist /all/i integer ( kind = int16 ) :: j ; namelist /all/j integer ( kind = int32 ) :: k ; namelist /all/k integer ( kind = int64 ) :: l ; namelist /all/l call set ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set Results: &ALL\n A       =   1.000000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                     7\n /\n &ALL\n A       =   10.00000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                   100\n / AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 class(*), intent(out) :: generic1 public        interface str private pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, force_kwargs, sep, if) NAME str ( 3 f ) - [ M_framework__msg ] converts up to twenty standard scalar type values to a string ( LICENSE : PD ) SYNOPSIS Syntax : pure function str ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if ) class (*), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class (*), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj logical , intent ( in ), optional :: if character ( len =*), intent ( in ), optional :: sep character , len =(:), allocatable :: str DESCRIPTION str(3f) builds a space-separated string from up to twenty scalar values. OPTIONS g [ 0 - 9 a - j ] Optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . Optionally , all the generic values can be single - dimensioned arrays . Currently , mixing scalar arguments and array arguments is not supported . sep separator string used between values . Defaults to a space . Must be specified with a keyword . if If false return a null string . Must be specified with a keyword . RETURNS str     description to print EXAMPLES Sample program: program demo_str use M_framework__msg , only : str implicit none character ( len = : ) , allocatable :: pr character ( len = : ) , allocatable :: frmt integer :: biggest pr = str ( ' HUGE(3f) integers ' , huge ( 0 ) , & & ' and real ' , huge ( 0 . 0 ) , ' and double ' , huge ( 0 . 0 d0 )) write ( * , ' (a) ' ) pr pr = str ( ' real            : ' , huge ( 0 . 0 ) , 0 . 0 , 12345 . 6789 , tiny ( 0 . 0 ) ) write ( * , ' (a) ' ) pr pr = str ( ' doubleprecision : ' , huge ( 0 . 0 d0 ) , 0 . 0 d0 , 12345 . 6789 d0 , tiny ( 0 . 0 d0 ) ) write ( * , ' (a) ' ) pr pr = str ( ' complex         : ' , cmplx ( huge ( 0 . 0 ) , tiny ( 0 . 0 )) ) write ( * , ' (a) ' ) pr ! create a format on the fly biggest = huge ( 0 ) ! + 0 for gfortran - 11 bug frmt = str ( ' (*(i ' , int ( log10 ( real ( biggest ))) + 0 , ' :,1x)) ' , sep = '' ) write ( * , * ) ' format= ' , frmt ! although it will often work , using str ( 3 f ) ! in an I / O statement is not recommended ! because if an error occurs str ( 3 f ) will try ! to write while part of an I / O statement ! which not all compilers can handle and is currently non - standard write ( * , * ) str ( ' program will now stop ' ) end program demo_str Output HUGE(3f) integers 2147483647 and real 3.40282347E+38 ...\nand double 1.7976931348623157E+308\nreal            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38\ndoubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...\n12345.678900000001 2.2250738585072014E-308\ncomplex         : (3.40282347E+38,1.17549435E-38)\n format=(*(i9:,1x))\n program will now stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic0 class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 class(*), intent(in), optional :: generica class(*), intent(in), optional :: genericb class(*), intent(in), optional :: genericc class(*), intent(in), optional :: genericd class(*), intent(in), optional :: generice class(*), intent(in), optional :: genericf class(*), intent(in), optional :: genericg class(*), intent(in), optional :: generich class(*), intent(in), optional :: generici class(*), intent(in), optional :: genericj type(force_kwargs_hack), intent(in), optional :: force_kwargs character(len=*), intent(in), optional :: sep logical, intent(in), optional :: if Return Value character(len=:), allocatable private pure function msg_one(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, force_kwargs, sep, if) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(in), optional :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) class(*), intent(in), optional :: generica (:) class(*), intent(in), optional :: genericb (:) class(*), intent(in), optional :: genericc (:) class(*), intent(in), optional :: genericd (:) class(*), intent(in), optional :: generice (:) class(*), intent(in), optional :: genericf (:) class(*), intent(in), optional :: genericg (:) class(*), intent(in), optional :: generich (:) class(*), intent(in), optional :: generici (:) class(*), intent(in), optional :: genericj (:) type(force_kwargs_hack), intent(in), optional :: force_kwargs character(len=*), intent(in), optional :: sep logical, intent(in), optional :: if Return Value character(len=:), allocatable Functions public recursive function fmt (generic, format) result(line) Sample program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Subroutines public  subroutine assert (filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: linen logical, intent(in) :: expr class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj public  subroutine pdec (string) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public  subroutine stderr (g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) Sample program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj public  subroutine wrt (luns, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: luns (:) class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj integer, intent(out), optional :: iostat","tags":"","url":"module/m_framework__msg.html"},{"title":"demo_M_framework__verify – M_framework","text":"Uses M_framework M_framework__verify_demo Subroutines subroutine test_one () Arguments None subroutine test_two () Arguments None Source Code program demo_M_framework__verify use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_msg , unit_test_stop , & & unit_test_system , unit_test_mode use M_framework__verify_demo , only : one , two ! set-up call unit_test_mode ( command = '' , flags = [ 0 ], keep_going = . true .) ! call a test procedure for each routine to test call test_one () call test_two () ! tear-down call unit_test_stop () contains subroutine test_one () integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 21 , 51 , 14 , 45 ] call unit_test_start ( 'one' ) call one ( results ) call unit_test ( 'one' , all ( expected > 0 ), & & 'testing if everyone greater than zero' ) call unit_test ( 'one' , all ( expected == results ), & & 'testing if all values are expected' ) call unit_test_end ( 'one' , 'checks on \"one\" ended' ) end subroutine test_one subroutine test_two integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 2 , 20 , 200 ] results = [ 1 , 10 , 100 ] call two ( results ) call unit_test_start ( 'two' , 'check procedure \"two\" ' ) call unit_test ( 'two' , all ( expected == results ) . and . & & all ( expected > 0 ) . and . maxval ( expected ) < 201 , msg = 'long expression' ) call unit_test_end ( 'two' , 'checks on \"two\" ended' ) end subroutine test_two end program demo_M_framework__verify","tags":"","url":"program/demo_m_framework__verify.html"},{"title":"demo_fstop – M_framework","text":"Uses M_framework__utility Variables Type Attributes Name Initial integer :: int !write( , )’Enter stop value’\n!read( , ) int Source Code program demo_fstop use M_framework__utility , only : fstop implicit none integer :: int !*!write(*,*)'Enter stop value' !*!read(*,*) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = 'error: program will now stop' ) case ( 25 ) ; call fstop ( int , stdout = 'stdout message' , & & stderr = 'stderr message' ) case ( 30 ) ; call fstop ( int , stdout = 'error: program will now stop' ) case default call fstop ( int ) endselect end program demo_fstop","tags":"","url":"program/demo_fstop.html"},{"title":"test_id – M_framework","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer :: break character(len=*), parameter :: nl = new_line('a') character(len=:), allocatable :: options integer :: start character(len=:), allocatable :: version integer :: where Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"program/test_id.html"},{"title":"runtest – M_framework","text":"Uses M_framework__verify Subroutines subroutine test_unit_test () Arguments None subroutine test_unit_test_bad () Arguments None subroutine test_unit_test_end () Arguments None subroutine test_unit_test_good () Arguments None subroutine test_unit_test_start () Arguments None subroutine test_unit_test_stop () Arguments None Source Code program runtest use M_framework__verify , only : unit_test , unit_test_bad , unit_test_end , unit_test_good , unit_test_start , unit_test_stop call test_unit_test_start () call test_unit_test () call test_unit_test_end () call test_unit_test_bad () call test_unit_test_good () call test_unit_test_stop () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_start () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_unit_test_start !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test () call unit_test_start ( 'unit_test' , msg = '' ) !      call unit_test('unit_test', .true.,'expression is true') !      call unit_test('unit_test', .false.,'expression is false') call unit_test_end ( 'unit_test' , msg = '' ) end subroutine test_unit_test !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_end () call unit_test_start ( 'unit_test_end' , msg = '' ) !      call unit_test('unit_test_end', .true.,'expression is true') !      call unit_test('unit_test_end', .false.,'expression is false') call unit_test_end ( 'unit_test_end' , msg = '' ) end subroutine test_unit_test_end !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_bad () call unit_test_start ( 'unit_test_bad' , msg = '' ) !      call unit_test('unit_test_bad', .true.,'expression is true') !      call unit_test('unit_test_bad', .false.,'expression is false') call unit_test_end ( 'unit_test_bad' , msg = '' ) end subroutine test_unit_test_bad !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_good () call unit_test_start ( 'unit_test_good' , msg = '' ) !      call unit_test('unit_test_good', .true.,'expression is true') !      call unit_test('unit_test_good', .false.,'expression is false') call unit_test_end ( 'unit_test_good' , msg = '' ) end subroutine test_unit_test_good !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_stop () call unit_test_start ( 'unit_test_stop' , msg = '' ) !      call unit_test_stop('unit_test_stop', .true.,'expression is true') !      call unit_test_stop('unit_test_stop', .false.,'expression is false') call unit_test_end ( 'unit_test_stop' , msg = '' ) end subroutine test_unit_test_stop !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest.html"},{"title":"demo_str – M_framework","text":"Uses M_framework__msg Variables Type Attributes Name Initial integer :: biggest character(len=:), allocatable :: frmt character(len=:), allocatable :: pr Source Code program demo_str use M_framework__msg , only : str implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = str ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = str ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = str ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = str ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) ! +0 for gfortran-11 bug frmt = str ( '(*(i' , int ( log10 ( real ( biggest ))) + 0 , ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using str(3f) ! in an I/O statement is not recommended ! because if an error occurs str(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) str ( 'program will now stop' ) end program demo_str","tags":"","url":"program/demo_str.html"},{"title":"demo_M_framework__timing – M_framework","text":"Uses M_framework__timing Variables Type Attributes Name Initial type( timer ) :: clock integer, parameter :: dp = selected_real_kind(15) character(len=*), parameter :: gen = '(*(g0,1x))' integer :: i integer :: j real(kind=dp) :: x (10000) Namelists Namelist vals Variables Name Type Default Description clock type( timer ) None Source Code program demo_M_framework__timing use M_framework__timing implicit none integer , parameter :: dp = selected_real_kind ( 15 ) character ( len =* ), parameter :: gen = '(*(g0,1x))' type ( timer ) :: clock integer :: i , j real ( kind = dp ) :: x ( 10000 ) namelist / vals / clock clock = timer () write ( * , gen ) 'Before calls' write ( * , nml = vals ) write ( * , gen ) 'Initialize:TIC' call clock % tic () write ( * , nml = vals ) do j = 1 , 100000 x (:) = log ( 2 3. ) * [( i , i = 1 , 10000 )] end do write ( * , gen ) ':TOC:' call clock % toc () write ( * , gen ) 'CPU TIME = ' , clock % cputime () write ( * , nml = vals ) write ( * , gen ) 'Now measuring inside the loop...' write ( * , nml = vals ) call clock % tic () do j = 1 , 100000 x (:) = log ( 2 3. ) * [( i , i = 1 , 10000 )] if ( j == 5000 ) then call clock % toc () write ( * , gen ) 'CPU TIME NOW (without pausing) = ' , clock % cputime () write ( * , nml = vals ) endif end do call clock % toc () call clock % print () write ( * , * ) clock write ( * , nml = vals ) end program demo_M_framework__timing","tags":"","url":"program/demo_m_framework__timing.html"},{"title":"demo_journal – M_framework","text":"Uses M_framework__journal showing creating debug messages\nproduces no output because trail is not on\nturn on debug messages\nproduces output on stdout because debug mode\nis on but no named trail file\nopen trail file\ndebug messages now go to the trail file only\nor always to stdout and trail file only if on\nclose trail file so messages go only to stdout again\ndebug on stdout now\nturn off debug messages\nback to no output from the next message Source Code program demo_journal !! showing creating debug messages use M_framework__journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , '*demo* DEBUG MESSAGE 001 IGNORED' ) !! turn on debug messages call journal ( '>' , 'debug on' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 002 ON STDOUT' ) !! open trail file call journal ( 'O' , 'mytrail.txt' ) !! debug messages now go to the trail file only call journal ( 'D' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! or always to stdout and trail file only if on call journal ( 'DS' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! close trail file so messages go only to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , '*demo* DEBUG MESSAGE 004 TO STDOUT' ) !! turn off debug messages call journal ( '<' , 'debug off' ) !! back to no output from the next message call journal ( 'D' , '*demo* DEBUG MESSAGE 005 IGNORED' ) end program demo_journal","tags":"","url":"program/demo_journal.html"},{"title":"runtest – M_framework","text":"Uses M_framework__msg M_framework__approx M_framework__verify M_framework__journal setup\nteardown Subroutines subroutine test_flush_trail () call unit_test(‘flush_trail’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_set_stdout_lun () call unit_test(‘set_stdout_lun’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_where_write_message_all () call unit_test(‘where_write_message_all’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_write_message_only () call unit_test(‘write_message_only’, 0.eq.0, ‘checking’,100) Arguments None Source Code program runtest use M_framework__msg use M_framework__verify use M_framework__journal use M_framework__approx implicit none !! setup call test_flush_trail () call test_set_stdout_lun () call test_where_write_message_all () call test_write_message_only () call unit_test_stop () !! teardown !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_flush_trail () implicit none call unit_test_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_test('flush_trail', 0.eq.0, 'checking',100) call unit_test_end ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_set_stdout_lun () implicit none call unit_test_start ( 'set_stdout_lun' , msg = '' ) !!call unit_test('set_stdout_lun', 0.eq.0, 'checking',100) call unit_test_end ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_where_write_message_all () implicit none call unit_test_start ( 'where_write_message_all' , msg = '' ) !!call unit_test('where_write_message_all', 0.eq.0, 'checking',100) call unit_test_end ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_write_message_only () implicit none call unit_test_start ( 'write_message_only' , msg = '' ) !!call unit_test('write_message_only', 0.eq.0, 'checking',100) call unit_test_end ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest~2.html"},{"title":"demo_almost – M_framework","text":"Uses M_framework__approx Variables Type Attributes Name Initial integer :: i real :: x real :: y logical :: z Source Code program demo_almost use M_framework__approx , only : almost implicit none real :: x , y logical :: z integer :: i x = 1.2345678 y = 1.2300000 do i = 1 , 8 z = almost ( x , y , i , verbose = . true .) write ( * , * ) i , z enddo end program demo_almost","tags":"","url":"program/demo_almost.html"},{"title":"test_compare_float – M_framework","text":"Uses M_framework iso_fortran_env M_framework__approx M_framework__msg M_framework__verify Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. character(len=*), parameter :: dfmt = 'es27.20' real(kind=real64), parameter :: double_number (nums) = [1.234567890123456e-16_real64, 1.234567890123456e-01_real64, 1.234567890123456e+01_real64, 1.234567890123456e+16_real64, 1.0_real64] real(kind=real64), parameter :: dten = 10.0_real64 integer :: i integer, parameter :: nums = 5 character(len=*), parameter :: sfmt = 'es20.13' real(kind=real32), parameter :: single_number (nums) = [1.234567890123456e-16_real32, 1.234567890123456e-01_real32, 1.234567890123456e+01_real32, 1.234567890123456e+16_real32, 1.0_real32] real(kind=real32), parameter :: sten = 10.0_real32 real(kind=real32) :: x real(kind=real64) :: xd real(kind=real32) :: y1 real(kind=real32) :: y2 real(kind=real32) :: y3 real(kind=real32) :: y4 real(kind=real64) :: yd1 real(kind=real64) :: yd2 real(kind=real64) :: yd3 real(kind=real64) :: yd4 Subroutines subroutine test_compare_float_double () Arguments None subroutine test_compare_float_single () Arguments None subroutine test_elemental_double () Arguments None subroutine test_elemental_single () Arguments None subroutine test_equalto_double () Arguments None subroutine test_equalto_single () Arguments None subroutine test_greaterthan_double () Arguments None subroutine test_greaterthan_single () Arguments None subroutine test_lessthan_double () Arguments None subroutine test_lessthan_single () Arguments None Source Code program test_compare_float use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use M_framework use m_framework__verify , only : unit_test_start , unit_test , unit_test_done , unit_test_good , unit_test_bad , unit_test_msg , unit_test_mode use m_framework__verify , only : unit_test_stop , unit_test_level use m_framework__msg , only : str , fmt use m_framework__approx , only : compare_float , operator (. equalto .), operator (. lessthan .), operator (. greaterthan .) implicit none logical , parameter :: T = . true ., F = . false . integer , parameter :: nums = 5 character ( len =* ), parameter :: sfmt = 'es20.13' , dfmt = 'es27.20' real ( kind = real32 ), parameter :: single_number ( nums ) = & [ 1.234567890123456e-16_real32 , & 1.234567890123456e-01_real32 , & 1.234567890123456e+01_real32 , & 1.234567890123456e+16_real32 , & 1.0_real32 ] real ( kind = real64 ), parameter :: double_number ( nums ) = & [ 1.234567890123456e-16_real64 , & 1.234567890123456e-01_real64 , & 1.234567890123456e+01_real64 , & 1.234567890123456e+16_real64 , & 1.0_real64 ] real ( kind = real32 ), parameter :: sten = 1 0.0_real32 real ( kind = real64 ), parameter :: dten = 1 0.0_real64 integer :: i real ( kind = real32 ) :: x , y1 , y2 , y3 , y4 real ( kind = real64 ) :: xd , yd1 , yd2 , yd3 , yd4 call unit_test_mode ( level = 0 , luns = [ OUTPUT_UNIT ]) ! Scalar calls do i = 1 , nums x = single_number ( i ) y1 = nearest ( x , 1.0_real32 ) y2 = y1 - spacing ( x ) y3 = nearest ( x , - 1.0_real32 ) y4 = y3 + spacing ( x ) call test_compare_float_single () call test_equalto_single () call test_greaterthan_single () call test_lessthan_single () xd = double_number ( i ) yd1 = nearest ( xd , 1.0_real64 ) yd2 = yd1 - spacing ( xd ) yd3 = nearest ( xd , - 1.0_real64 ) yd4 = yd3 + spacing ( xd ) call test_compare_float_double () call test_equalto_double () call test_greaterthan_double () call test_lessthan_double () enddo call test_elemental_single () call test_elemental_double () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_compare_float_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float single' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( x , sfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( y1 , sfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( y2 , sfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( y3 , sfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( y4 , sfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , x . eq . y4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( x , y1 ), \"Compare_Float(x, y1)       = \" , compare_float ( x , y1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( x , y1 , ulp = 2 ), \"Compare_Float(x, y1,ulp=2) = \" , compare_float ( x , y1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( x , y2 ), \"Compare_Float(x, y2)       = \" , compare_float ( x , y2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( x , y3 ), \"Compare_Float(x, y3)       = \" , compare_float ( x , y3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( x , y3 , ulp = 2 ), \"Compare_Float(x, y3,ulp=2) = \" , compare_float ( x , y3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( x , y4 ), \"Compare_Float(x, y4)       = \" , compare_float ( x , y4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_compare_float_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float double' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( xd , dfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( yd1 , dfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( yd2 , dfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( yd3 , dfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( yd4 , dfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( xd , yd1 ), \"Compare_Float(xd, yd1)      =\" , compare_float ( xd , yd1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( xd , yd1 , ulp = 2 ), \"Compare_Float(xd, yd1,ulp=2)=\" , compare_float ( xd , yd1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( xd , yd2 ), \"Compare_Float(xd, yd2)      =\" , compare_float ( xd , yd2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( xd , yd3 ), \"Compare_Float(xd, yd3)      =\" , compare_float ( xd , yd3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( xd , yd3 , ulp = 2 ), \"Compare_Float(xd, yd3,ulp=2)=\" , compare_float ( xd , yd3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( xd , yd4 ), \"Compare_Float(xd, yd4)      =\" , compare_float ( xd , yd4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_elemental_single () real ( kind = real32 ), dimension ( nums ) :: xv , yv1 , yv2 , yv3 , yv4 real ( kind = real32 ), dimension ( nums , 2 ) :: xa , ya1 , ya2 , ya3 , ya4 character ( len = :), allocatable :: title title = 'equalto single' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xv = single_number yv1 = nearest ( xv , ( / ( 1.0_real32 , i = 1 , nums ) / ) ) yv2 = yv1 - spacing ( xv ) yv3 = nearest ( xv , ( / ( - 1.0_real32 , i = 1 , nums ) / ) ) yv4 = yv3 + spacing ( xv ) call unit_test_msg ( title , \"    xv  = \" , str ( xv ) ) call unit_test_msg ( title , \"    yv1 = \" , str ( yv1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yv2 = \" , str ( yv2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yv3 = \" , str ( yv3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yv4 = \" , str ( yv4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xv , yv1 )), \"Compare_Float(xv, yv1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv1 , ulp = 2 )), \"Compare_Float(xv, yv1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv2 )), \"Compare_Float(xv, yv2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xv , yv3 )), \"Compare_Float(xv, yv3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv3 , ulp = 2 )), \"Compare_Float(xv, yv3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv4 )), \"Compare_Float(xv, yv4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . equalto . yv1 )), \"( xv .equalto. yv1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv2 )), \"( xv .equalto. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xv . equalto . yv3 )), \"( xv .equalto. yv3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv4 )), \"( xv .equalto. yv4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv1 )), \"( xv .greaterthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv2 )), \"( xv .greaterthan. yv2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xv . greaterthan . yv3 )), \"( xv .greaterthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv4 )), \"( xv .greaterthan. yv4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . lessthan . yv1 )), \"( xv .lessthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv2 )), \"( xv .lessthan. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv3 )), \"( xv .lessthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv4 )), \"( xv .lessthan. yv4 )\" ) call unit_test_msg ( title , 'matrix' ) xa = reshape (( / single_number , single_number + ( sten * spacing ( single_number )) / ),( / nums , 2 / )) ya1 = nearest ( xa , reshape (( / ( 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya2 = ya1 - spacing ( xa ) ya3 = nearest ( xa , reshape (( / ( - 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya4 = ya3 + spacing ( xa ) call unit_test_msg ( title , \"    xa  = \" , str ([ xa ]) ) call unit_test_msg ( title , \"    ya1 = \" , str ([ ya1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    ya2 = \" , str ([ ya2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    ya3 = \" , str ([ ya3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    ya4 = \" , str ([ ya4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 )), \"Compare_Float(xa,ya1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 , ulp = 2 )), \"Compare_Float(xa,ya1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya2 )), \"Compare_Float(xa,ya2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 )), \"Compare_Float(xa,ya3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 , ulp = 2 )), \"Compare_Float(xa,ya3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya4 )), \"Compare_Float(xa,ya4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya1 )), \"( xa .equalto. ya1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya2 )), \"( xa .equalto. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya3 )), \"( xa .equalto. ya3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya4 )), \"( xa .equalto. ya4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya1 )), \"( xa .greaterthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya2 )), \"( xa .greaterthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . greaterthan . ya3 )), \"( xa .greaterthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya4 )), \"( xa .greaterthan. ya4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . lessthan . ya1 )), \"( xa .lessthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya2 )), \"( xa .lessthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya3 )), \"( xa .lessthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya4 )), \"( xa .lessthan. ya4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_elemental_double () real ( kind = real64 ), dimension ( nums ) :: xvd , yvd1 , yvd2 , yvd3 , yvd4 real ( kind = real64 ), dimension ( nums , 2 ) :: xad , yad1 , yad2 , yad3 , yad4 character ( len = :), allocatable :: title title = 'equalto double' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xvd = double_number yvd1 = nearest ( xvd , ( / ( 1.0_real64 , i = 1 , nums ) / ) ) yvd2 = yvd1 - spacing ( xvd ) yvd3 = nearest ( xvd , ( / ( - 1.0_real64 , i = 1 , nums ) / ) ) yvd4 = yvd3 + spacing ( xvd ) call unit_test_msg ( title , \"    xvd  = \" , str ( xvd ) ) call unit_test_msg ( title , \"    yvd1 = \" , str ( yvd1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yvd2 = \" , str ( yvd2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yvd3 = \" , str ( yvd3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yvd4 = \" , str ( yvd4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xvd , yvd1 )), \"Compare_Float(xvd, yvd1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd1 , ulp = 2 )), \"Compare_Float(xvd, yvd1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd2 )), \"Compare_Float(xvd, yvd2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xvd , yvd3 )), \"Compare_Float(xvd, yvd3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd3 , ulp = 2 )), \"Compare_Float(xvd, yvd3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd4 )), \"Compare_Float(xvd, yvd4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . equalto . yvd1 )), \"( xvd .equalto. yvd1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd2 )), \"( xvd .equalto. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xvd . equalto . yvd3 )), \"( xvd .equalto. yvd3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd4 )), \"( xvd .equalto. yvd4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd1 )), \"( xvd .greaterthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd2 )), \"( xvd .greaterthan. yvd2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xvd . greaterthan . yvd3 )), \"( xvd .greaterthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd4 )), \"( xvd .greaterthan. yvd4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . lessthan . yvd1 )), \"( xvd .lessthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd2 )), \"( xvd .lessthan. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd3 )), \"( xvd .lessthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd4 )), \"( xvd .lessthan. yvd4 )\" ) call unit_test_msg ( title , 'matrix' ) xad = reshape (( / double_number , double_number + ( dten * spacing ( double_number )) / ),( / nums , 2 / )) yad1 = nearest ( xad , reshape (( / ( 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad2 = yad1 - spacing ( xad ) yad3 = nearest ( xad , reshape (( / ( - 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad4 = yad3 + spacing ( xad ) call unit_test_msg ( title , \"    xad  = \" , str ([ xad ]) ) call unit_test_msg ( title , \"    yad1 = \" , str ([ yad1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yad2 = \" , str ([ yad2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yad3 = \" , str ([ yad3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yad4 = \" , str ([ yad4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 )), \"Compare_Float(xad,yad1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 , ulp = 2 )), \"Compare_Float(xad,yad1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad2 )), \"Compare_Float(xad,yad2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 )), \"Compare_Float(xad,yad3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 , ulp = 2 )), \"Compare_Float(xad,yad3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad4 )), \"Compare_Float(xad,yad4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad1 )), \"( xad .equalto. yad1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad2 )), \"( xad .equalto. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad3 )), \"( xad .equalto. yad3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad4 )), \"( xad .equalto. yad4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad1 )), \"( xad .greaterthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad2 )), \"( xad .greaterthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . greaterthan . yad3 )), \"( xad .greaterthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad4 )), \"( xad .greaterthan. yad4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . lessthan . yad1 )), \"( xad .lessthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad2 )), \"( xad .lessthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad3 )), \"( xad .lessthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad4 )), \"( xad .lessthan. yad4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_equalto_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . equalto . yd1 ), \"( x .equalto. y1 ) =\" , xd . equalto . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . equalto . yd2 ), \"( x .equalto. y2 ) =\" , xd . equalto . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . equalto . yd3 ), \"( x .equalto. y3 ) =\" , xd . equalto . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . equalto . yd4 ), \"( x .equalto. y4 ) =\" , xd . equalto . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_equalto_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , xd . eq . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . equalto . y1 ), \"( x .equalto. y1 ) =\" , x . equalto . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . equalto . y2 ), \"( x .equalto. y2 ) =\" , x . equalto . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . equalto . y3 ), \"( x .equalto. y3 ) =\" , x . equalto . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . equalto . y4 ), \"( x .equalto. y4 ) =\" , x . equalto . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_lessthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . lt . yd1 , xd . lt . yd1 , xd . lt . yd2 , xd . lt . yd3 , xd . lt . yd3 , xd . lt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . lessthan . yd1 ), \"( x .lessthan. y1 ) =\" , xd . lessthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . lessthan . yd2 ), \"( x .lessthan. y2 ) =\" , xd . lessthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . lessthan . yd3 ), \"( x .lessthan. y3 ) =\" , xd . lessthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . lessthan . yd4 ), \"( x .lessthan. y4 ) =\" , xd . lessthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_lessthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . lt . y1 , x . lt . y1 , x . lt . y2 , x . lt . y3 , x . lt . y3 , x . lt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . lessthan . y1 ), \"( x .lessthan. y1 ) =\" , x . lessthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . lessthan . y2 ), \"( x .lessthan. y2 ) =\" , x . lessthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . lessthan . y3 ), \"( x .lessthan. y3 ) =\" , x . lessthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . lessthan . y4 ), \"( x .lessthan. y4 ) =\" , x . lessthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_greaterthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . gt . yd1 , xd . gt . yd1 , xd . gt . yd2 , xd . gt . yd3 , xd . gt . yd3 , xd . gt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . greaterthan . yd1 ), \"( x .greaterthan. y1 ) =\" , xd . greaterthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . greaterthan . yd2 ), \"( x .greaterthan. y2 ) =\" , xd . greaterthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . greaterthan . yd3 ), \"( x .greaterthan. y3 ) =\" , xd . greaterthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . greaterthan . yd4 ), \"( x .greaterthan. y4 ) =\" , xd . greaterthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_greaterthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . gt . y1 , x . gt . y1 , x . gt . y2 , x . gt . y3 , x . gt . y3 , x . gt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . greaterthan . y1 ), \"( x .greaterthan. y1 ) =\" , x . greaterthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . greaterthan . y2 ), \"( x .greaterthan. y2 ) =\" , x . greaterthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . greaterthan . y3 ), \"( x .greaterthan. y3 ) =\" , x . greaterthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . greaterthan . y4 ), \"( x .greaterthan. y4 ) =\" , x . greaterthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program test_compare_float","tags":"","url":"program/test_compare_float.html"},{"title":"demo_significant – M_framework","text":"Uses M_framework__approx Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0.7,1x))' Source Code program demo_significant use M_framework__approx , only : significant implicit none character ( len =* ), parameter :: g = '(*(g0.7,1x))' write ( * , g ) significant ([ 876 5.43210 , 0.1234567890 ], 5 ) write ( * , * ) 'default:' , 1.23456789012345 write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ), 'RU' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ), 'RD' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ), 'RZ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ), 'RN' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ), 'RC' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ), 'RP' end program demo_significant","tags":"","url":"program/demo_significant.html"},{"title":"demo_unit_test_stop – M_framework","text":"Uses M_framework iso_fortran_env Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_test_stop use M_framework , only : unit_test_start , unit_test_end , & & unit_test , unit_test_stop , unit_test_mode use , intrinsic :: iso_fortran_env , stdout => OUTPUT_UNIT implicit none integer :: x x = 10 call unit_test_mode ( luns = [ stdout ]) ! do a test call unit_test_start ( 'proc1' ) call unit_test ( 'proc1' , x > 3 , 'if big enough' ) call unit_test ( 'proc1' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc1' , msg = 'checks all done' ) ! do another test call unit_test_start ( 'proc2' ) call unit_test ( 'proc2' , x > 3 , 'if big enough' ) call unit_test ( 'proc2' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc2' , msg = 'checks all done' ) ! tally up test results and stop program call unit_test_stop () end program demo_unit_test_stop","tags":"","url":"program/demo_unit_test_stop.html"},{"title":"demo_unit_test_system – M_framework","text":"Uses M_framework Source Code program demo_unit_test_system use M_framework , only : & unit_test_start , & unit_test , & unit_test_system , & unit_test_end implicit none if ( command_argument_count () == 0 ) then call unit_test_start ( 'myroutine' ) call unit_test ( 'false' , unit_test_system ( 'false' ) == 0 , 'check false' ) call unit_test ( 'true' , unit_test_system ( 'true' ) == 0 , 'check true' ) call unit_test ( 'notthere' , unit_test_system ( 'notthere' ) == 0 , & & 'check notthere' ) call unit_test ( '*' ,& & unit_test_system ( '* and options' , verbose = . true .) == 0 , 'check \"*\"' ) call unit_test_end ( 'myroutine' ) else write ( * , * ) 'called with an option' endif end program demo_unit_test_system","tags":"","url":"program/demo_unit_test_system.html"},{"title":"demo_update – M_framework","text":"Uses M_framework__attr Source Code program demo_update use M_framework__attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","url":"program/demo_update.html"},{"title":"demo_attr_mode – M_framework","text":"Uses M_framework__attr Variables Type Attributes Name Initial integer :: i character(len=:), allocatable :: lines (:) character(len=:), allocatable :: outlines (:) Source Code program demo_attr_mode use M_framework__attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & & '<M><y>' ,& & '<M><y>  Suffice it to say that black and white are also colors' ,& & '<M><y>  for their simultaneous contrast is as striking as that ' ,& & '<M><y>  of green and red, for instance. & & --- <y><bo>Vincent van Gogh</bo></y>' ,& & ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode end program demo_attr_mode","tags":"","url":"program/demo_attr_mode.html"},{"title":"demo_M_framework__attr – M_framework","text":"Uses M_framework__attr Variables Type Attributes Name Initial character(len=*), parameter :: f = '( \"   <bo><w><G> GREAT: </G></w>The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\")' character(len=256) :: line real :: value Source Code program demo_M_framework__attr use M_framework__attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mnemonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_framework__attr","tags":"","url":"program/demo_m_framework__attr.html"},{"title":"demo_journal – M_framework","text":"Uses M_framework__journal BASIC USAGE Source Code program demo_journal use M_framework__journal , only : journal !! BASIC USAGE call journal (& & 'write to standard output as-is, and trail file as a comment if open' ) ! since trail file is not yet open, only stdout will display output call journal ( 'c' , 'ignored, as trail file is not open' ) ! now open trail file \"trail\" call journal ( 'o' , 'trail' ) call journal ( 'sc' , 'same thing except now trail file is open' ) ! only write to trail file if open call journal ( 'c' ,& & 'not ignored, as trail file is open. Written with # suffix' ) call journal ( 't' ,& & 'not ignored, as trail file is open. Written as-is' ) ! turn off trail file call journal ( 'o' , '' ) end program demo_journal","tags":"","url":"program/demo_journal~2.html"},{"title":"demo_unit_test_end – M_framework","text":"Uses M_framework Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_test_end use M_framework , only : unit_test_start use M_framework , only : unit_test use M_framework , only : unit_test_end implicit none integer :: x x = 10 call unit_test_start ( 'myroutine' ) call unit_test ( 'myroutine' , x > 3 , 'if big enough' ) call unit_test ( 'myroutine' , x < 100 , 'if small enough' ) ! program execution stopped call unit_test_end ( 'myroutine' , msg = 'checks on \"myroutine\"' ) end program demo_unit_test_end","tags":"","url":"program/demo_unit_test_end.html"},{"title":"demo_unit_test_msg – M_framework","text":"Uses M_framework Source Code program demo_unit_test_msg use M_framework , only : unit_test_start , unit_test_msg , & & unit_test_end implicit none call unit_test_start ( 'myroutine' ) call unit_test_msg ( 'myroutine' , 'HUGE(3f) integers' , & & huge ( 0 ), 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) call unit_test_msg ( 'myroutine' , 'real            :' , & & huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) call unit_test_msg ( 'myroutine' , 'doubleprecision :' , & & huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) call unit_test_msg ( 'myroutine' , 'complex         :' , & & cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) call unit_test_end ( 'myroutine' ) end program demo_unit_test_msg","tags":"","url":"program/demo_unit_test_msg.html"},{"title":"demo_set – M_framework","text":"Uses M_framework__msg iso_fortran_env Variables Type Attributes Name Initial real(kind=real32) :: a real(kind=real64) :: b real(kind=real128) :: c integer(kind=int8) :: i integer(kind=int16) :: j integer(kind=int32) :: k integer(kind=int64) :: l Namelists Namelist all Variables Name Type Default Description a real(kind=real32) None Namelist all Variables Name Type Default Description b real(kind=real64) None Namelist all Variables Name Type Default Description c real(kind=real128) None Namelist all Variables Name Type Default Description i integer(kind=int8) None Namelist all Variables Name Type Default Description j integer(kind=int16) None Namelist all Variables Name Type Default Description k integer(kind=int32) None Namelist all Variables Name Type Default Description l integer(kind=int64) None Source Code program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_framework__msg , only : set implicit none real ( kind = real32 ) :: a ; namelist / all / a real ( kind = real64 ) :: b ; namelist / all / b real ( kind = real128 ) :: c ; namelist / all / c integer ( kind = int8 ) :: i ; namelist / all / i integer ( kind = int16 ) :: j ; namelist / all / j integer ( kind = int32 ) :: k ; namelist / all / k integer ( kind = int64 ) :: l ; namelist / all / l call set ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set","tags":"","url":"program/demo_set.html"},{"title":"maketest – M_framework","text":"Uses iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: out = stdout character(len=:), allocatable :: words (:) Functions function get_stack () result(args) Arguments None Return Value character(len=:), allocatable, (:) Source Code program maketest use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none character ( len = :), allocatable :: words (:) character ( len =* ), parameter :: g = '(*(g0))' logical , parameter :: T = . true ., F = . false . integer :: out = stdout integer :: i ! a program to call the test_suite_* Fortran procedures write ( out , g ) \"program runtest\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only : real_kinds,real32,real64,real128\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only : integer_kinds,int8,int16,int32,int64\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only: &\" write ( out , g ) \"& stdin => input_unit,   &\" write ( out , g ) \"& stdout => output_unit, &\" write ( out , g ) \"& stderr => error_unit\" write ( out , g ) \"use M_framework, only : unit_test_start, unit_test, unit_test_msg\" write ( out , g ) \"use M_framework, only : unit_test_end, unit_test_stop, unit_test_mode\" write ( out , g ) \"use M_framework, only : unit_test_level, unit_test_flags\" write ( out , g ) \"!use M_xxxx\" write ( out , g ) \"implicit none\" write ( out , g ) \"logical, parameter :: T=.true., F=.false.\" write ( out , g ) \"logical            :: matched\" write ( out , g ) \"! optional call to change default modes\" write ( out , g ) \"   call unit_test_mode(       &\" write ( out , g ) \"       keep_going=T,           &\" write ( out , g ) \"       flags=[0],              &\" write ( out , g ) \"       luns=[stdout],          &\" write ( out , g ) \"       command='',             &\" write ( out , g ) \"       brief=F,                &\" write ( out , g ) \"       match='',               &\" write ( out , g ) \"       interactive=F,          &\" write ( out , g ) \"       CMDLINE=T,              &\" write ( out , g ) \"       debug=F)\" write ( out , g ) \"\" write ( out , g ) '   unit_test_level=0' words = get_stack () if ( size ( words ) . eq . 0 ) words = [ \"sample\" ] write ( out , g ) '' do i = 1 , size ( words ) write ( out , g ) '   call test_suite_' // trim ( words ( i )) // '()' end do write ( out , g ) '   call unit_test_stop()' write ( out , g ) '' write ( out , g ) 'contains' do i = 1 , size ( words ) write ( out , g ) '' write ( out , g ) 'subroutine test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_start(\"' // trim ( words ( i )) // '\",msg=\"\",matched=matched)' write ( out , g ) '   if(.not.matched)return' write ( out , g ) '   !!call unit_test(\"' // trim ( words ( i )) // '\", 0 .eq. 0, \"checking\",100)' write ( out , g ) '   call unit_test_end(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) 'end subroutine test_suite_' // trim ( words ( i )) end do write ( out , g ) '' write ( out , g ) 'end program runtest' contains function get_stack () result ( args ) character ( len = :), allocatable :: args (:) integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_ARGS end if end do GET_ARGS end function get_stack end program maketest","tags":"","url":"program/maketest.html"},{"title":"maketest – M_framework","text":"Uses iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. character(len=*), parameter :: g = '(*(g0))' integer :: i character(len=256) :: iomsg integer :: iostat integer :: out character(len=:), allocatable :: words (:) Functions function get_stack () result(args) Arguments None Return Value character(len=:), allocatable, (:) Source Code program maketest ! writes an individual file for each argument name use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none character ( len = :), allocatable :: words (:) character ( len =* ), parameter :: g = '(*(g0))' logical , parameter :: T = . true ., F = . false . integer :: out , i , iostat character ( len = 256 ) :: iomsg ! a program to call the test_suite_* Fortran procedures words = get_stack () if ( size ( words ) . eq . 0 ) words = [ '--help' ] if ( words ( 1 ). eq . '--help' ) then write ( stderr , g ) '--------------------------------------------------------------------------------' write ( stderr , g ) 'NAME                                                                            ' write ( stderr , g ) ' unit-test(1f) - create unit-test skeleton programs for use with M_framework(1) ' write ( stderr , g ) 'SYNOPSIS                                                                        ' write ( stderr , g ) '     unit_test ARG1 ARG2 ARG3 ARG4 ...                                          ' write ( stderr , g ) 'DESCRIPTION                                                                     ' write ( stderr , g ) '   generate skeleton programs in current directory named \"unit_test_ARG.f90\"    ' write ( stderr , g ) '   for use with \"fpm test\". Will not overwrite existing files.                  ' write ( stderr , g ) 'EXAMPLE                                                                         ' write ( stderr , g ) 'Create a new fpm project to try it out                                          ' write ( stderr , g ) '   fpm new tryit;cd tryit/test  # go to test/ directory of an fpm(1) project    ' write ( stderr , g ) ' unit_test a b c             # create three skeleton test files                 ' write ( stderr , g ) 'Ensure your fpm.toml file includes M_framework as a dependency with lines like  ' write ( stderr , g ) '[dev-dependencies]                                                              ' write ( stderr , g ) '   M_framework    = { git = \"https://github.com/urbanjost/M_framework.git\" }    ' write ( stderr , g ) 'Run tests                                                                       ' write ( stderr , g ) '    fpm test   # run all tests                                                  ' write ( stderr , g ) '    fpm test unit_test_c # run test \"c\"                                        ' write ( stderr , g ) '    fpm test \"timing_*\" # run tests starting with \"timing_\"                     ' write ( stderr , g ) '    fpm test -- command=bookkeeper  # use sample bookkeeper command to generate ' write ( stderr , g ) '                                    # CSV and HTML and NAMELIST files.          ' write ( stderr , g ) 'Now try it in a real fpm(1) test/ directory and add real tests or results in the' write ( stderr , g ) 'unit_test(3f) calls.                                                           ' write ( stderr , g ) '--------------------------------------------------------------------------------' !      write (stderr, g) '    [[test]]                                                                    ' !      write (stderr, g) '    name=\"test_suite\"                                                           ' !      write (stderr, g) '    source-dir=\"test\"                                                           ' !      write (stderr, g) '    main=\"check.f90\"                                                            ' !      write (stderr, g) '    [test.dependencies]                                                         ' !      write (stderr, g) '    M_framework = { git = \"https://github.com/urbanjost/M_framework.git\" }      ' stop endif do i = 1 , size ( words ) open ( newunit = out , file = 'unit_test_' // trim ( words ( i )) // '.f90' , status = 'new' , iostat = iostat , iomsg = iomsg ) if ( iostat . ne . 0 ) then write ( stderr , g ) trim ( iomsg ) cycle endif write ( out , g ) \"program unit_test_\" , trim ( words ( i )) write ( out , g ) \"use, intrinsic :: iso_fortran_env, only: &\" write ( out , g ) \"& real32, real64, real128,   &\" write ( out , g ) \"& int8, int16, int32, int64, &\" write ( out , g ) \"& stdin => input_unit,       &\" write ( out , g ) \"& stdout => output_unit,     &\" write ( out , g ) \"& stderr => error_unit\" write ( out , g ) \"use M_framework, only : unit_test_start, unit_test\" write ( out , g ) \"use M_framework, only : unit_test_end,   unit_test_stop\" write ( out , g ) \"use M_framework, only : unit_test_mode,  unit_test_msg\" write ( out , g ) \"use M_framework, only : unit_test_level, unit_test_flags\" write ( out , g ) \"!use M_xxxx\" write ( out , g ) \"implicit none\" write ( out , g ) \"logical, parameter :: T=.true., F=.false.\" write ( out , g ) \"! optional call to change default modes\" write ( out , g ) \"   call unit_test_mode(       &\" write ( out , g ) \"       keep_going=T,           &\" write ( out , g ) \"       flags=[0],              &\" write ( out , g ) \"       luns=[stdout],          &\" write ( out , g ) \"       command='',             &\" write ( out , g ) \"       brief=F,                &\" write ( out , g ) \"       silent=F,               &\" write ( out , g ) \"       verbose=F,              &\" write ( out , g ) \"       interactive=F,          &\" write ( out , g ) \"       cmdline=T,              &\" write ( out , g ) \"       debug=F)\" write ( out , g ) \"\" write ( out , g ) '   unit_test_level=0' write ( out , g ) '' write ( out , g ) '   call test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_stop()' write ( out , g ) '' write ( out , g ) 'contains' write ( out , g ) '' write ( out , g ) 'subroutine test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_start(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) '   !!call unit_test(\"' // trim ( words ( i )) // '\", 0 .eq. 0, \"checking\",100)' write ( out , g ) '   call unit_test_end(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) 'end subroutine test_suite_' // trim ( words ( i )) write ( out , g ) '' write ( out , g ) \"end program unit_test_\" , trim ( words ( i )) close ( unit = out , iostat = iostat ) enddo contains function get_stack () result ( args ) character ( len = :), allocatable :: args (:) character ( len = 256 ) :: errmsg = '' integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) !,errmsg=errmsg)    ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining length for argument ' , i , trim ( errmsg ) exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) !,errmsg=errmsg)  ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i , trim ( errmsg ) exit GET_ARGS end if end do GET_ARGS end function get_stack end program maketest","tags":"","url":"program/maketest~2.html"},{"title":"runtest – M_framework","text":"Uses M_framework Subroutines subroutine test_framework () Arguments None Source Code program runtest use M_framework unit_test_level = 0 call test_framework () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_framework () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_framework !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest~3.html"},{"title":"demo_attr – M_framework","text":"Uses M_framework__attr Subroutines subroutine printstuff (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_attr use M_framework__attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_attr","tags":"","url":"program/demo_attr.html"},{"title":"testtype – M_framework","text":"Uses M_framework iso_fortran_env something where you could restrict nml output to just listed names would be nice\nwrite( ,nml=args)[‘A’,’H’]\nwrite( ,nml=*NML)args[‘A’,’H’] Variables Type Attributes Name Initial character(len=256) :: answer character(len=80) :: archiver = '' character(len=80) :: c_compiler = '' character(len=80) :: c_flag = '' character(len=80) :: compiler = '' character(len=80) :: cxx_compiler = '' character(len=80) :: cxx_flag = '' character(len=80) :: flag = '' character(len=*), parameter :: g = '(*(g0,1x))' character(len=256) :: iomsg integer :: ios integer :: iostat integer :: level = 0 character(len=256) :: line character(len=80) :: link_flag = '' integer :: lun character(len=:), allocatable :: options character(len=80) :: profile = '' character(len=:), allocatable :: string character(len=:), allocatable :: strlevel Subroutines subroutine run (command) Arguments Type Intent Optional Attributes Name character(len=*) :: command Namelists Namelist args Variables Name Type Default Description level integer 0 Namelist args Variables Name Type Default Description compiler character(len=80) '' Namelist args Variables Name Type Default Description profile character(len=80) '' Namelist args Variables Name Type Default Description link_flag character(len=80) '' Namelist args Variables Name Type Default Description flag character(len=80) '' Namelist args Variables Name Type Default Description cxx_flag character(len=80) '' Namelist args Variables Name Type Default Description cxx_compiler character(len=80) '' Namelist args Variables Name Type Default Description c_flag character(len=80) '' Namelist args Variables Name Type Default Description c_compiler character(len=80) '' Namelist args Variables Name Type Default Description archiver character(len=80) '' Source Code program testtype ! evaluate an interactive environment wrapped around fpm(1) and M_framework(1) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_framework , only : str , wrt implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: ios integer :: iostat character ( len = :), allocatable :: string character ( len = 256 ) :: line character ( len = 256 ) :: iomsg character ( len = 256 ) :: answer integer :: lun character ( len = :), allocatable :: strlevel integer :: level = 0 ; namelist / args / level character ( len = 80 ) :: compiler = '' ; namelist / args / compiler character ( len = 80 ) :: profile = '' ; namelist / args / profile character ( len = 80 ) :: link_flag = '' ; namelist / args / link_flag character ( len = 80 ) :: flag = '' ; namelist / args / flag character ( len = 80 ) :: cxx_flag = '' ; namelist / args / cxx_flag character ( len = 80 ) :: cxx_compiler = '' ; namelist / args / cxx_compiler character ( len = 80 ) :: c_flag = '' ; namelist / args / c_flag character ( len = 80 ) :: c_compiler = '' ; namelist / args / c_compiler character ( len = 80 ) :: archiver = '' ; namelist / args / archiver character ( len = :), allocatable :: options options = ' --compiler gfortran --profile debug' strlevel = 'level=0' write ( * , g ) ' try different fpm(1) test commands, setting values via NAMELIST:' write ( * , g ) ' Enter command (\"help\" for more information):' INFINITE : do write ( * , g , iostat = ios , iomsg = iomsg , advance = 'no' ) 'fsh>' read ( * , '(a)' , iostat = ios , iomsg = iomsg ) line if ( ios . ne . 0 ) then write ( * , g ) trim ( iomsg ) cycle INFINITE endif if ( adjustl ( line ( 1 : 1 )) . eq . '#' ) cycle select case ( line ) case ( 'test' ) string = str ( 'fpm test --target ''*'' ' , options , ' -- luns=6' , strlevel ) call run ( string ) case ( 'brief' ) string = str ( 'fpm test --target ''*'' ' , options , ' -- luns=6 brief' , strlevel ) call run ( string ) case ( 'build' ) string = str ( 'fpm build                ' , options , ' -- luns=6' , strlevel ) call run ( string ) case ( 'run' ) call run ( str ( 'fpm run --target ''*'' ' , options , ' -- luns=6 brief' , strlevel )) case ( 'example' ) call run ( str ( 'fpm run --target ''*'' ' , options , ' --example -- luns=6 brief' , strlevel )) case ( 'valgrind' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --runner ''valgrind'' -- luns=6 brief interactive ' , strlevel )) case ( 'valgrind+' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --runner ''valgrind --leak-check=full '' -- luns=6 brief interactive ' , strlevel )) case ( 'debug' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --verbose --runner ''gdb -ex \"list,0\" -ex run --quiet --args'' -- luns=6 ' , strlevel )) case ( 'shell' , 'sh' ) call run ( 'bash' ) case ( 'list' ) write ( * , g ) 'APPLICATIONS:' call run ( 'fpm run --list' ) write ( * , g ) 'EXAMPLES:' call run ( 'fpm run --example --list' ) write ( * , g ) 'TESTS:' call run ( 'fpm test --list' ) case ( 'q' , 'stop' , 'quit' , 'exit' , 'end' , '.' ) exit INFINITE case ( 'help' , '?' ) write ( * , '(a)' ) [ character ( len = 80 ) :: & 'Any unrecognized command is passed to the system. Verbs are                     ' , & 'TESTS:                                                                          ' , & '   test      -- run \"fpm test\"  with current options                            ' , & '   brief     -- run \"fpm test\" tests in brief mode                              ' , & '   build     -- run \"fpm build\" with current options                            ' , & '   run       -- run \"fpm run\" with current options                              ' , & '   example   -- run \"fpm run --example \" with current options                   ' , & '   debug     -- run tests with gdb(1)                                           ' , & '   valgrind  -- run tests with \"valgrind\"                                       ' , & '   valgrind+ -- run tests with \"valgrind --leak-check=full\"                     ' , & 'NAMELIST VARIABLES: set current options                                         ' , & '   save      -- write NAMELIST config file using current settings               ' , & '   load      -- read NAMELIST config file to set options                        ' , & '   show      -- show variables that may be set                                  ' , & '   set       -- set NAMELIST values in submode                                  ' , & 'HOUSEKEEPING:                                                                   ' , & '   list      -- list targets                                                    ' , & '   bash|sh   -- bash shell                                                      ' , & '   stop|q|quit|exit|end                                                         ' , & 'EXAMPLE:                                                                        ' , & '    set                                                                         ' , & '    compiler=\"ifx\"                                                              ' , & '    level=3                                                                     ' , & '    .                                                                           ' , & '    brief                                                                       ' , & '    debug                                                                       ' , & '    quit                                                                        ' , & ' ' ] case ( 'show' ) write ( * , g ) 'options...' write ( * , nml = args , delim = 'quote' ) !! something where you could restrict nml output to just listed names would be nice !!write(*,nml=args)['A','H'] !!write(*,nml=*NML)args['A','H'] case ( 'load' ) write ( * , '(a)' , advance = 'no' ) 'filename:' read ( * , '(a)' , iostat = iostat ) answer if ( iostat . ne . 0 ) exit open ( file = answer , iostat = iostat , newunit = lun ) if ( iostat . ne . 0 ) exit read ( lun , args , iostat = iostat ) close ( unit = lun , iostat = iostat ) case ( 'save' ) write ( * , g , advance = 'no' ) 'filename:' read ( * , '(a)' , iostat = iostat ) answer if ( iostat . ne . 0 ) exit open ( file = answer , iostat = iostat , newunit = lun ) if ( iostat . ne . 0 ) exit write ( lun , args , iostat = iostat ) close ( unit = lun , iostat = iostat ) case ( 'set' ) UPDATE : block character ( len = :), allocatable :: intmp do write ( * , g ) 'enter \".\" to exit set mode. Current values are ...' write ( * , nml = args , iostat = iostat , iomsg = iomsg ) read ( * , '(a)' , iostat = iostat ) line if ( line . eq . '.' ) exit intmp = '&ARGS ' // trim ( line ) // '/' read ( intmp , nml = args , iostat = iostat , iomsg = iomsg ) if ( iostat . ne . 0 ) then write ( * , * ) 'ERROR:' , trim ( iomsg ) endif enddo strlevel = str ( 'level=' , level , sep = '' ) end block UPDATE ! add //'' to avoid gfortran-11 bug options = str ( & & str ( ' --compiler \"' , compiler , '\"' , if = compiler . ne . '' , sep = '' ) // '' , & & str ( ' --profile \"' , profile , '\"' , if = profile . ne . '' , sep = '' ) // '' , & & str ( ' --link-flag \"' , link_flag , '\"' , if = link_flag . ne . '' , sep = '' ) // '' , & & str ( ' --flag flag \"' , flag , '\"' , if = flag . ne . '' , sep = '' ) // '' , & & str ( ' --cxx-flag \"' , cxx_flag , '\"' , if = cxx_flag . ne . '' , sep = '' ) // '' , & & str ( ' --cxx-compiler \"' , cxx_compiler , '\"' , if = cxx_compiler . ne . '' , sep = '' ) // '' , & & str ( ' --c-flag \"' , c_flag , '\"' , if = c_flag . ne . '' , sep = '' ) // '' , & & str ( ' --c-compiler \"' , c_compiler , '\"' , if = c_compiler . ne . '' , sep = '' ) // '' , & & str ( ' --archiver \"' , archiver , '\"' , if = archiver . ne . '' , sep = '' ) // '' ) case default call run ( line ) end select enddo INFINITE contains subroutine run ( command ) ! convenience routine so command does not cause program to stop character ( len =* ) :: command logical , parameter :: wait = . true . integer :: exitstat integer :: cmdstat character ( len = 256 ) :: cmdmsg call wrt ([ error_unit ], \"+ \" , command ) cmdmsg = ' ' call execute_command_line ( command , wait , exitstat , cmdstat , cmdmsg ) if ( cmdstat /= 0 ) then call wrt ([ error_unit ], \"cmdstat: \" , cmdmsg , 'for command :' , command ) elseif ( cmdmsg /= '' ) then call wrt ([ error_unit ], \"exitstat: \" , cmdmsg , 'for command :' , command ) endif end subroutine run end program testtype","tags":"","url":"program/testtype.html"},{"title":"runtest – M_framework","text":"Uses iso_fortran_env M_framework__approx M_framework__journal M_framework__msg M_framework__verify Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' Subroutines subroutine test_accdig () Arguments None subroutine test_almost () Arguments None subroutine test_in_margin () call unit_test(‘in_margin’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_round () call unit_test(‘round’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_significant () Arguments None Source Code program runtest use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT use M_framework__msg use M_framework__verify use M_framework__journal use M_framework__approx implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' call unit_test_mode ( level = 0 , luns = [ OUTPUT_UNIT ]) call test_accdig () ! compare two real numbers only up to a specified number of digits call test_almost () ! function compares two numbers only up to a specified number of digits call test_in_margin () ! check if two reals are approximately equal using a relative margin call test_round () ! round val to specified number of significant digits call test_significant () ! round val to specified number of significant digits call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_in_margin () call unit_test_start ( 'in_margin' , msg = '' ) !!call unit_test('in_margin', 0.eq.0, 'checking', 100) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_test ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_test ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_test_end ( 'in_margin' , msg = '' ) end subroutine test_in_margin !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_significant () doubleprecision , allocatable :: answers (:) doubleprecision , allocatable :: expected (:) call unit_test_start ( 'significant' , msg = '' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ) expected = [ 2.0d0 , 1.3d0 , 1.24d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.2345679d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RU, round up' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RD, round down ' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RZ, round towards zero' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RN, round towards nearest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RC, compatible rounding rounds to closest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RP, processor-dependent rounding ' ) call unit_test_end ( 'significant' , msg = '' ) end subroutine test_significant !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_round () call unit_test_start ( 'round' , msg = '' ) !!call unit_test('round', 0.eq.0, 'checking', 100) call unit_test_end ( 'round' , msg = '' ) end subroutine test_round !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_accdig () integer , parameter :: sz = 16 doubleprecision :: a , b , aarr ( sz ), barr ( sz ) integer :: i , ind , indarr ( sz ) real :: acurcy , acurcyarr ( sz ) call unit_test_start ( 'accdig' , msg = '' ) do i = 1 , sz a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i ) call accdig ( a , b , 8.0 , acurcy , ind ) if ( unit_test_level > 0 ) write ( * , g ) i , a , b , acurcy , ind aarr ( i ) = a barr ( i ) = b enddo call accdig ( aarr , barr , 8.0 , acurcyarr , indarr ) if ( unit_test_level > 0 ) write ( * , g )( aarr ( i ), barr ( i ), acurcyarr ( i ), indarr ( i ), new_line ( 'a' ), i = 1 , sz ) call unit_test ( 'accdig' , all ( indarr . eq .[ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'expected 7 bad, got ' , count ( indarr . eq . 1 ) + 0 ) call unit_test_end ( 'accdig' , msg = '' ) end subroutine test_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_test_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_test ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i ), 'for' , x , y , r , 'expected' , expected ( i )) enddo call unit_test_end ( 'almost' , msg = '' ) end subroutine test_almost !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest~4.html"},{"title":"demo_assert – M_framework","text":"Uses M_framework__msg Variables Type Attributes Name Initial real :: a real :: toobig = 1024 Source Code program demo_assert use M_framework__msg , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( 'myroutine' , 101 , a > toobig , & & 'The value is too large' , a , ' > ' , toobig ) end program demo_assert","tags":"","url":"program/demo_assert.html"},{"title":"demo_fmt – M_framework","text":"Uses M_framework__msg Variables Type Attributes Name Initial character(len=:), allocatable :: output Source Code program demo_fmt use :: M_framework__msg , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","url":"program/demo_fmt.html"},{"title":"demo_in_margin – M_framework","text":"Uses M_framework__approx Source Code program demo_in_margin use :: M_framework__approx , only : in_margin implicit none write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], & & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], & & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.01 ) end program demo_in_margin","tags":"","url":"program/demo_in_margin.html"},{"title":"demo_pdec – M_framework","text":"Uses M_framework__msg Source Code program demo_pdec use M_framework__msg , only : pdec call pdec ( ' ABCDEFG abcdefg    ' ) end program demo_pdec","tags":"","url":"program/demo_pdec.html"},{"title":"demo_stderr – M_framework","text":"Uses M_framework__msg iso_fortran_env Source Code program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_framework__msg , only : stderr implicit none call stderr ( 'A simple message' ) call stderr ( 'error: RVALUE=' , 3.0 / 4.0 ) call stderr ( 'error: IVALUE=' , 123456789 ) call stderr ( 'error: LVALUE=' ,. true .) SEVERAL : block integer :: least = 10 , most = 999 , ival =- 10 call stderr ( 'error: value' , ival , & & 'should be between' , least , 'and' , most ) endblock SEVERAL call stderr ( 'real32  :' , huge ( 0.0_real32 ), 0.0_real32 , & & 1234 5.6789_real32 , tiny ( 0.0_real32 )) call stderr ( 'real64  :' , huge ( 0.0_real64 ), 0.0_real64 , & & 1234 5.6789_real64 , tiny ( 0.0_real64 )) !#ifdef __NVCOMPILER !#else call stderr ( 'real128 :' , huge ( 0.0_real128 ), 0.0_real128 , & & 1234 5.6789_real128 , tiny ( 0.0_real128 )) !#endif call stderr ( 'complex :' , cmplx ( huge ( 0.0_real ), tiny ( 0.0_real ))) call stderr ( 'error: program will now stop' ) stop 1 end program demo_stderr","tags":"","url":"program/demo_stderr.html"},{"title":"demo_unit_test_start – M_framework","text":"Uses M_framework Variables Type Attributes Name Initial integer :: ival logical :: matched Subroutines subroutine test_mysub1 () Arguments None subroutine test_mysub2 () Arguments None Source Code program demo_unit_test_start use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_mode , unit_test_stop implicit none integer :: ival logical :: matched call unit_test_mode () call test_mysub1 () call test_mysub2 () call unit_test_stop () contains subroutine test_mysub1 () ! first test call unit_test_start ( 'mysub1' ) ! the example goodbad(1) command called here takes many options ! used to build an SQLite3 entry ival = 10 call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub1\"' ) end subroutine test_mysub1 subroutine test_mysub2 () ! second test call unit_test_start ( 'mysub1' , '' , matched = matched ) ival = 200 if (. not . matched ) return ! makes it skippable call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub2\"' ) end subroutine test_mysub2 end program demo_unit_test_start","tags":"","url":"program/demo_unit_test_start.html"},{"title":"demo_wrt – M_framework","text":"Uses M_framework__msg iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ints (3) = [1, 2, 3] integer :: iostat = 0 integer, allocatable :: luns (:) Source Code program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_framework__msg , only : wrt , fmt implicit none integer , allocatable :: luns (:) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , 'NULL LIST:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! multiple files can be used to create a log file, for example luns = [ stderr , stdout ] call wrt ( luns , 'TWO FILES:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], 'USING FMT :' , & & huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , fmt ( ints ( 2 ), 'i0.4' ), iostat = iostat ) end program demo_wrt","tags":"","url":"program/demo_wrt.html"},{"title":"demo_unit_test_expected – M_framework","text":"Uses M_framework iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. Source Code program demo_unit_test_expected use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit use M_framework , only : & & unit_test_mode , & & start => unit_test_start , & & expected => unit_test_expected , & & stop => unit_test_stop , & & unit_test_level ! , unit_test_flags implicit none logical , parameter :: T = . true ., F = . false . ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stderr ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 ! unit tests for ABS(3f) intrinsic call start ( 'abs' ) ! integer call expected ( 'abs' , abs ( - 10 ), 10 ) call expected ( 'abs' , abs ( 10 ), 10 ) ! real and elemental call expected ( 'abs' , abs ( [ - 1 0.0 , 1 0.0 ]), 1 0.0 ) ! complex call expected ( 'abs' , abs (( 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( 3.0 , 4.0 )), 5.0 ) call stop ( 'abs' ) end program demo_unit_test_expected","tags":"","url":"program/demo_unit_test_expected.html"},{"title":"runtest – M_framework","text":"Uses M_framework iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. logical :: matched Subroutines subroutine add (message, question, answer, answer2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: question character(len=*), intent(in) :: answer character(len=*), intent(in) :: answer2 subroutine test_suite_assert () call unit_test(“assert”, 0 .eq. 0, “checking”,100) Arguments None subroutine test_suite_fmt () call unit_test(“fmt   “, 0 .eq. 0, “checking”,100) Arguments None subroutine test_suite_pdec () call unit_test(“pdec  “, 0 .eq. 0, “checking”,100) Arguments None subroutine test_suite_set () call unit_test(“set   “, 0 .eq. 0, “checking”,100) Arguments None subroutine test_suite_stderr () call unit_test(“stderr”, 0 .eq. 0, “checking”,100) Arguments None subroutine test_suite_str () Arguments None subroutine test_suite_wrt () call unit_test(“wrt   “, 0 .eq. 0, “checking”,100) Arguments None Source Code program runtest use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_framework , only : unit_test_start , unit_test , unit_test_msg use M_framework , only : unit_test_end , unit_test_stop , unit_test_mode use M_framework , only : unit_test_level ! unit_test_flags use M_framework , only : str !use M_xxxx implicit none logical , parameter :: T = . true ., F = . false . logical :: matched ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stderr ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 call test_suite_str () call test_suite_stderr () call test_suite_wrt () call test_suite_fmt () call test_suite_set () call test_suite_pdec () call test_suite_assert () call unit_test_stop ( 'M_framework_msg' ) contains subroutine test_suite_str () logical , allocatable :: tests (:) call unit_test_start ( 'str' , 'test building message strings' , matched = matched ) if (. not . matched ) return tests = [ logical :: ] call add ( 'INTEGER' , str ( 10 ), '10' , '10' ) call add ( 'LOGICAL' , str (. false .), 'F' , 'F' ) call add ( 'LOGICAL' , str (. true .), 'T' , 'T' ) call add ( 'REAL' , str ( 10 0.0 ), '100.000000' , '100.0000' ) call add ( 'COMPLEX' , str (( 1 1.0 , 2 2.0 )), '(11.0000000,22.0000000)' , '(11.00000,22.00000)' ) call add ( 'COMPOUND' , str ( 10 , 10 0.0 , \"string\" ,( 1 1.0 , 2 2.0 ),. false .), & & '10 100.000000 string (11.0000000,22.0000000) F' ,& & '10 100.0000 string (11.00000,22.00000) F' ) call unit_test_msg ( 'str' , 'tally is ' , str ( tests ) // '' ) ! //'' for gfortran-11 bug call unit_test_end ( \"str   \" , msg = \"\" ) end subroutine test_suite_str subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if ( passed ) then call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer , 'got' , question ) else passed = question . eq . answer2 call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer2 , 'got' , question ) endif end subroutine add subroutine test_suite_stderr () call unit_test_start ( \"stderr\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"stderr\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"stderr\" , msg = \"\" ) end subroutine test_suite_stderr subroutine test_suite_wrt () call unit_test_start ( \"wrt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"wrt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"wrt\" , msg = \"\" ) end subroutine test_suite_wrt subroutine test_suite_fmt () call unit_test_start ( \"fmt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"fmt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"fmt\" , msg = \"\" ) end subroutine test_suite_fmt subroutine test_suite_set () call unit_test_start ( \"set\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"set   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"set\" , msg = \"\" ) end subroutine test_suite_set subroutine test_suite_pdec () call unit_test_start ( \"pdec\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"pdec  \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"pdec\" , msg = \"\" ) end subroutine test_suite_pdec subroutine test_suite_assert () call unit_test_start ( \"assert\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"assert\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"assert\" , msg = \"\" ) end subroutine test_suite_assert end program runtest","tags":"","url":"program/runtest~5.html"},{"title":"M_test_suite_M_steam67 – M_framework","text":"Uses M_framework Variables Type Attributes Name Initial double precision, allocatable :: answers (:) double precision, allocatable :: expected (:) double precision, allocatable :: input (:) Subroutines subroutine test_cos () Arguments None subroutine test_sin () Arguments None subroutine test_sqrt () Arguments None Source Code program M_test_suite_M_steam67 use M_framework , only : unit_test_start , unit_test , unit_test_done , & unit_test_mode , unit_test_stop !  unit_test_level !use M_steam67 implicit none double precision , allocatable :: expected (:), answers (:), input (:) call test_sqrt () call test_cos () call test_sin () call unit_test_stop () contains subroutine test_sqrt () integer :: i call unit_test_mode ( luns = [ 0 , 10 ]) call unit_test_start ( 'sqrt' , msg = '' ) call unit_test_mode ( luns = [ 0 , 10 ]) input = [ 1.0d0 , 4.0d0 , 9.0d0 ] expected = [ 1.0d0 , 2.0d0 , 3.0d0 ] answers = [( sqrt ( input ( i )), i = 1 , size ( input ))] call unit_test ( 'sqrt' , & all ( expected . eq . answers ), & 'check table of values' ) call unit_test ( 'sqrt' , & sqrt ( 2 5.0d0 ). eq . 5.0d0 , & 'got' , sqrt ( 2 5.0d0 ), 'expected' , 5.0d0 ) call unit_test_done ( 'sqrt' , msg = '' ) end subroutine test_sqrt subroutine test_sin () call unit_test_start ( 'sin' , msg = '' ) call unit_test_done ( 'sin' , msg = '' ) end subroutine test_sin subroutine test_cos () call unit_test_start ( 'cos' , msg = '' ) call unit_test_done ( 'cos' , msg = '' ) end subroutine test_cos end program M_test_suite_M_steam67","tags":"","url":"program/m_test_suite_m_steam67.html"},{"title":"demo_unit_test – M_framework","text":"Uses M_framework Variables Type Attributes Name Initial integer, allocatable :: arr (:) real, allocatable :: arr1 (:) real, allocatable :: arr2 (:) integer :: i integer :: x Source Code program demo_unit_test use M_framework , only : & & unit_test_mode , & & unit_test_start , & & unit_test , & & unit_test_end , & & unit_test_stop use M_framework , only : almost implicit none integer :: i integer :: x integer , allocatable :: arr (:) real , allocatable :: arr1 (:) real , allocatable :: arr2 (:) call unit_test_mode ( keep_going = . true ., debug = . false ., command = '' ) x = 10 arr1 = [ 1.0 , 1 0.0 , 10 0.0 ] arr2 = [ 1.0001 , 1 0.001 , 10 0.01 ] call unit_test_start ( 'myroutine' ) call unit_test ( 'myroutine' , x > 3 , ' if big enough' ) call unit_test ( 'myroutine' , x < 100 , ' if small enough' ) do i = 1 , size ( arr1 ) call unit_test ( 'myroutine' , & & almost ( arr1 ( i ), arr2 ( i ), 3.9 , verbose = . true .) ) enddo arr = [ 10 , 20 , 30 ] call unit_test ( 'myroutine' , . not . any ( arr < 0 ) , & & 'fail if any negative values in array ARR' ) call unit_test ( 'myroutine' , all ( arr < 100 ) , & & 'fail unless all values are less than 100 in array ARR' ) call unit_test_end ( 'myroutine' , & & msg = 'checks on \"myroutine\" all passed' ) call unit_test_stop () end program demo_unit_test","tags":"","url":"program/demo_unit_test.html"},{"title":"demo_accdig – M_framework","text":"Uses M_framework__approx Variables Type Attributes Name Initial doubleprecision :: a real :: acurcy real :: acurcy1 real :: acurcy2 doubleprecision :: b integer :: digi integer :: i10 integer :: i20 integer :: i30 integer :: ind integer :: ind1 integer :: ind2 doubleprecision :: vals (9) Source Code program demo_accdig ! fortran 90 example use M_framework__approx , only : accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1.234680d0 , 1.2345378d0 , 2.2234568d0 , 1.2345678d0 , & & 1.2345679d0 , - 1.2345678d0 , 7 6.234567d0 , 2.4691356d0 , & & 0.0d0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i10 ) call accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i20 ) call accdig ( a , b , dble ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call accdig ( 1.2345678d0 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ), 1.2345678d0 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig","tags":"","url":"program/demo_accdig.html"},{"title":"bookkeeper – M_framework","text":"Uses M_framework iso_fortran_env Variables Type Attributes Name Initial integer(kind=int64) :: clicks integer :: clicksfile character(len=:), allocatable :: color character(len=1), parameter :: comma = ',' integer :: csvfile character(len=25) :: date character(len=*), parameter :: g = '(*(g0,1x))' character(len=*), parameter :: g0 = '(*(g0))' logical :: help character(len=:), allocatable :: html_footer (:) character(len=:), allocatable :: html_header (:) integer :: htmlfile integer :: i logical :: intable = .true. character(len=:), allocatable :: msg character(len=:), allocatable :: name integer :: nmlfile character(len=:), allocatable :: passed character(len=1), parameter :: quote = '\"' character(len=:), allocatable :: type logical :: verbose logical :: version Interfaces interface exists function fileexists (filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical function unitexists (lun) result(r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Functions function fileexists (filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical function here_and_now () Arguments None Return Value character(len=25) function unitexists (lun) result(r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Subroutines subroutine cmdline_ () Arguments None subroutine get_html_header () Arguments None subroutine header () Arguments None subroutine printhelp () Arguments None subroutine printversion () Arguments None Namelists Namelist args Variables Name Type Default Description type character(len=:) None Namelist args Variables Name Type Default Description name character(len=:) None Namelist args Variables Name Type Default Description passed character(len=:) None Namelist args Variables Name Type Default Description msg character(len=:) None Namelist args Variables Name Type Default Description date character(len=1) None Namelist args Variables Name Type Default Description clicks integer(kind=int64) None Namelist long Variables Name Type Default Description help logical None Namelist long Variables Name Type Default Description version logical None Namelist long Variables Name Type Default Description verbose logical None Source Code program bookkeeper ! example program that can parse arguments given to optional unit_test command !  o writing a CSV file to be read into spread sheets, SQLite3, .... !  o writing a HTML document !  o writing a NAMELIST group file for post-processing into formats like a TAP (Test Anything Protocol) document use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_framework , only : wrt , str ! put something here into namelist and it becomes an argument character ( len = :), allocatable :: type ; namelist / args / type , / long / type character ( len = :), allocatable :: name ; namelist / args / name , / long / name character ( len = :), allocatable :: passed ; namelist / args / passed , / long / passed character ( len = :), allocatable :: msg ; namelist / args / msg , / long / msg character ( len = 25 ) :: date ; namelist / args / date , / long / date integer ( kind = int64 ) :: clicks ; namelist / args / clicks , / long / clicks logical :: help ; namelist / long / help logical :: version ; namelist / long / version logical :: verbose ; namelist / long / verbose !integer                      :: level = -1         ; namelist /args/ level !integer,allocatable          :: flags(:)           ; namelist /args/ flags character ( len = :), allocatable :: html_header (:), html_footer (:) character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: g0 = '(*(g0))' character ( len = 1 ), parameter :: comma = ',' , quote = '\"' character ( len = :), allocatable :: color logical :: intable = . true . integer :: i integer :: htmlfile , csvfile , clicksfile , nmlfile interface exists ! for backward compatibility, accdig(3f) preferred procedure fileexists procedure unitexists end interface exists !SETUP ! This is an example program. A simple kludge is to pick scratch output or file output ! to work with just one output. Not something to do in production code. open ( newunit = htmlfile , file = 'bookkeeper.html' , position = 'append' ) !open(newunit=htmlfile,position='append',status='scratch') open ( newunit = csvfile , file = 'bookkeeper.csv' , position = 'append' , DELIM = 'quote' , form = 'formatted' ) !open(newunit=csvfile,position='append',DELIM='quote',form='formatted',status='scratch') open ( newunit = clicksfile , file = 'bookkeeper_clicks.csv' , position = 'append' ) !open(newunit=clicksfile,position='append',status='scratch') open ( newunit = nmlfile , file = 'bookkeeper.nml' , position = 'append' ) !open(newunit=nmlfile,position='append',status='scratch') call header () verbose = . false . type = repeat ( ' ' , 4096 ) name = repeat ( ' ' , 4096 ) passed = repeat ( ' ' , 4096 ) msg = repeat ( ' ' , 4096 ) !intable=.false. date = here_and_now () clicks =- 1 !   flags = [(-1, i=1, 1000)] !PARSE call cmdline_ () !TEARDOWN type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) !   flags = pack(flags, flags  /=  -1) !USE write ( nmlfile , nml = args ) ! cannot do advance='no' select case ( passed ) case ( \"untested\" ); color = 'yellow' case ( \"passed\" ) ; color = '#9F9' case ( \"failed\" ) ; color = 'red' case default ; color = 'white' end select select case ( type ) case ( \"start\" ) !intable=.true. write ( htmlfile , g0 ) '<table id=\"' , name , '\">' write ( htmlfile , g0 ) '<caption class=\"caption\" style=\"text-align:left\">' , name , str ( ' -' , if = msg . ne . '' ), ' ' , msg , '</caption>' write ( htmlfile , g0 ) '<tbody>' write ( htmlfile , g0 ) '<tr class=\"header\" class=\"odd\"><!-- start -->' write ( htmlfile , g0 ) ' <th style=\"width:25%;text-align:center;\"> name   </th>' write ( htmlfile , g0 ) ' <th style=\"width:10%;text-align:center;\"> passed </th>' write ( htmlfile , g0 ) ' <th style=\"width:40%;text-align:center;\"> msg    </th>' write ( htmlfile , g0 ) ' <th style=\"width:25%;text-align:center;\"> date   </th>' write ( htmlfile , g0 ) '</tr>' case ( \"check\" ) write ( csvfile , g0 ) quote , name , quote , comma , quote , here_and_now (), quote , comma , quote , passed , quote , comma , quote , msg , quote write ( htmlfile , g0 ) '<tr class=\"' , passed , '\" class=\"even\"><!-- check -->' write ( htmlfile , g0 ) ' <td >' , name , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\" bgcolor=\"' , color , '\">' , passed , ' </td>' write ( htmlfile , g0 ) ' <td >' , msg , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\">' , date , ' </td>' write ( htmlfile , g0 ) '</tr>' case ( \"message\" ) if ( intable ) then write ( htmlfile , g0 ) '<tr class=\"message\"><!-- message -->' write ( htmlfile , g0 ) '<td colspan=\"4\" bgcolor=\"#AAF\" style=\"text-align:center;\">' , msg , '</td>' write ( htmlfile , g0 ) '</tr>' else !write(htmlfile,g0)msg endif case ( \"end\" ) !intable=.false. if ( passed . eq . 'untested' ) then write ( csvfile , g0 ) quote , name , quote , comma , quote , here_and_now (), quote , comma , quote , passed , quote , comma , quote , msg , quote write ( htmlfile , g0 ) '<tr class=\"' , passed , '\" class=\"odd\"><!-- end -->' write ( htmlfile , g0 ) ' <td >' , name , ' </td>' write ( htmlfile , g0 ) ' <td bgcolor=\"' , color , '\" style=\"text-align:center;\">' , passed , ' </td>' write ( htmlfile , g0 ) ' <td >' , msg , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\">' , date , ' </td>' write ( htmlfile , g0 ) '</tr>' endif if ( clicks . ne . 0 ) then write ( htmlfile , g0 ) '<tr class=\"clicks\" class=\"' , passed , '\"><!-- clicks -->' write ( htmlfile , g0 ) '<td colspan=\"4\" bgcolor=\"#AAF\" style=\"text-align:center;\"> clicks:' , clicks , ' for ' , name , '</td>' write ( htmlfile , g0 ) '</tr>' endif write ( htmlfile , g0 ) '</table>' write ( clicksfile , g0 ) quote , name , quote , comma , & quote , here_and_now (), quote , comma , & quote , clicks , quote , comma , & quote , msg , quote case ( \"stop\" ) !intable=.false. write ( htmlfile , g0 ) '<!-- STOP -->' end select contains subroutine cmdline_ () ! read arguments from command line as NAMELIST group input character ( len = 4096 ), save :: input ( 3 ) = [ character ( len = 4096 ) :: '&long' , '' , ' /' ], arg character ( len = 256 ) :: message1 , message2 integer :: i , j , ios , equal_pos , iend help = . false . version = . false . do i = 1 , command_argument_count () call get_command_argument ( i , arg ) do j = 1 , len_trim ( arg ) ! blank out leading - or / so \"--name=value\" or \"/name=value\" works if ( index ( '/- ' , arg ( j : j )) == 0 ) exit arg ( j : j ) = ' ' enddo arg = ' ' // adjustl ( arg ) if ( index ( arg , '=' ) == 0 ) arg = trim ( arg ) // '=T' ! if no equal sign add =T iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message1 ) if ( ios /= 0 ) then ! assume first failure might be because of missing quotes equal_pos = index ( arg , '=' ) ! find position of '=' if ( equal_pos /= 0 ) then ! requote and try again arg = arg (: equal_pos ) // '\"' // arg ( equal_pos + 1 : len_trim ( arg )) // '\"' iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message2 ) if ( ios /= 0 ) then write ( stderr , g ) 'BOOKKEEPER:ERROR UNQUOTED:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) if ( message1 . ne . message2 ) write ( stderr , g ) 'BOOKKEEPER:ERROR QUOTED  :' , trim ( message2 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( * , nml = long , delim = 'quote' ) stop 2 endif else write ( stderr , g ) 'ERROR:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( stderr , nml = long , delim = 'quote' ) stop 4 endif endif enddo if ( help ) call printhelp () if ( version ) call printversion () end subroutine cmdline_ subroutine printhelp () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& 'NAME                                                                            ' ,& '    bookkeeper-(1f) - example filter program callable from the M_framework(3f)  ' ,& '    unit testing harness.                                                       ' ,& '    (LICENSE:PD)                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' commands:                                                                      ' ,& '                                                                                ' ,& '     bookkeeper [help| version]                                                 ' ,& '     bookkeeper type=\"start\" name=\"NAME\" msg=\"MESSAGE TEXT\" [opts]              ' ,& '     bookkeeper type=\"check\" name=\"NAME\" msg=\"MESSAGE TEXT\" ...                 ' ,& '                passed=\"passed|failed\"                                          ' ,& '     bookkeeper type=\"end\" name=\"NAME\" msg=\"MESSAGE TEXT\" clicks=N ...          ' ,& '                [passed=\"failed|passed|untested\"]                               ' ,& '     bookkeeper type=\"stop\" name=\"NAME\" msg=\"MESSAGE TEXT\"                      ' ,& '                [passed=\"failed|passed|untested\"] clicks=M                      ' ,& '     bookkeeper type=\"message\" name=\"NAME\" msg=\"MESSAGE TEXT\"                   ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& ' This is an example program that shows how to create an external program that   ' ,& ' can be called by the testing harness in the M_framework__verify(3f) module     ' ,& ' for custom processing. Data is based in the form of NAMELIST group data        ' ,& ' for the NAMELIST group                                                         ' ,& '                                                                                ' ,& '     character(len=:),allocatable :: type                                       ' ,& '     character(len=:),allocatable :: name                                       ' ,& '     character(len=:),allocatable :: passed                                     ' ,& '     character(len=:),allocatable :: msg                                        ' ,& '     character(len=25)            :: date                                       ' ,& '     integer(kind=int64)          :: clicks                                     ' ,& '     logical                      :: help                                       ' ,& '     logical                      :: version                                    ' ,& '                                                                                ' ,& ' The data conforms to the Fortran NAMELIST group input syntax with the          ' ,& ' delimiter set to a double-quote except extraneous spaces are not allowed,      ' ,& ' and names may optionally be preceded by \" --\" or \" /\" and if no equal          ' ,& ' appears after a keyword \"=T\" is assumed to appear more like typical            ' ,& ' Unix long options or MSWindows commands. So these would all be                 ' ,& ' equivalent:                                                                    ' ,& '                                                                                ' ,& '      bookkeeper type=\"end\" msg=\"message text\"                                  ' ,& '      bookkeeper /type=\"end\" /msg=\"message text\"                                ' ,& '      bookkeeper --type=\"end\" --msg=\"message text\"                              ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    type     \"start\",\"check\",\"end\",\"stop\",\"message\"                             ' ,& '    name     a label, typically the name of the procedure that was tested.      ' ,& '    passed   \"passed\",\"failed\",\"untested\"                                       ' ,& '    msg      a description of the test, or a descriptive message                ' ,& '    date     YYYY-MM-DDTHH:MM:SS-HH:MM                                          ' ,& '    clicks   for type=\"end\" assumed to be the time in clicks since the          ' ,& '             previous type=\"start\"                                              ' ,& '    silent|brief|verbose   silent produces no output from unit_check_* routines ' ,& '                           brief only shows failed tests, verbose shows all     ' ,& '                           messages including compiler and options.             ' ,& '    help     display this help and exit                                         ' ,& '    version  output version information and exit                                ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '    Sample commands                                                             ' ,& '                                                                                ' ,& '       fpm test -- command=bookkeeper                                           ' ,& '       fpm test --target=''time*'' -- command=bookkeeper luns=6                   ' ,& '                                                                                ' ,& '                                                                                ' ,& 'SEE ALSO                                                                        ' ,& '    M_framework(3f), unit_test(3f), unit_test_mode(3f)                          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printhelp subroutine printversion () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& '                                                                                ' ,& 'PRODUCT:        Fortran Unit Testing Harness                                    ' ,& 'PROGRAM:        bookkeeper(1)                                                   ' ,& 'DESCRIPTION:    filter data from M_framework(3f) Unit Testing Framework         ' ,& 'VERSION:        1.0, 20230507                                                   ' ,& 'AUTHOR:         John S. Urban                                                   ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                            ' ,& 'HOME PAGE:      https://github.com/urbanjost/M_framework                        ' ,& 'LICENSE:        Public Domain. This is free software: you are free to change    ' ,& '                and redistribute it. There is NO WARRANTY,                      ' ,& '                to the extent permitted by law.                                 ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printversion function here_and_now () ! 2023-05-01 23:05:12 UTC-0400 character :: date * ( 8 ), time * ( 10 ), zone * ( 5 ) character ( len = 25 ) :: here_and_now call date_and_time ( DATE = date , TIME = time , ZONE = zone ) !write(here_and_now,'(*(g0))')date(1:4),'-',date(5:6),'-',date(7:8),' ',time(1:2),':',time(3:4),':',time(5:6),' UTC',zone ! rfc-3339\"   ==> %Y-%M-%DT%h:%m:%s%z  2023-05-02T18:40:25-04:00; except ZONE is in write ( here_and_now , '(*(g0))' )& & date ( 1 : 4 ), '-' , date ( 5 : 6 ), '-' , date ( 7 : 8 ), 'T' , time ( 1 : 2 ), ':' , time ( 3 : 4 ), ':' , time ( 5 : 6 ), zone ( 1 : 3 ), ':' , zone ( 4 : 5 ) end function here_and_now logical function fileexists ( filename ) result ( r ) character ( len =* ), intent ( in ) :: filename integer :: size inquire ( file = filename , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function fileexists logical function unitexists ( lun ) result ( r ) integer , intent ( in ) :: lun integer :: size inquire ( unit = lun , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function unitexists subroutine header () if ( . not . exists ( 'bookkeeper.csv' ) ) then write ( csvfile , g0 ) '\"name\",\"date\",\"passed\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.html' ) ) then call get_html_header () write ( htmlfile , '(a)' )( trim ( html_header ( i )), i = 1 , size ( html_header )) endif if ( . not . exists ( 'bookkeeper_clicks.csv' ) ) then write ( clicksfile , g0 ) '\"name\",\"date\",\"clicks\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.nml' ) ) then write ( nmlfile , g0 ) ' Fortran NAMELIST group file containing test results' write ( nmlfile , g0 ) ' that may be read with a simple program and used to' write ( nmlfile , g0 ) ' generate reports in other formats.' write ( nmlfile , g0 ) ' ' endif end subroutine header subroutine get_html_header () html_header = [ CHARACTER ( LEN = 128 ) :: & '<html>' ,& '<head>' ,& '<title>unit_test_results</title>' ,& '<style>        ' ,& 'body {xfont-style: italic}' ,& 'body {                    ' ,& 'background-color:#FFF; color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }' ,& 'a:visited { color:#666; }                                                                                                ' ,& 'h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }                                              ' ,& 'h1 { font-size:200%; }                                                                                                   ' ,& 'h2 { font-size:173%; }                                                                                                   ' ,& 'h3 { font-size:144%; }                                                                                                   ' ,& 'h4 { font-size:120%; }                                                                                                   ' ,& 'h5,h6 { font-size:100% }                                                                                                 ' ,& 'a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }                                                   ' ,& '/*                                                                                                                       ' ,& 'td { border:thin solid #888; word-break: break-all; width: 1em}                                                          ' ,& '*/                                                                                                                       ' ,& 'td { border:thin solid #888; overflow-wrap: break-word; }                                                                ' ,& 'li { margin-bottom:0.5em; }                                                                                              ' ,& 'blockquote { display:block; font-size:90%; font-style:italic; line-height:1.5em; margin:0 0 1.5em; padding:0 2.5em; }    ' ,& 'pre { background-color:#DDD; font-size:90%; overflow:auto; padding:1em; }                                                ' ,& 'a,li span { color:#000; }                                                                                                ' ,& 'a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }                                                ' ,& '#Container { margin:0 10px; text-align:center; }                                                                         ' ,& '#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:58em; }                   ' ,& 'span.webName { font-size:.5em; }                                                                                         ' ,& 'textarea#content { font-size: 1em; line-height: 1.125em; }                                                               ' ,& 'h1#pageName { line-height:1.4em; margin:0.2em 0 0.2em 0; padding:0; }                                                    ' ,& 'h2{ line-height:1.2em; margin:0.2em 0 0.2em 0; padding:0; color:blue;}                                                   ' ,& '.property { color:#666; font-size:80%; }                                                                                 ' ,& 'a.existingWikiWord[title]{ //border: 1px dashed #BBB; }                                                                  ' ,& '.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; }                           ' ,& '/* table takes its dimensions from the <table> element width and                                                         ' ,& 'the width of the first row of cells (or the <col> elements, if you have them).*/                                         ' ,& 'table { table-layout: fixed ; width: 100% ; border:double #000; border-collapse:collapse; }                              ' ,& 'td { width: 25% ; }                                                                                                      ' ,& 'table#unit_test { table-layout: fixed ; width: 100% ; border-collapse: collapse ; border: 1px black solid ; }            ' ,& 'table#unit_test td { width: 25% ; border: 1px black solid ; padding: 10px ; }                                            ' ,& 'table#unit_test caption { font-style: italic ; font-weight: 600; color: gray;}                                           ' ,& '/*                                                                                                                       ' ,& 'col:nth-child(even) {background: #FFF}                                                                                   ' ,& 'col:nth-child(odd) {background: #CCC}                                                                                    ' ,& '*/                                                                                                                       ' ,& 'tr:nth-child(even) {background: #CCC}                                                                                    ' ,& 'tr:nth-child(odd) {background: #FFF}                                                                                     ' ,& '</style>                                                                                                                 ' ,& '<script language=\"JavaScript1.1\" type=\"text/javascript\">                                                                 ' ,& '//<![CDATA[                                                                                                              ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of class                                                                                    ' ,& '   function toggleHiddenClass(objectClassName) {                                                                         ' ,& '                                                                                                                         ' ,& '      const collection = document.getElementsByClassName(objectClassName);                                               ' ,& '                                                                                                                         ' ,& '      for (let i = 0; i < collection.length; i++) {                                                                      ' ,& '         if(collection[i].style.display == \"none\" ) {                                                                    ' ,& '            collection[i].style.display = \"\";                                                                            ' ,& '         }else{                                                                                                          ' ,& '            collection[i].style.display = \"none\";                                                                        ' ,& '         }                                                                                                               ' ,& '      }                                                                                                                  ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   //alert(\"A1\");                                                                                                        ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of id                                                                                       ' ,& '   function toggleHiddenId(objectIdName) {                                                                               ' ,& '      var TARGET = document.getElementById(objectIdName);                                                                ' ,& '      if(TARGET.style.display == \"none\" ) {                                                                              ' ,& '         TARGET.style.display = \"\";                                                                                      ' ,& '      }else{                                                                                                             ' ,& '         TARGET.style.display = \"none\";                                                                                  ' ,& '      }                                                                                                                  ' ,& '   //alert(TARGET.style.display);                                                                                        ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '</script>                                                                                                                ' ,& '<p>                                                                                                                      ' ,& '   <form>                                                                                                                ' ,& '      <input  type=\"button\"  value=\"passed\"   onclick=\"toggleHiddenClass(''passed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"failed\"   onclick=\"toggleHiddenClass(''failed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"untested\" onclick=\"toggleHiddenClass(''untested'');\" />                              ' ,& '      <input  type=\"button\"  value=\"clicks\"   onclick=\"toggleHiddenClass(''clicks'');\" />                                ' ,& '      <input  type=\"button\"  value=\"message\"  onclick=\"toggleHiddenClass(''message'');\" />                               ' ,& '      <input  type=\"button\"  value=\"caption\"  onclick=\"toggleHiddenClass(''caption'');\" />                               ' ,& '      <input  type=\"button\"  value=\"header\"   onclick=\"toggleHiddenClass(''header'');\" />                                ' ,& '  </form>                                                                                                                ' ,& '</p>                                                                                                                     ' ,& '</head>                                                                                                                  ' ,& '<body>                                                                                                                   ' ,& '<div id=\"Container\">                                                                                                     ' ,& '<div id=\"Content\">                                                                                                       ' ,& '' ] html_footer = [ CHARACTER ( LEN = 128 ) :: & '</div>' ,& '</div>' ,& '</body>' ,& '</html>' ,& '' ] end subroutine get_html_header end program bookkeeper","tags":"","url":"program/bookkeeper.html"},{"title":"demo_compare_float – M_framework","text":"Uses M_framework__approx iso_fortran_env Variables Type Attributes Name Initial real(kind=wp) :: a (10) integer :: i character(len=80), save :: line = '10*0.1' real(kind=wp) :: ulp integer, parameter :: wp = int32 real(kind=wp) :: x real(kind=wp) :: y Source Code program demo_compare_float use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use M_framework__approx , only : compare_float use M_framework__approx , only : & & operator (. equalto .), operator (. greaterthan .), operator (. lessthan .) implicit none integer , parameter :: wp = int32 integer :: i character ( len = 80 ), save :: line = '10*0.1' real ( kind = wp ) :: a ( 10 ), x , y , ulp write ( * , * ) 'is 10*0.1 == 1.0?' ! sum up 0.1 ten times hopefully in a manner compiler does not ! optimize it and in the process make it equal a = 0.1_wp read ( line , * ) a x = sum ( a ) y = 1.0_wp write ( * , * ) merge ( '    EQUAL ' , 'NOT EQUAL!' , x . eq . y ) write ( * , '(*(g0,1x,z0,1x))' ) x , x , y , y ! show decimal and hexadecimal value write ( * , * ) 'regular' , x . eq . y , x . gt . y , x . lt . y ! standard operators ! For the default ULP=1.0, the relational operators can be used write ( * , * ) 'compare' , x . equalto . y , x . greaterthan . y , x . lessthan . y do i = 0 , 10 ulp = real ( i , kind = wp ) / 2.0 write ( * , * ) i , compare_float ( x , y , ulp = ulp ) , 'ULP=' , ulp enddo end program demo_compare_float","tags":"","url":"program/demo_compare_float.html"},{"title":"demo_unit_test_mode – M_framework","text":"Uses M_framework Source Code program demo_unit_test_mode use M_framework implicit none call unit_test_mode ( keep_going = . false ., luns = [ 6 ], & & brief = . true .) end program demo_unit_test_mode","tags":"","url":"program/demo_unit_test_mode.html"},{"title":"  vals – M_framework\n","text":"Variables Name Type Default Description clock type( timer ) None","tags":"","url":"namelist/vals.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_match character(len=:) None","tags":"","url":"namelist/args.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_level integer None","tags":"","url":"namelist/args~2.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_debug logical .false.","tags":"","url":"namelist/args~3.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_flags integer None","tags":"","url":"namelist/args~4.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_keep_going logical .false.","tags":"","url":"namelist/args~5.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_command character(len=:) None","tags":"","url":"namelist/args~6.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_brief logical .false.","tags":"","url":"namelist/args~7.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_luns integer None","tags":"","url":"namelist/args~8.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_interactive logical .false.","tags":"","url":"namelist/args~9.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_help logical .false.","tags":"","url":"namelist/args~10.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_verbose logical .false.","tags":"","url":"namelist/args~11.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description G_silent logical .false.","tags":"","url":"namelist/args~12.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description a real(kind=real32) None","tags":"","url":"namelist/all.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description b real(kind=real64) None","tags":"","url":"namelist/all~2.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description c real(kind=real128) None","tags":"","url":"namelist/all~3.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description i integer(kind=int8) None","tags":"","url":"namelist/all~4.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description j integer(kind=int16) None","tags":"","url":"namelist/all~5.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description k integer(kind=int32) None","tags":"","url":"namelist/all~6.html"},{"title":"  all – M_framework\n","text":"Variables Name Type Default Description l integer(kind=int64) None","tags":"","url":"namelist/all~7.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description level integer 0","tags":"","url":"namelist/args~13.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description compiler character(len=80) ''","tags":"","url":"namelist/args~14.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description profile character(len=80) ''","tags":"","url":"namelist/args~15.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description link_flag character(len=80) ''","tags":"","url":"namelist/args~16.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description flag character(len=80) ''","tags":"","url":"namelist/args~17.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description cxx_flag character(len=80) ''","tags":"","url":"namelist/args~18.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description cxx_compiler character(len=80) ''","tags":"","url":"namelist/args~19.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description c_flag character(len=80) ''","tags":"","url":"namelist/args~20.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description c_compiler character(len=80) ''","tags":"","url":"namelist/args~21.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description archiver character(len=80) ''","tags":"","url":"namelist/args~22.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description type character(len=:) None","tags":"","url":"namelist/args~23.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description name character(len=:) None","tags":"","url":"namelist/args~24.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description passed character(len=:) None","tags":"","url":"namelist/args~25.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description msg character(len=:) None","tags":"","url":"namelist/args~26.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description date character(len=1) None","tags":"","url":"namelist/args~27.html"},{"title":"  args – M_framework\n","text":"Variables Name Type Default Description clicks integer(kind=int64) None","tags":"","url":"namelist/args~28.html"},{"title":"  long – M_framework\n","text":"Variables Name Type Default Description help logical None","tags":"","url":"namelist/long.html"},{"title":"  long – M_framework\n","text":"Variables Name Type Default Description version logical None","tags":"","url":"namelist/long~2.html"},{"title":"  long – M_framework\n","text":"Variables Name Type Default Description verbose logical None","tags":"","url":"namelist/long~3.html"},{"title":"demo_M_framework__verify.f90 – M_framework","text":"program demo_M_framework__verify Source Code !! program demo_M_framework__verify module M_framework__verify_demo private public one ! some regular routine public two ! some regular routine contains subroutine one ( array ) integer , intent ( out ), allocatable :: array (:) array = [ 21 , 51 , 14 , 45 ] end subroutine one subroutine two ( array ) integer , intent ( inout ), allocatable :: array (:) array = 2 * array end subroutine two end module M_framework__verify_demo program demo_M_framework__verify use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_msg , unit_test_stop , & & unit_test_system , unit_test_mode use M_framework__verify_demo , only : one , two ! set-up call unit_test_mode ( command = '' , flags = [ 0 ], keep_going = . true .) ! call a test procedure for each routine to test call test_one () call test_two () ! tear-down call unit_test_stop () contains subroutine test_one () integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 21 , 51 , 14 , 45 ] call unit_test_start ( 'one' ) call one ( results ) call unit_test ( 'one' , all ( expected > 0 ), & & 'testing if everyone greater than zero' ) call unit_test ( 'one' , all ( expected == results ), & & 'testing if all values are expected' ) call unit_test_end ( 'one' , 'checks on \"one\" ended' ) end subroutine test_one subroutine test_two integer , allocatable :: results (:) integer , parameter :: expected ( * ) = [ 2 , 20 , 200 ] results = [ 1 , 10 , 100 ] call two ( results ) call unit_test_start ( 'two' , 'check procedure \"two\" ' ) call unit_test ( 'two' , all ( expected == results ) . and . & & all ( expected > 0 ) . and . maxval ( expected ) < 201 , msg = 'long expression' ) call unit_test_end ( 'two' , 'checks on \"two\" ended' ) end subroutine test_two end program demo_M_framework__verify","tags":"","url":"sourcefile/demo_m_framework__verify.f90.html"},{"title":"M_framework__timing.f90 – M_framework","text":"Source Code module M_framework__timing use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT implicit none private type timer real ( real64 ) :: cpu_start real ( real64 ) :: cpu_end integer ( int64 ) :: clock_start integer ( int64 ) :: clock_end contains procedure :: tic => clock_tic procedure :: toc => clock_toc procedure :: print => clock_print procedure :: wallclock => clock_wallclock procedure :: cputime => clock_cputime end type interface timer procedure :: clock_new end interface timer public :: timer character ( len =* ), parameter :: gen = '(*(g0,1x))' contains ! initialization constructor type ( timer ) function clock_new ( this ) type ( timer ), intent ( in ), optional :: this call cpu_time ( clock_new % cpu_start ) call system_clock ( clock_new % clock_start ) clock_new % cpu_end = clock_new % cpu_start clock_new % clock_end = clock_new % clock_start end function clock_new subroutine clock_tic ( this ) class ( timer ) :: this call cpu_time ( this % cpu_start ) call system_clock ( this % clock_start ) this % cpu_end = this % cpu_start this % clock_end = this % clock_start end subroutine clock_tic subroutine clock_toc ( this ) class ( timer ) :: this call cpu_time ( this % cpu_end ) call system_clock ( this % clock_end ) end subroutine clock_toc subroutine clock_print ( this , string , lun ) class ( timer ), intent ( in ) :: this character ( len =* ), intent ( in ), optional :: string integer ( kind = int64 ), intent ( in ), optional :: lun integer ( kind = int64 ) :: count_rate integer ( kind = int64 ) :: lun_ real :: elapsed_time real :: cpu_time if ( present ( lun )) then lun_ = lun else lun_ = stdout endif elapsed_time = this % wallclock () cpu_time = this % cputime () if ( present ( string )) then write ( lun_ , gen , advance = 'no' ) string write ( lun_ , gen , advance = 'no' ) 'Elapsed time (sec) ::' , elapsed_time , ',' write ( lun_ , gen , advance = 'no' ) 'CPU time (sec) ::' , cpu_time , ',' write ( lun_ , '(a,1x,f0.2)' , advance = 'yes' ) 'Percentage ::' , ( cpu_time / elapsed_time ) * 10 0.0 else write ( lun_ , gen ) 'Elapsed time (sec) ::' , elapsed_time write ( lun_ , gen ) 'CPU time     (sec) ::' , cpu_time write ( lun_ , '(a,1x,f0.2)' ) 'Percentage         ::' ,( cpu_time / elapsed_time ) * 100 endif end subroutine clock_print function clock_wallclock ( this ) result ( elapsed_time ) class ( timer ) :: this integer ( kind = int64 ) :: count_rate real :: elapsed_time real :: cpu_time call system_clock ( count_rate = count_rate ) ! Find the time rate elapsed_time = real ( this % clock_end - this % clock_start ) / real ( count_rate ) end function clock_wallclock function clock_cputime ( this ) result ( cpu_time ) class ( timer ) :: this real :: cpu_time cpu_time = real ( this % cpu_end - this % cpu_start ) end function clock_cputime end module M_framework__timing","tags":"","url":"sourcefile/m_framework__timing.f90.html"},{"title":"demo_fstop.f90 – M_framework","text":"Source Code program demo_fstop use M_framework__utility , only : fstop implicit none integer :: int !*!write(*,*)'Enter stop value' !*!read(*,*) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = 'error: program will now stop' ) case ( 25 ) ; call fstop ( int , stdout = 'stdout message' , & & stderr = 'stderr message' ) case ( 30 ) ; call fstop ( int , stdout = 'error: program will now stop' ) case default call fstop ( int ) endselect end program demo_fstop","tags":"","url":"sourcefile/demo_fstop.f90.html"},{"title":"fid.f90 – M_framework","text":"Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"sourcefile/fid.f90.html"},{"title":"test_suite_M_framework__verify.f90 – M_framework","text":"Source Code program runtest use M_framework__verify , only : unit_test , unit_test_bad , unit_test_end , unit_test_good , unit_test_start , unit_test_stop call test_unit_test_start () call test_unit_test () call test_unit_test_end () call test_unit_test_bad () call test_unit_test_good () call test_unit_test_stop () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_start () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_unit_test_start !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test () call unit_test_start ( 'unit_test' , msg = '' ) !      call unit_test('unit_test', .true.,'expression is true') !      call unit_test('unit_test', .false.,'expression is false') call unit_test_end ( 'unit_test' , msg = '' ) end subroutine test_unit_test !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_end () call unit_test_start ( 'unit_test_end' , msg = '' ) !      call unit_test('unit_test_end', .true.,'expression is true') !      call unit_test('unit_test_end', .false.,'expression is false') call unit_test_end ( 'unit_test_end' , msg = '' ) end subroutine test_unit_test_end !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_bad () call unit_test_start ( 'unit_test_bad' , msg = '' ) !      call unit_test('unit_test_bad', .true.,'expression is true') !      call unit_test('unit_test_bad', .false.,'expression is false') call unit_test_end ( 'unit_test_bad' , msg = '' ) end subroutine test_unit_test_bad !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_good () call unit_test_start ( 'unit_test_good' , msg = '' ) !      call unit_test('unit_test_good', .true.,'expression is true') !      call unit_test('unit_test_good', .false.,'expression is false') call unit_test_end ( 'unit_test_good' , msg = '' ) end subroutine test_unit_test_good !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unit_test_stop () call unit_test_start ( 'unit_test_stop' , msg = '' ) !      call unit_test_stop('unit_test_stop', .true.,'expression is true') !      call unit_test_stop('unit_test_stop', .false.,'expression is false') call unit_test_end ( 'unit_test_stop' , msg = '' ) end subroutine test_unit_test_stop !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","url":"sourcefile/test_suite_m_framework__verify.f90.html"},{"title":"demo_str.f90 – M_framework","text":"Source Code program demo_str use M_framework__msg , only : str implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = str ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = str ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = str ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = str ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) ! +0 for gfortran-11 bug frmt = str ( '(*(i' , int ( log10 ( real ( biggest ))) + 0 , ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using str(3f) ! in an I/O statement is not recommended ! because if an error occurs str(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) str ( 'program will now stop' ) end program demo_str","tags":"","url":"sourcefile/demo_str.f90.html"},{"title":"test_suite_M_framework__timing.f90 – M_framework","text":"Source Code program demo_M_framework__timing use M_framework__timing implicit none integer , parameter :: dp = selected_real_kind ( 15 ) character ( len =* ), parameter :: gen = '(*(g0,1x))' type ( timer ) :: clock integer :: i , j real ( kind = dp ) :: x ( 10000 ) namelist / vals / clock clock = timer () write ( * , gen ) 'Before calls' write ( * , nml = vals ) write ( * , gen ) 'Initialize:TIC' call clock % tic () write ( * , nml = vals ) do j = 1 , 100000 x (:) = log ( 2 3. ) * [( i , i = 1 , 10000 )] end do write ( * , gen ) ':TOC:' call clock % toc () write ( * , gen ) 'CPU TIME = ' , clock % cputime () write ( * , nml = vals ) write ( * , gen ) 'Now measuring inside the loop...' write ( * , nml = vals ) call clock % tic () do j = 1 , 100000 x (:) = log ( 2 3. ) * [( i , i = 1 , 10000 )] if ( j == 5000 ) then call clock % toc () write ( * , gen ) 'CPU TIME NOW (without pausing) = ' , clock % cputime () write ( * , nml = vals ) endif end do call clock % toc () call clock % print () write ( * , * ) clock write ( * , nml = vals ) end program demo_M_framework__timing","tags":"","url":"sourcefile/test_suite_m_framework__timing.f90.html"},{"title":"demo_M_framework__journal.f90 – M_framework","text":"Source Code program demo_journal !! showing creating debug messages use M_framework__journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , '*demo* DEBUG MESSAGE 001 IGNORED' ) !! turn on debug messages call journal ( '>' , 'debug on' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 002 ON STDOUT' ) !! open trail file call journal ( 'O' , 'mytrail.txt' ) !! debug messages now go to the trail file only call journal ( 'D' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! or always to stdout and trail file only if on call journal ( 'DS' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! close trail file so messages go only to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , '*demo* DEBUG MESSAGE 004 TO STDOUT' ) !! turn off debug messages call journal ( '<' , 'debug off' ) !! back to no output from the next message call journal ( 'D' , '*demo* DEBUG MESSAGE 005 IGNORED' ) end program demo_journal","tags":"","url":"sourcefile/demo_m_framework__journal.f90.html"},{"title":"test_suite_M_framework__journal.f90 – M_framework","text":"Source Code !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT program runtest use M_framework__msg use M_framework__verify use M_framework__journal use M_framework__approx implicit none !! setup call test_flush_trail () call test_set_stdout_lun () call test_where_write_message_all () call test_write_message_only () call unit_test_stop () !! teardown !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_flush_trail () implicit none call unit_test_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_test('flush_trail', 0.eq.0, 'checking',100) call unit_test_end ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_set_stdout_lun () implicit none call unit_test_start ( 'set_stdout_lun' , msg = '' ) !!call unit_test('set_stdout_lun', 0.eq.0, 'checking',100) call unit_test_end ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_where_write_message_all () implicit none call unit_test_start ( 'where_write_message_all' , msg = '' ) !!call unit_test('where_write_message_all', 0.eq.0, 'checking',100) call unit_test_end ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_write_message_only () implicit none call unit_test_start ( 'write_message_only' , msg = '' ) !!call unit_test('write_message_only', 0.eq.0, 'checking',100) call unit_test_end ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"sourcefile/test_suite_m_framework__journal.f90.html"},{"title":"demo_almost.f90 – M_framework","text":"Source Code program demo_almost use M_framework__approx , only : almost implicit none real :: x , y logical :: z integer :: i x = 1.2345678 y = 1.2300000 do i = 1 , 8 z = almost ( x , y , i , verbose = . true .) write ( * , * ) i , z enddo end program demo_almost","tags":"","url":"sourcefile/demo_almost.f90.html"},{"title":"test_compare_float.f90 – M_framework","text":"Source Code program test_compare_float use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use M_framework use m_framework__verify , only : unit_test_start , unit_test , unit_test_done , unit_test_good , unit_test_bad , unit_test_msg , unit_test_mode use m_framework__verify , only : unit_test_stop , unit_test_level use m_framework__msg , only : str , fmt use m_framework__approx , only : compare_float , operator (. equalto .), operator (. lessthan .), operator (. greaterthan .) implicit none logical , parameter :: T = . true ., F = . false . integer , parameter :: nums = 5 character ( len =* ), parameter :: sfmt = 'es20.13' , dfmt = 'es27.20' real ( kind = real32 ), parameter :: single_number ( nums ) = & [ 1.234567890123456e-16_real32 , & 1.234567890123456e-01_real32 , & 1.234567890123456e+01_real32 , & 1.234567890123456e+16_real32 , & 1.0_real32 ] real ( kind = real64 ), parameter :: double_number ( nums ) = & [ 1.234567890123456e-16_real64 , & 1.234567890123456e-01_real64 , & 1.234567890123456e+01_real64 , & 1.234567890123456e+16_real64 , & 1.0_real64 ] real ( kind = real32 ), parameter :: sten = 1 0.0_real32 real ( kind = real64 ), parameter :: dten = 1 0.0_real64 integer :: i real ( kind = real32 ) :: x , y1 , y2 , y3 , y4 real ( kind = real64 ) :: xd , yd1 , yd2 , yd3 , yd4 call unit_test_mode ( level = 0 , luns = [ OUTPUT_UNIT ]) ! Scalar calls do i = 1 , nums x = single_number ( i ) y1 = nearest ( x , 1.0_real32 ) y2 = y1 - spacing ( x ) y3 = nearest ( x , - 1.0_real32 ) y4 = y3 + spacing ( x ) call test_compare_float_single () call test_equalto_single () call test_greaterthan_single () call test_lessthan_single () xd = double_number ( i ) yd1 = nearest ( xd , 1.0_real64 ) yd2 = yd1 - spacing ( xd ) yd3 = nearest ( xd , - 1.0_real64 ) yd4 = yd3 + spacing ( xd ) call test_compare_float_double () call test_equalto_double () call test_greaterthan_double () call test_lessthan_double () enddo call test_elemental_single () call test_elemental_double () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_compare_float_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float single' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( x , sfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( y1 , sfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( y2 , sfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( y3 , sfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( y4 , sfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , x . eq . y4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( x , y1 ), \"Compare_Float(x, y1)       = \" , compare_float ( x , y1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( x , y1 , ulp = 2 ), \"Compare_Float(x, y1,ulp=2) = \" , compare_float ( x , y1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( x , y2 ), \"Compare_Float(x, y2)       = \" , compare_float ( x , y2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( x , y3 ), \"Compare_Float(x, y3)       = \" , compare_float ( x , y3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( x , y3 , ulp = 2 ), \"Compare_Float(x, y3,ulp=2) = \" , compare_float ( x , y3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( x , y4 ), \"Compare_Float(x, y4)       = \" , compare_float ( x , y4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_compare_float_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'compare_float double' call unit_test_start ( title , msg = title ) call unit_test_msg ( title , \"    x  = \" , fmt ( xd , dfmt ) ) call unit_test_msg ( title , \"    y1 = \" , fmt ( yd1 , dfmt ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    y2 = \" , fmt ( yd2 , dfmt ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    y3 = \" , fmt ( yd3 , dfmt ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    y4 = \" , fmt ( yd4 , dfmt ), \":  y3 + SPACING( x )\" ) select case ( i ) case ( 1 ); expected = [ F , T , T , F , T , T ] case ( 2 ); expected = [ F , T , T , F , T , T ] case ( 3 ); expected = [ F , T , T , F , T , T ] case ( 4 ); expected = [ F , T , T , F , T , T ] case ( 5 ); expected = [ F , T , T , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 ), expected ( 5 ), expected ( 6 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ). eqv . compare_float ( xd , yd1 ), \"Compare_Float(xd, yd1)      =\" , compare_float ( xd , yd1 ), i ) call unit_test ( title , expected ( 2 ). eqv . compare_float ( xd , yd1 , ulp = 2 ), \"Compare_Float(xd, yd1,ulp=2)=\" , compare_float ( xd , yd1 , ulp = 2 ), i ) call unit_test ( title , expected ( 3 ). eqv . compare_float ( xd , yd2 ), \"Compare_Float(xd, yd2)      =\" , compare_float ( xd , yd2 ), i ) call unit_test ( title , expected ( 4 ). eqv . compare_float ( xd , yd3 ), \"Compare_Float(xd, yd3)      =\" , compare_float ( xd , yd3 ), i ) call unit_test ( title , expected ( 5 ). eqv . compare_float ( xd , yd3 , ulp = 2 ), \"Compare_Float(xd, yd3,ulp=2)=\" , compare_float ( xd , yd3 , ulp = 2 ), i ) call unit_test ( title , expected ( 6 ). eqv . compare_float ( xd , yd4 ), \"Compare_Float(xd, yd4)      =\" , compare_float ( xd , yd4 ), i ) call unit_test_end ( title , msg = '' ) end subroutine test_compare_float_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_elemental_single () real ( kind = real32 ), dimension ( nums ) :: xv , yv1 , yv2 , yv3 , yv4 real ( kind = real32 ), dimension ( nums , 2 ) :: xa , ya1 , ya2 , ya3 , ya4 character ( len = :), allocatable :: title title = 'equalto single' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xv = single_number yv1 = nearest ( xv , ( / ( 1.0_real32 , i = 1 , nums ) / ) ) yv2 = yv1 - spacing ( xv ) yv3 = nearest ( xv , ( / ( - 1.0_real32 , i = 1 , nums ) / ) ) yv4 = yv3 + spacing ( xv ) call unit_test_msg ( title , \"    xv  = \" , str ( xv ) ) call unit_test_msg ( title , \"    yv1 = \" , str ( yv1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yv2 = \" , str ( yv2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yv3 = \" , str ( yv3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yv4 = \" , str ( yv4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xv , yv1 )), \"Compare_Float(xv, yv1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv1 , ulp = 2 )), \"Compare_Float(xv, yv1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv2 )), \"Compare_Float(xv, yv2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xv , yv3 )), \"Compare_Float(xv, yv3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv3 , ulp = 2 )), \"Compare_Float(xv, yv3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xv , yv4 )), \"Compare_Float(xv, yv4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . equalto . yv1 )), \"( xv .equalto. yv1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv2 )), \"( xv .equalto. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xv . equalto . yv3 )), \"( xv .equalto. yv3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . equalto . yv4 )), \"( xv .equalto. yv4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv1 )), \"( xv .greaterthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv2 )), \"( xv .greaterthan. yv2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xv . greaterthan . yv3 )), \"( xv .greaterthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . greaterthan . yv4 )), \"( xv .greaterthan. yv4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xv . lessthan . yv1 )), \"( xv .lessthan. yv1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv2 )), \"( xv .lessthan. yv2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv3 )), \"( xv .lessthan. yv3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xv . lessthan . yv4 )), \"( xv .lessthan. yv4 )\" ) call unit_test_msg ( title , 'matrix' ) xa = reshape (( / single_number , single_number + ( sten * spacing ( single_number )) / ),( / nums , 2 / )) ya1 = nearest ( xa , reshape (( / ( 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya2 = ya1 - spacing ( xa ) ya3 = nearest ( xa , reshape (( / ( - 1.0_real32 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) ya4 = ya3 + spacing ( xa ) call unit_test_msg ( title , \"    xa  = \" , str ([ xa ]) ) call unit_test_msg ( title , \"    ya1 = \" , str ([ ya1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    ya2 = \" , str ([ ya2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    ya3 = \" , str ([ ya3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    ya4 = \" , str ([ ya4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 )), \"Compare_Float(xa,ya1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya1 , ulp = 2 )), \"Compare_Float(xa,ya1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya2 )), \"Compare_Float(xa,ya2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 )), \"Compare_Float(xa,ya3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya3 , ulp = 2 )), \"Compare_Float(xa,ya3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xa , ya4 )), \"Compare_Float(xa,ya4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya1 )), \"( xa .equalto. ya1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya2 )), \"( xa .equalto. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . equalto . ya3 )), \"( xa .equalto. ya3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . equalto . ya4 )), \"( xa .equalto. ya4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya1 )), \"( xa .greaterthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya2 )), \"( xa .greaterthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . greaterthan . ya3 )), \"( xa .greaterthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . greaterthan . ya4 )), \"( xa .greaterthan. ya4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xa . lessthan . ya1 )), \"( xa .lessthan. ya1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya2 )), \"( xa .lessthan. ya2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya3 )), \"( xa .lessthan. ya3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xa . lessthan . ya4 )), \"( xa .lessthan. ya4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_elemental_double () real ( kind = real64 ), dimension ( nums ) :: xvd , yvd1 , yvd2 , yvd3 , yvd4 real ( kind = real64 ), dimension ( nums , 2 ) :: xad , yad1 , yad2 , yad3 , yad4 character ( len = :), allocatable :: title title = 'equalto double' call unit_test_start ( title , msg = 'vector tests' ) call unit_test_msg ( title , 'vector' ) xvd = double_number yvd1 = nearest ( xvd , ( / ( 1.0_real64 , i = 1 , nums ) / ) ) yvd2 = yvd1 - spacing ( xvd ) yvd3 = nearest ( xvd , ( / ( - 1.0_real64 , i = 1 , nums ) / ) ) yvd4 = yvd3 + spacing ( xvd ) call unit_test_msg ( title , \"    xvd  = \" , str ( xvd ) ) call unit_test_msg ( title , \"    yvd1 = \" , str ( yvd1 ), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yvd2 = \" , str ( yvd2 ), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yvd3 = \" , str ( yvd3 ), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yvd4 = \" , str ( yvd4 ), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . compare_float ( xvd , yvd1 )), \"Compare_Float(xvd, yvd1)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd1 , ulp = 2 )), \"Compare_Float(xvd, yvd1,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd2 )), \"Compare_Float(xvd, yvd2)      \" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . compare_float ( xvd , yvd3 )), \"Compare_Float(xvd, yvd3)      \" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd3 , ulp = 2 )), \"Compare_Float(xvd, yvd3,ulp=2)\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . compare_float ( xvd , yvd4 )), \"Compare_Float(xvd, yvd4)      \" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . equalto . yvd1 )), \"( xvd .equalto. yvd1 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd2 )), \"( xvd .equalto. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , T ] . eqv . ( xvd . equalto . yvd3 )), \"( xvd .equalto. yvd3 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . equalto . yvd4 )), \"( xvd .equalto. yvd4 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd1 )), \"( xvd .greaterthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd2 )), \"( xvd .greaterthan. yvd2 )\" ) call unit_test ( title , all ([ T , T , T , T , F ] . eqv . ( xvd . greaterthan . yvd3 )), \"( xvd .greaterthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . greaterthan . yvd4 )), \"( xvd .greaterthan. yvd4 )\" ) call unit_test ( title , all ([ T , T , T , T , T ] . eqv . ( xvd . lessthan . yvd1 )), \"( xvd .lessthan. yvd1 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd2 )), \"( xvd .lessthan. yvd2 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd3 )), \"( xvd .lessthan. yvd3 )\" ) call unit_test ( title , all ([ F , F , F , F , F ] . eqv . ( xvd . lessthan . yvd4 )), \"( xvd .lessthan. yvd4 )\" ) call unit_test_msg ( title , 'matrix' ) xad = reshape (( / double_number , double_number + ( dten * spacing ( double_number )) / ),( / nums , 2 / )) yad1 = nearest ( xad , reshape (( / ( 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad2 = yad1 - spacing ( xad ) yad3 = nearest ( xad , reshape (( / ( - 1.0_real64 , i = 1 , nums * 2 ) / ),( / nums , 2 / )) ) yad4 = yad3 + spacing ( xad ) call unit_test_msg ( title , \"    xad  = \" , str ([ xad ]) ) call unit_test_msg ( title , \"    yad1 = \" , str ([ yad1 ]), \":  NEAREST( x, 1.0 )\" ) call unit_test_msg ( title , \"    yad2 = \" , str ([ yad2 ]), \":  y1 - SPACING( x )\" ) call unit_test_msg ( title , \"    yad3 = \" , str ([ yad3 ]), \":  NEAREST( x,-1.0 )\" ) call unit_test_msg ( title , \"    yad4 = \" , str ([ yad4 ]), \":  y3 + SPACING( x )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 )), \"Compare_Float(xad,yad1)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad1 , ulp = 2 )), \"Compare_Float(xad,yad1,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad2 )), \"Compare_Float(xad,yad2)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 )), \"Compare_Float(xad,yad3)      \" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad3 , ulp = 2 )), \"Compare_Float(xad,yad3,ulp=2)\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv . compare_float ( xad , yad4 )), \"Compare_Float(xad,yad4)      \" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad1 )), \"( xad .equalto. yad1 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad2 )), \"( xad .equalto. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , T , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . equalto . yad3 )), \"( xad .equalto. yad3 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . equalto . yad4 )), \"( xad .equalto. yad4 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad1 )), \"( xad .greaterthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad2 )), \"( xad .greaterthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , F , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . greaterthan . yad3 )), \"( xad .greaterthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . greaterthan . yad4 )), \"( xad .greaterthan. yad4 )\" ) call unit_test ( title , all ( reshape ([ T , T , T , T , T , T , T , T , T , T ],[ nums , 2 ]). eqv .( xad . lessthan . yad1 )), \"( xad .lessthan. yad1 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad2 )), \"( xad .lessthan. yad2 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad3 )), \"( xad .lessthan. yad3 )\" ) call unit_test ( title , all ( reshape ([ F , F , F , F , F , F , F , F , F , F ],[ nums , 2 ]). eqv .( xad . lessthan . yad4 )), \"( xad .lessthan. yad4 )\" ) call unit_test_end ( title , msg = '' ) end subroutine test_elemental_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_equalto_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . eq . yd1 , xd . eq . yd1 , xd . eq . yd2 , xd . eq . yd3 , xd . eq . yd3 , xd . eq . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . equalto . yd1 ), \"( x .equalto. y1 ) =\" , xd . equalto . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . equalto . yd2 ), \"( x .equalto. y2 ) =\" , xd . equalto . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . equalto . yd3 ), \"( x .equalto. y3 ) =\" , xd . equalto . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . equalto . yd4 ), \"( x .equalto. y4 ) =\" , xd . equalto . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_equalto_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'equalto single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , T , F , T ] case ( 2 ); expected = [ F , T , F , T ] case ( 3 ); expected = [ F , T , F , T ] case ( 4 ); expected = [ F , T , F , T ] case ( 5 ); expected = [ F , T , T , T ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . eq . y1 , x . eq . y1 , x . eq . y2 , x . eq . y3 , x . eq . y3 , xd . eq . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . equalto . y1 ), \"( x .equalto. y1 ) =\" , x . equalto . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . equalto . y2 ), \"( x .equalto. y2 ) =\" , x . equalto . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . equalto . y3 ), \"( x .equalto. y3 ) =\" , x . equalto . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . equalto . y4 ), \"( x .equalto. y4 ) =\" , x . equalto . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_equalto_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_lessthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . lt . yd1 , xd . lt . yd1 , xd . lt . yd2 , xd . lt . yd3 , xd . lt . yd3 , xd . lt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . lessthan . yd1 ), \"( x .lessthan. y1 ) =\" , xd . lessthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . lessthan . yd2 ), \"( x .lessthan. y2 ) =\" , xd . lessthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . lessthan . yd3 ), \"( x .lessthan. y3 ) =\" , xd . lessthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . lessthan . yd4 ), \"( x .lessthan. y4 ) =\" , xd . lessthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_lessthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'lessthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ T , F , F , F ] case ( 2 ); expected = [ T , F , F , F ] case ( 3 ); expected = [ T , F , F , F ] case ( 4 ); expected = [ T , F , F , F ] case ( 5 ); expected = [ T , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . lt . y1 , x . lt . y1 , x . lt . y2 , x . lt . y3 , x . lt . y3 , x . lt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . lessthan . y1 ), \"( x .lessthan. y1 ) =\" , x . lessthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . lessthan . y2 ), \"( x .lessthan. y2 ) =\" , x . lessthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . lessthan . y3 ), \"( x .lessthan. y3 ) =\" , x . lessthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . lessthan . y4 ), \"( x .lessthan. y4 ) =\" , x . lessthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_lessthan_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_greaterthan_double () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan double' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , xd . gt . yd1 , xd . gt . yd1 , xd . gt . yd2 , xd . gt . yd3 , xd . gt . yd3 , xd . gt . yd4 ) call unit_test ( title , expected ( 1 ) . eqv . ( xd . greaterthan . yd1 ), \"( x .greaterthan. y1 ) =\" , xd . greaterthan . yd1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( xd . greaterthan . yd2 ), \"( x .greaterthan. y2 ) =\" , xd . greaterthan . yd2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( xd . greaterthan . yd3 ), \"( x .greaterthan. y3 ) =\" , xd . greaterthan . yd3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( xd . greaterthan . yd4 ), \"( x .greaterthan. y4 ) =\" , xd . greaterthan . yd4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_greaterthan_single () logical , allocatable :: expected (:) character ( len =* ), parameter :: title = 'greaterthan single' call unit_test_start ( title , msg = title ) select case ( i ) case ( 1 ); expected = [ F , F , T , F ] case ( 2 ); expected = [ F , F , T , F ] case ( 3 ); expected = [ F , F , T , F ] case ( 4 ); expected = [ F , F , T , F ] case ( 5 ); expected = [ F , F , F , F ] end select call unit_test_msg ( title , 'expected' , expected ( 1 ), expected ( 2 ), expected ( 3 ), expected ( 4 )) call unit_test_msg ( title , ' regular' , x . gt . y1 , x . gt . y1 , x . gt . y2 , x . gt . y3 , x . gt . y3 , x . gt . y4 ) call unit_test ( title , expected ( 1 ) . eqv . ( x . greaterthan . y1 ), \"( x .greaterthan. y1 ) =\" , x . greaterthan . y1 , 'test' , i ) call unit_test ( title , expected ( 2 ) . eqv . ( x . greaterthan . y2 ), \"( x .greaterthan. y2 ) =\" , x . greaterthan . y2 , 'test' , i ) call unit_test ( title , expected ( 3 ) . eqv . ( x . greaterthan . y3 ), \"( x .greaterthan. y3 ) =\" , x . greaterthan . y3 , 'test' , i ) call unit_test ( title , expected ( 4 ) . eqv . ( x . greaterthan . y4 ), \"( x .greaterthan. y4 ) =\" , x . greaterthan . y4 , 'test' , i ) call unit_test_end ( title , msg = '' ) end subroutine test_greaterthan_single !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program test_compare_float !===================================================================================================================================","tags":"","url":"sourcefile/test_compare_float.f90.html"},{"title":"demo_significant.f90 – M_framework","text":"Source Code program demo_significant use M_framework__approx , only : significant implicit none character ( len =* ), parameter :: g = '(*(g0.7,1x))' write ( * , g ) significant ([ 876 5.43210 , 0.1234567890 ], 5 ) write ( * , * ) 'default:' , 1.23456789012345 write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ), 'RU' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ), 'RD' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ), 'RZ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ), 'RN' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ), 'RC' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ), 'RP' end program demo_significant","tags":"","url":"sourcefile/demo_significant.f90.html"},{"title":"demo_unit_test_stop.f90 – M_framework","text":"Source Code program demo_unit_test_stop use M_framework , only : unit_test_start , unit_test_end , & & unit_test , unit_test_stop , unit_test_mode use , intrinsic :: iso_fortran_env , stdout => OUTPUT_UNIT implicit none integer :: x x = 10 call unit_test_mode ( luns = [ stdout ]) ! do a test call unit_test_start ( 'proc1' ) call unit_test ( 'proc1' , x > 3 , 'if big enough' ) call unit_test ( 'proc1' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc1' , msg = 'checks all done' ) ! do another test call unit_test_start ( 'proc2' ) call unit_test ( 'proc2' , x > 3 , 'if big enough' ) call unit_test ( 'proc2' , x < 100 , 'if small enough' ) call unit_test_end ( 'proc2' , msg = 'checks all done' ) ! tally up test results and stop program call unit_test_stop () end program demo_unit_test_stop","tags":"","url":"sourcefile/demo_unit_test_stop.f90.html"},{"title":"demo_unit_test_system.f90 – M_framework","text":"Source Code program demo_unit_test_system use M_framework , only : & unit_test_start , & unit_test , & unit_test_system , & unit_test_end implicit none if ( command_argument_count () == 0 ) then call unit_test_start ( 'myroutine' ) call unit_test ( 'false' , unit_test_system ( 'false' ) == 0 , 'check false' ) call unit_test ( 'true' , unit_test_system ( 'true' ) == 0 , 'check true' ) call unit_test ( 'notthere' , unit_test_system ( 'notthere' ) == 0 , & & 'check notthere' ) call unit_test ( '*' ,& & unit_test_system ( '* and options' , verbose = . true .) == 0 , 'check \"*\"' ) call unit_test_end ( 'myroutine' ) else write ( * , * ) 'called with an option' endif end program demo_unit_test_system","tags":"","url":"sourcefile/demo_unit_test_system.f90.html"},{"title":"demo_attr_update.f90 – M_framework","text":"Source Code program demo_update use M_framework__attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","url":"sourcefile/demo_attr_update.f90.html"},{"title":"demo_attr_mode.f90 – M_framework","text":"Source Code program demo_attr_mode use M_framework__attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & & '<M><y>' ,& & '<M><y>  Suffice it to say that black and white are also colors' ,& & '<M><y>  for their simultaneous contrast is as striking as that ' ,& & '<M><y>  of green and red, for instance. & & --- <y><bo>Vincent van Gogh</bo></y>' ,& & ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode end program demo_attr_mode","tags":"","url":"sourcefile/demo_attr_mode.f90.html"},{"title":"M_framework__utility.f90 – M_framework","text":"Source Code module M_framework__utility use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT implicit none private public :: fstop contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fstop(3f) - [M_framework__utility] call stop with both a number and !!    a message !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine fstop(ierr,stdout,stderr) !! !!     integer,intent(in)                   :: ierr !!     character(len=*),intent(in),optional :: stdout !!     character(len=*),intent(in),optional :: stderr !!##DESCRIPTION !!    FSTOP(3f) call STOP(3f). What a call to STOP does is very system !!    dependent, so using an abstraction layer is useful, as it allows just !!    the fstop() routine to be changed; and STOP does not allow a variable !!    to be used on the numeric access status (this has changed at f2015). !! !!##OPTIONS !!    ierr    - value in range 0 to 32 !!    stdout  - description to be printed to standard output !!    stderr  - description to be printed to standard error !!##EXAMPLES !! !!   Sample program: !! !!    program demo_fstop !!    use M_framework__utility, only: fstop !!    implicit none !!    integer :: int !!    !*!write(*,*)'Enter stop value' !!    !*!read(*,*) int !!    int=25 !!    select case(int) !!    case(10) ; call fstop(int) !!    case(20) ; call fstop(int,stderr='error: program will now stop') !!    case(25) ; call fstop(int,stdout='stdout message', & !!                    & stderr='stderr message') !!    case(30) ; call fstop(int,stdout='error: program will now stop') !!    case default !!               call fstop(int) !!    endselect !! !!    end program demo_fstop !! !!   Results: !! !!##SEE ALSO !!   Look for common extensions, such as abort(3f), backtrace(3f) !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine fstop ( ierr , stdout , stderr ) ! ident_1=\"@(#) M_framework__utility fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message\" integer , intent ( in ) :: ierr character ( len =* ), optional , intent ( in ) :: stdout character ( len =* ), optional , intent ( in ) :: stderr character ( len = 132 ) :: message ! The standard states: !   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the !   processor supports that concept. If the integer stop-code is used as the process exit status, the processor !   might be able to interpret only values within a limited range, or only a limited portion of the integer value !   (for example, only the least-significant 8 bits). !   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed, !   it is recommended that the value zero be supplied as the process exit status, if the processor supports that !   concept. !   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement. ! ! Conforming variants I have encountered include !    o printing a message such as 'STOP nnn' when the integer value is called !    o having a limit on the length of the message string passed !    o prefixing the message with the string 'STOP ' !    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument !      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...) !    o whether messages appear on stdout or stderr. !    o no value being returned to the system at all. ! !  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported. !  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated? ! !  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value. !  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system, !  but I sometimes want to return variables. ! !  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message !  to appear when using integer values ! !  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky !  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran !  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a !  value to the system and Fortran does not, but I do not recommend it. ! !  Note that the C function \"exit(int signal)\" not only works more consistently but that the global values EXIT_SUCCESS and !  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant. ! !  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure. !----------------------------------------------------------------------------------------------------------------------------------- !STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab' !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( stderr )) then ! write message to stderr, assuming string length is allowed if ( stderr /= '' ) then write ( error_unit , '(a)' ) trim ( stderr ) endif !f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED) !f2015!      case(0); allstop 0 !f2015!      case(1); allstop 1 !f2015!      case(2); allstop 2 !f2015!      case(3); allstop 3 !f2015!      case(4); allstop 4 !f2015!      case(5); allstop 5 !f2015!      case(6); allstop 6 !f2015!      case(7); allstop 7 !f2015!      case(8); allstop 8 !f2015!      case(9); allstop 8 !f2015!      case(10); allstop 10 !f2015!      case(11); allstop 11 !f2015!      case(12); allstop 12 !f2015!      case(13); allstop 13 !f2015!      case(14); allstop 14 !f2015!      case(15); allstop 15 !f2015!      case(16); allstop 16 !f2015!      case(17); allstop 17 !f2015!      case(18); allstop 18 !f2015!      case(19); allstop 19 !f2015!      case(20); allstop 20 !f2015!      case(21); allstop 21 !f2015!      case(22); allstop 22 !f2015!      case(23); allstop 23 !f2015!      case(24); allstop 24 !f2015!      case(25); allstop 25 !f2015!      case(26); allstop 26 !f2015!      case(27); allstop 27 !f2015!      case(28); allstop 28 !f2015!      case(29); allstop 29 !f2015!      case(30); allstop 30 !f2015!      case(31); allstop 31 !f2015!      case(32); allstop 32 !f2015!   case default !f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system' !f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error !f2015!      allstop 1 !f2015!   end select endif if ( present ( stdout )) then ! write message to stdout, assuming string length is allowed if ( stdout /= '' ) then write ( * , '(a)' ) trim ( stdout ) endif endif select case ( ierr ) ! have executable return an exit status to the system (IF SUPPORTED) case ( 0 ); stop 0 case ( 1 ); stop 1 case ( 2 ); stop 2 case ( 3 ); stop 3 case ( 4 ); stop 4 case ( 5 ); stop 5 case ( 6 ); stop 6 case ( 7 ); stop 7 case ( 8 ); stop 8 case ( 9 ); stop 8 case ( 10 ); stop 10 case ( 11 ); stop 11 case ( 12 ); stop 12 case ( 13 ); stop 13 case ( 14 ); stop 14 case ( 15 ); stop 15 case ( 16 ); stop 16 case ( 17 ); stop 17 case ( 18 ); stop 18 case ( 19 ); stop 19 case ( 20 ); stop 20 case ( 21 ); stop 21 case ( 22 ); stop 22 case ( 23 ); stop 23 case ( 24 ); stop 24 case ( 25 ); stop 25 case ( 26 ); stop 26 case ( 27 ); stop 27 case ( 28 ); stop 28 case ( 29 ); stop 29 case ( 30 ); stop 30 case ( 31 ); stop 31 case ( 32 ); stop 32 case default write ( message , '(a,i0,a)' ) '*fstop*: stop value of ' , ierr , ' returning 1 to system' write ( error_unit , '(a)' ) trim ( message ) ! write message to standard error stop 1 end select end subroutine fstop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_framework__utility","tags":"","url":"sourcefile/m_framework__utility.f90.html"},{"title":"demo_M_framework__attr.f90 – M_framework","text":"Source Code program demo_M_framework__attr use M_framework__attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mnemonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_framework__attr","tags":"","url":"sourcefile/demo_m_framework__attr.f90.html"},{"title":"demo_journal.f90 – M_framework","text":"Source Code program demo_journal use M_framework__journal , only : journal !! BASIC USAGE call journal (& & 'write to standard output as-is, and trail file as a comment if open' ) ! since trail file is not yet open, only stdout will display output call journal ( 'c' , 'ignored, as trail file is not open' ) ! now open trail file \"trail\" call journal ( 'o' , 'trail' ) call journal ( 'sc' , 'same thing except now trail file is open' ) ! only write to trail file if open call journal ( 'c' ,& & 'not ignored, as trail file is open. Written with # suffix' ) call journal ( 't' ,& & 'not ignored, as trail file is open. Written as-is' ) ! turn off trail file call journal ( 'o' , '' ) end program demo_journal","tags":"","url":"sourcefile/demo_journal.f90.html"},{"title":"M_framework__verify.F90 – M_framework","text":"Source Code !> !!##NAME !!    M_framework__verify(3f) - [M_framework__verify::INTRO] unit test framework !!     (LICENSE:PD) !!##SYNOPSIS !! !! !!  Module procedures !! !!    use M_framework, only : unit_test, unit_test_start,    & !!                            unit_test_end, unit_test_stop, & !!                            unit_test_msg, unit_test_mode, & !!                            unit_test_system,              & !!                            unit_test_expected !!  Module values !! !!    use M_framework, only : unit_test_level, unit_test_flags !! !!##QUOTE !!    Do not let your victories go to your head, nor let your failures go !!    to your heart. !! !!##DESCRIPTION !!    The M_framework(3f) module is a collection of Fortran routines for !!    supporting code development by providing logging, error processing, !!    debugging, comparison and unit testing procedures. !! !!    The M_framework__verify(3f) module specifically brings together a !!    few procedures for creating unit testing. It ... !! !!     o allows for a user-defined command to be called to collect results or !!       produce mail alerts, or other custom bookkeeping operations. !! !!     o supports easily composing a message from up to twenty scalar !!       intrinsic values and different strings !! !!     o allows stopping on failure or continuing !! !!     o provides for a non-zero exit code if any tests fail !! !!     o is designed for with integration with the fpm !!      (Fortran Package Manager) \"test\" subcommand. !! !!    If default modes need changed it can be done via the unit_test_mode(3f) !!    procedure or as command line options. !! !!    messages by default are writing to stderr, but may be written to any !!    list of LUNs of preassigned or open files. !! !!    SET MODES !! !!    Some of the most common options are !! !!       call unit_test_mode(command,keep_going,level,luns=[K,L,M,N,...]) !! !!        keep_going  logical variable that can be used to turn on or off !!                    program termination on errors. !!        luns        array of Fortran LUNs to write messages to !!        level       An integer that can be used to specify !!                    different debug levels !!        command     name of optional command to execute for a start, !!                    check, or finish. !! !!  PROCEDURES !! !!  The unit test procedures are !! !!       unit_test_start()     start tests of a procedure !!       unit_test()           report if expression is false or true !!                              and if .false. stop program when keep_going=.false. !!       unit_test_end()       ends test of a procedure !!       unit_test_msg()       write message !!       unit_test_stop()      stop program with exit value of 0 if no failures !!                              else with an exit value of 1 !!       unit_test_system()    execute system command, recursively if requested. !! !!  The unit test short-cut procedures are !! !!       unit_test_expected()  report if two values are equal !! !!    For custom unit testing reports, a command can be given that will be !!    passed information on the command line in NAMELIST format. !! !!    This command is generally a script that makes entries for each unit, !!    perhaps in an SQLite data file for example. !! !!    It might also send an email if a test fails in batch environments. !! !!    It could also convert the information to CSV for use in spreadsheets, !!    or generate an HTML report, for example. !! !!    A sample command written in the bash(1) shell and using the sqlite3(1) !!    command should be included in this distribution as an example. !! !!    The flexibility introduced by calling an external script or program !!    is that the command can be changed as desired without changing the !!    test programs. !! !!    RELATED FUNCTIONS !! !!    The routines in M_framework__verify(3f) are often combined with other !!    small modules such as Comparisons of real values can be done with a !!    tolerance with M_Compare_Float_Numbers(3f) and M_framework__approx(3f). !!    M_hashkeys(3f) routines and various math and statistical routines can !!    be helpful to quickly create unit tests. !! !!    The intrinsics ANY(3f) and ALL(3f) are particularly useful in calls !!    to unit_test(3f). !! !!##EXAMPLES !! !!   Sample program !! !!     !! program demo_M_framework__verify !!     module M_framework__verify_demo !!     private !!     public one ! some regular routine !!     public two ! some regular routine !!     contains !! !!     subroutine one(array) !!     integer,intent(out),allocatable :: array(:) !!        array=[21,51,14,45] !!     end subroutine one !! !!     subroutine two(array) !!     integer,intent(inout),allocatable :: array(:) !!        array=2*array !!     end subroutine two !! !!     end module M_framework__verify_demo !! !!     program demo_M_framework__verify !!     use M_framework, only: unit_test_start, unit_test,   & !!         & unit_test_end, unit_test_msg, unit_test_stop, & !!         & unit_test_system, unit_test_mode !!     use M_framework__verify_demo,   only: one, two !!     ! set-up !!     call unit_test_mode(command='',flags=[0],keep_going=.true.) !!     ! call a test procedure for each routine to test !!        call test_one() !!        call test_two() !!     ! tear-down !!     call unit_test_stop() !!     contains !! !!     subroutine test_one() !!     integer,allocatable :: results(:) !!     integer,parameter   :: expected(*)=[21,51,14,45] !!     call unit_test_start('one') !!     call one(results) !!     call unit_test('one',all(expected>0), & !!        & 'testing if everyone greater than zero') !!     call unit_test('one',all(expected==results), & !!        & 'testing if all values are expected') !!     call unit_test_end('one','checks on \"one\" ended') !!     end subroutine test_one !! !!     subroutine test_two !!     integer,allocatable :: results(:) !!     integer,parameter   :: expected(*)=[2,20,200] !!     results=[1,10,100] !!     call two(results) !!     call unit_test_start('two','check procedure \"two\" ') !!     call unit_test('two', all(expected == results) .and. & !!        & all(expected > 0) .and. maxval(expected) <201,msg='long expression') !!     call unit_test_end('two','checks on \"two\" ended') !!     end subroutine test_two !! !!     end program demo_M_framework__verify !! !!   Expected output: !! !!    check_start: one   START   : !!    check:       one   SUCCESS : testing if everyone greater than zero !!    check:       one   SUCCESS : testing if all values are expected !!    check_end:   one   PASSED  : GOOD:  2 BAD:  0 DURATION:00000001 !!    check_start: two   START   : !!    check:       two   SUCCESS : long expression !!    check_end:   two   PASSED  : GOOD:   1 BAD:  0 DURATION:00000000 !!    check_stop:  TALLY PASSED  : GOOD:    3 BAD:  0 DURATION:00000001 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_framework__verify use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use :: M_framework__msg , only : str , wrt implicit none private type called logical :: preset_globals = . true . logical :: cmdline = . true . logical :: unit_test_mode = . true . end type called type ( called ), save :: G_virgin integer , save , allocatable :: G_luns (:) ! output units logical , save :: G_debug = . false . logical , save :: G_verbose = . false . logical , save :: G_silent = . false . logical , save :: G_brief = . false . ! flag on whether to display SUCCESS: messages character ( len = :), allocatable :: G_match integer , save , public :: unit_test_level = 0 ! a value that can be used to select different debug levels integer , save , public , allocatable :: unit_test_flags (:) ! an array of flags that can be used to select different options logical , save :: G_keep_going = . false . ! can be used to turn on program termination on errors. logical , save :: G_interactive = . false . character ( len = :), allocatable :: G_command ! name of command to execute. Defaults to the name logical , save :: G_cmdline = . true . ! flag whether to parse command line for arguments or not integer , parameter , public :: realtime = kind ( 0.0d0 ) ! type for julian days integer , parameter , public :: EXIT_SUCCESS = 0 integer , parameter , public :: EXIT_FAILURE = 1 real ( kind = realtime ), save :: duration = 0.0d0 real ( kind = realtime ), save :: duration_all = 0.0d0 integer ( kind = int64 ), save :: clicks = 0_int64 integer ( kind = int64 ), save :: clicks_all = 0_int64 integer , save :: IPASSED_G = 0 ! counter of successes initialized by unit_test_start(3f) integer , save :: IFAILED_G = 0 ! counter of failures  initialized by unit_test_start(3f) integer , save :: IPASSED_ALL_G = 0 ! counter of successes initialized at program start integer , save :: IFAILED_ALL_G = 0 ! counter of failures  initialized at program start integer , save :: G_LONGEST = 20 public unit_test_mode ! optionally set some non-default modes public unit_test_start ! start testing a procedure public unit_test ! report results of a test public unit_test_end ! end  testing a procedure public unit_test_stop ! produce tally of all procedures tested and end program public unit_test_msg ! maybe write some message public unit_test_system ! usually used for recursive calls when testing program termination status public unit_test_expected ! shortcut for common call to unit_test with expression and expected result private atleast_ private cmdline_ private getarg0_ private getall_ private glob_ type :: force_keywd_hack ! force keywords, using @awvwgk method end type force_keywd_hack ! so then any argument that comes after \"force_keywd\" is a compile time error ! if not done with a keyword unless someone \"breaks\" it by passing something ! of this type: !    type(force_keywd_hack), optional, intent(in) :: force_keywd !=================================================== ! for backward compatibility 2023-04-30. Otherwise, ignore these public unit_test_good ! report results of a test public unit_test_bad ! report results of a test interface unit_test_done ; module  procedure unit_test_end ; end  interface unit_test_done ; public unit_test_done interface unit_check_start ; module  procedure unit_test_start ; end  interface unit_check_start ; public unit_check_start interface unit_check ; module  procedure unit_test ; end  interface unit_check ; public unit_check interface unit_check_done ; module  procedure unit_test_end ; end  interface unit_check_done ; public unit_check_done interface unit_check_mode ; module  procedure unit_test_mode ; end  interface unit_check_mode ; public unit_check_mode interface unit_check_stop ; module  procedure unit_test_stop ; end  interface unit_check_stop ; public unit_check_stop interface unit_check_msg ; module  procedure unit_test_msg ; end  interface unit_check_msg ; public unit_check_msg interface unit_check_good ; module  procedure unit_test_good ; end  interface unit_check_good ; public unit_check_good interface unit_check_bad ; module  procedure unit_test_bad ; end  interface unit_check_bad ; public unit_check_bad interface unit_test_expected module procedure unit_test_expected_int32 module procedure unit_test_expected_int64 module procedure unit_test_expected_char module procedure unit_test_expected_boolean module procedure unit_test_expected_onoff module procedure unit_test_expected_real32 module procedure unit_test_expected_real64 module procedure unit_test_expected_cmplx32 module procedure unit_test_expected_cmplx64 end interface public unit_check_level integer :: unit_check_level equivalence ( unit_test_level , unit_check_level ) ! labels for PREFIX COLUMN OF MESSAGES type prefix character ( len = :), allocatable :: CHECK_MSG !  'check_msg:    ' character ( len = :), allocatable :: CHECK !  'check:        ' character ( len = :), allocatable :: CHECK_START !  'check_start:  ' character ( len = :), allocatable :: CHECK_STOP !  'check_stop:   ' character ( len = :), allocatable :: CHECK_END !  'check_end:    ' end type prefix !type(prefix),save :: CHECK_PREFIX=prefix( & !   CHECK_MSG    =  'check_msg:   ', & !   CHECK        =  'check:       ', & !   CHECK_START  =  'check_start: ', & !   CHECK_STOP   =  'check_stop:  ', & !   CHECK_END    =  'check_end:   '  & !&) type ( prefix ), save :: CHECK_PREFIX = prefix ( null (), null (), null (), null (), null ()) public :: CHECK_PREFIX contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_test_msg(3f) - [M_framework__verify] converts up to twenty !!    standard scalar values to a message for unit testing !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function unit_test_msg(name, msg, & !!    & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,if) !! !!     character(len=*),intent(in)  :: name !!     class(*),intent(in),optional :: msg, & !!     & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!##DESCRIPTION !!    unit_test_msg(3f) builds a string from up to twenty scalar values and !!    prints it to the error log. !! !!##OPTIONS !!    name        name of unit being tested !!    msg,g[1-j]  optional values to print the value of. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !!    if          expression must be true or message is not output. !!                Must be specified by keyword as \"if=expression\". !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unit_test_msg !!    use M_framework, only : unit_test_start,unit_test_msg, & !!            & unit_test_end !!    implicit none !! !!    call unit_test_start('myroutine') !!    call unit_test_msg('myroutine','HUGE(3f) integers', & !!            & huge(0),'and real',huge(0.0),'and double',huge(0.0d0)) !!    call unit_test_msg('myroutine','real            :', & !!            & huge(0.0),0.0,12345.6789,tiny(0.0) ) !!    call unit_test_msg('myroutine','doubleprecision :', & !!            & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) ) !!    call unit_test_msg('myroutine','complex         :', & !!            & cmplx(huge(0.0),tiny(0.0)) ) !!    call unit_test_end('myroutine') !! !!    end program demo_unit_test_msg !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_msg ( name , msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , force_keywd , if ) implicit none ! ident_1=\"@(#) M_framework__verify unit_test_msg(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: name class ( * ), intent ( in ), optional :: msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( in ), optional :: if character ( len = :), allocatable :: msg_all logical :: if_local G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( if )) then if_local = if else if_local = . true . endif if ( G_virgin % cmdline ) call cmdline_ () if ( if_local ) then msg_all = str ( msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if (. not . G_brief ) then ! write message to standard error call wrt ( G_luns , CHECK_PREFIX % check_msg // atleast_ ( name , G_LONGEST ) // ' INFO    : ' // msg_all ) endif if ( G_command /= '' ) call run ( G_command // ' type=\"message\"  name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_all ) // '\"' ) endif end subroutine unit_test_msg !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_test(3f) - [M_framework__verify] report if logical expression is !!    true or false, optionally call command and/or stop program. !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail) !! !!     character(len=*),intent(in) :: name !!     logical,intent(in) :: expression !!     class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!     & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!     logical,intent(in),optional :: only_on_fail !! !!##DESCRIPTION !!    unit_test(3f) tests the expression and displays a message composed !!    of the generic intrinsic values msg, and g1 thorough gj. Additionally, !!    if the expression is false !! !!    o if unit_test_mode(command) is not blank calls the !!    specified shell command !! !!       $COMMAND name=\"NAME\" type=\"check\" passed=\"passed|failed\" ... !!       msg=\"all messages\" !! !!    o if keep_going = .false. stop the program on a failed test !! !!##OPTIONS !!     NAME          the unit test name !!     EXPRESSION    the logical expression to evaluate !!     msg,g1...gj   optional message to display when performing test, !!                   composed of any scalar intrinsics of type INTEGER, !!                   REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or !!                   CHARACTER. A space is placed between each value. !!     wordy         If .false. The message MSG is only displayed if the expression !!                   is .false. . Must be used as a keyword. Default is .true. . !! !!##EXAMPLES !! !!   Sample program: !! !!       program demo_unit_test !!       use M_framework, only: & !!          & unit_test_mode,     & !!          & unit_test_start,    & !!          & unit_test,          & !!          & unit_test_end,      & !!          & unit_test_stop !!       use M_framework, only: almost !! !!       implicit none !!       integer :: i !!       integer :: x !!       integer,allocatable :: arr(:) !!       real,allocatable :: arr1(:) !!       real,allocatable :: arr2(:) !! !!          call unit_test_mode(keep_going=.true.,debug=.false.,command='') !! !!          x=10 !!          arr1=[1.0,10.0,100.0] !!          arr2=[1.0001,10.001,100.01] !!          call unit_test_start('myroutine') !! !!          call unit_test('myroutine', x > 3 ,' if big enough') !!          call unit_test('myroutine', x < 100 ,' if small enough') !! !!          do i=1,size(arr1) !!             call unit_test('myroutine', & !!             & almost(arr1(i),arr2(i),3.9,verbose=.true.) ) !!          enddo !! !!          arr=[10,20,30] !!          call unit_test('myroutine', .not.any(arr < 0) , & !!          & 'fail if any negative values in array ARR') !!          call unit_test('myroutine', all(arr < 100) , & !!          & 'fail unless all values are less than 100 in array ARR') !! !!          call unit_test_end('myroutine', & !!          & msg='checks on \"myroutine\" all passed') !! !!          call unit_test_stop() !! !!       end program demo_unit_test !! !! Results: !! !!  Sample output (varies with what optional command or modes is used): !! !!      >check_start: myroutine            START   : !!      >check:       myroutine            SUCCESS :  if big enough !!      >check:       myroutine            SUCCESS :  if small enough !!      >*almost* for values 1.00000000 1.00010002 agreement of 3.99997139 ... !!      >digits out of requested 3.90000010 !!      >check:       myroutine            SUCCESS : !!      >*almost* for values 10.0000000 10.0010004 agreement of 3.99986792 ... !!      >digits out of requested 3.90000010 !!      >check:       myroutine            SUCCESS : !!      >*almost* for values 100.000000 100.010002 agreement of 3.99995065 ... !!      >digits out of requested 3.90000010 !!      >check:       myroutine            SUCCESS : !!      >check:       myroutine            SUCCESS : fail if any negative ... !!      >values in array ARR !!      >check:       myroutine            SUCCESS : fail unless all values ... !!      >are less than 100 in array ARR !!      >check_end:   myroutine            PASSED  : GOOD:7         BAD: ... !!      >0 DURATION:00000000294709: checks on \"myroutine\" all passed !!      >check_stop:  TALLY                PASSED  : GOOD:7         BAD: ... !!      >0 DURATION:00000000267059 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test ( name , logical_expression , msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , force_keywd , wordy ) ! ident_2=\"@(#) M_framework__verify unit_test(3f) assert if expression is .true. or .false. and optionally call command or stop on .false.\" character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: logical_expression class ( * ), intent ( in ), optional :: msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( in ), optional :: wordy character ( len = :), allocatable :: msg_all logical :: wordy_local G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( wordy )) then wordy_local = wordy else wordy_local = . true . endif if ( G_virgin % cmdline ) call cmdline_ () msg_all = str ( msg , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if (. not . logical_expression ) then call wrt ( G_luns , CHECK_PREFIX % check // atleast_ ( name , G_LONGEST ) // ' FAILURE : ' // msg_all ) if ( G_command /= '' ) call run ( G_command // ' type=\"check\" name=\"' // trim ( name ) // '\" passed=\"failed\" msg=\"' // ndq ( msg_all ) // '\"' ) if (. not . G_keep_going ) then call wrt ( G_luns , CHECK_PREFIX % check // 'STOPPING PROGRAM ON FAILED TEST OF ' // trim ( name )) stop 1 endif IFAILED_G = IFAILED_G + 1 IFAILED_ALL_G = IFAILED_ALL_G + 1 else if (. not . G_brief ) then if ( wordy_local ) call wrt ( G_luns , CHECK_PREFIX % check // atleast_ ( name , G_LONGEST ) // ' SUCCESS : ' // msg_all ) endif if ( G_command /= '' ) call run ( G_command // ' type=\"check\" name=\"' // trim ( name ) // '\" passed=\"passed\" msg=\"' // ndq ( msg_all ) // '\"' ) IPASSED_G = IPASSED_G + 1 IPASSED_ALL_G = IPASSED_ALL_G + 1 endif end subroutine unit_test !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_test_start(3f) - [M_framework__verify] reset counters !!    and start a new test block !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test_start(name,msg,opts,matched) !! !!     character(len=*),intent(in)          :: name !!     character(len=*),intent(in),optional :: msg !!     character(len=*),intent(in),optional :: opts !!     logical,intent(out),optional         :: matched !! !!##DESCRIPTION !!    unit_test_start(3f) is an initialization procedure for starting a !!    new procedure test. !! !!##OPTIONS !!    NAME   name of the procedure to test !!    MSG    message to print !!    OPTS   pass additional options to the optional shell command that !!           can be assigned on the command line or by unit_test_mode(3f). !!    MATCHED  if the match string has been set with unit_test_mode(3f) !!             or on the command line this will return true if the name !!             and msg concatenated with a space match the entire match !!             string, where \"*\" matches any string and \"?\" matches any !!             single character. This allows you to skip a test set if !!             you wish by exiting. !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_test_start !!     use M_framework, only: unit_test_start, unit_test, & !!      & unit_test_end, unit_test_mode, unit_test_stop !!     implicit none !!     integer :: ival !!     logical :: matched !!     call unit_test_mode() !!     call test_mysub1() !!     call test_mysub2() !!     call unit_test_stop() !!     contains !!     subroutine test_mysub1() ! first test !!     call unit_test_start('mysub1') !!     ! the example goodbad(1) command called here takes many options !!     ! used to build an SQLite3 entry !!     ival=10 !!     call unit_test('mysub1', ival > 3 ,   msg=' if big enough') !!     call unit_test('mysub1', ival < 100 , msg=' if small enough') !!     call unit_test_end('mysub1',msg='completed checks of \"mysub1\"') !!     end subroutine test_mysub1 !! !!     subroutine test_mysub2() ! second test !!     call unit_test_start('mysub1','',matched=matched) !!     ival=200 !!        if(.not.matched)return ! makes it skippable !!        call unit_test('mysub1', ival > 3 ,   msg=' if big enough') !!        call unit_test('mysub1', ival < 100 , msg=' if small enough') !!        call unit_test_end('mysub1',msg='completed checks of \"mysub2\"') !!     end subroutine test_mysub2 !! !!     end program demo_unit_test_start !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_start ( name , msg , opts , force_keywd , matched ) ! ident_3=\"@(#) M_framework__verify unit_test_start(3f) start testing procedure \"name\"\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: msg character ( len =* ), intent ( in ), optional :: opts type ( force_keywd_hack ), optional , intent ( in ) :: force_keywd logical , intent ( out ), optional :: matched character ( len = :), allocatable :: msg_local logical , save :: called = . false . G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( present ( msg )) then msg_local = trim ( msg ) else msg_local = '' endif if ( G_virgin % cmdline ) call cmdline_ () ! check optional matched string and return if string is not blank and not matched. ! It is assumed program will skip the subsequent test if ( present ( matched )) then if ( G_match . ne . '' ) then matched = glob_ ( name // ' ' // msg_local , G_match ) if (. not . matched ) return endif matched = . true . endif if ( present ( opts )) then if ( G_command /= '' ) call run ( G_command // ' type=\"start\" name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_local ) // '\" ' // opts ) else if ( G_command /= '' ) call run ( G_command // ' type=\"start\" name=\"' // trim ( name ) // '\" msg=\"' // ndq ( msg_local ) // '\"' ) endif call system_clock ( clicks ) duration = julian () if (. not . called ) then call system_clock ( clicks_all ) duration_all = julian () called = . true . endif if (. not . G_brief ) then call wrt ( G_luns , CHECK_PREFIX % check_start // atleast_ ( name , G_LONGEST ) // ' START   : ' // msg_local ) endif IPASSED_G = 0 IFAILED_G = 0 end subroutine unit_test_start !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_test_stop(3f) - [M_framework__verify] report tally of all checks !!    and stop program !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test_stop(msg,opts) !! !!     character(len=*),intent(in),optional :: msg !!     character(len=*),intent(in),optional :: opts !! !!##DESCRIPTION !! !!    give a tally of all calls to unit_test(3f) and stop program. !! !!    Tally up the test result totals and stop the program. !!    If a command is set via unit_test_mode(3f) or the command line !!    call it appending OPTS to the end of the command. !! !!##OPTIONS !!     MSG  additional message to display !!     OPTS add string to filter command line if any is specified. !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_test_stop !!     use M_framework, only: unit_test_start, unit_test_end, & !!     & unit_test, unit_test_stop, unit_test_mode !!     use,intrinsic :: iso_fortran_env, stdout=>OUTPUT_UNIT !!     implicit none !!     integer :: x !!     x=10 !!     call unit_test_mode(luns=[stdout]) !!     ! do a test !!     call unit_test_start('proc1') !!     call unit_test('proc1', x > 3 , 'if big enough') !!     call unit_test('proc1', x < 100 , 'if small enough') !!     call unit_test_end  ('proc1',msg='checks all done' ) !!     ! do another test !!     call unit_test_start('proc2') !!     call unit_test('proc2', x > 3 , 'if big enough') !!     call unit_test('proc2', x < 100 , 'if small enough') !!     call unit_test_end  ('proc2',msg='checks all done' ) !! !!     ! tally up test results and stop program !!     call unit_test_stop() !! !!     end program demo_unit_test_stop !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_stop ( msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_4=\"@(#) M_framework__verify unit_test_stop(3f) stop program with report on calls to unit_test(3f)\" character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = 4096 ) :: out character ( len = :), allocatable :: PF integer ( kind = int64 ) :: milliseconds integer ( kind = int64 ) :: clicks_now if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif call system_clock ( clicks_now ) milliseconds = ( julian () - duration_all ) * 1000 milliseconds = clicks_now - clicks_all PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_all_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_all_G == 0 ) then PF = 'UNTESTED:' endif write ( out , '(\"' // CHECK_PREFIX % check_stop // '\",a,1x,a,\" GOOD: \",a,\" BAD: \",a,\" DURATION: \",i20.20)' ) & & atleast_ ( \"TALLY\" , G_LONGEST ), & & PF , & & atleast_ ( str ( IPASSED_ALL_G ), 9 ), & & atleast_ ( str ( IFAILED_ALL_G ), 9 ), & & milliseconds if ( present ( msg )) then if (. not . G_brief . or .( IFAILED_ALL_G + IPASSED_ALL_G . eq . 0 ). or . IFAILED_ALL_G . ne . 0 ) & & call wrt ( G_luns , trim ( out ) // ': ' // trim ( msg )) else if (. not . G_brief . or .( IFAILED_ALL_G + IPASSED_ALL_G . eq . 0 ). or . IFAILED_ALL_G . ne . 0 ) & & call wrt ( G_luns , out ) endif if ( PF == 'UNTESTED' ) then if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"untested\" clicks=0 msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop ! EXIT_SUCCESS elseif ( IFAILED_ALL_G == 0 ) then if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"passed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop ! EXIT_SUCCESS else if ( G_command /= '' ) & & call run ( str ( G_command , ' type=\"stop\" passed=\"failed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg_local ), '\"' , sep = '' ) ) stop EXIT_FAILURE endif end subroutine unit_test_stop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !! unit_test_end(3f) - [M_framework__verify] end test of procedure started !! by unit_test_start(3f) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test_end(name,msg,opts) !! !!     character(len=*),intent(in) :: name !!     character(len=*),intent(in),optional :: msg !!     character(len=*),intent(in),optional :: opts !! !!##DESCRIPTION !! !!    A message is shown including the duration of the tests !!    If there have been no failures the optional shell command !! !!        $COMMAND name=\"name\" type=\"end\" passed=\"passed|failed|untested\" ... !!        clicks=NNNN msg=\"message\" opts !! !!    is executed !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_test_end !!     use M_framework, only: unit_test_start !!     use M_framework, only: unit_test !!     use M_framework, only: unit_test_end !!     implicit none !!     integer :: x !!     x=10 !!     call unit_test_start('myroutine') !! !!     call unit_test('myroutine', x > 3 ,'if big enough') !!     call unit_test('myroutine', x < 100 ,'if small enough') !! !!     ! program execution stopped !!     call unit_test_end ('myroutine',msg='checks on \"myroutine\"' ) !! !!     end program demo_unit_test_end !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_end ( name , msg , opts ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_5=\"@(#) M_framework__verify unit_test_end(3f) end checking procedure \"name\"\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: msg character ( len =* ), intent ( in ), optional :: opts character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local character ( len = 4096 ) :: out character ( len = 9 ) :: pf integer ( kind = int64 ) :: milliseconds integer ( kind = int64 ) :: clicks_now G_LONGEST = max ( G_LONGEST , len_trim ( name )) if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_G == 0 ) then PF = 'UNTESTED:' endif if ( duration /= 0.0d0 ) then call system_clock ( clicks_now ) milliseconds = ( julian () - duration ) * 1000 milliseconds = clicks_now - clicks write ( out , '(\"' // CHECK_PREFIX % check_end // '\",a,  & & 1x,a,                            & & \" GOOD: \",a,                     & & \" BAD: \" ,a,                     & & \" DURATION: \",i20.20             & & )' ) & & atleast_ ( name , G_LONGEST ), & & PF , & & atleast_ ( str ( IPASSED_G ), 9 ), & & atleast_ ( str ( IFAILED_G ), 9 ), & & milliseconds else milliseconds = 0 write ( out , '(\"' // CHECK_PREFIX % check_end // '\",a,1x,a,\" GOOD: \",a,1x,\" BAD: \",a)' ) & & atleast_ ( name , G_LONGEST ), PF , atleast_ ( str ( IPASSED_G ), 9 ), atleast_ ( str ( IFAILED_G ), 9 ) endif if ( present ( msg )) then if (. not . G_brief . or .( IFAILED_G + IPASSED_G . eq . 0 ). or . IFAILED_G . ne . 0 ) then call wrt ( G_luns , trim ( out ) // ': ' // trim ( msg )) call wrt ( G_luns , '' ) endif else if (. not . G_brief . or .( IFAILED_G + IPASSED_G . eq . 0 ). or . IFAILED_G . ne . 0 ) then call wrt ( G_luns , out ) call wrt ( G_luns , '' ) endif endif if ( G_command /= '' ) then ! if system command name is not blank call system command if ( ipassed_G + ifailed_G == 0 ) then call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"untested\" clicks=0' , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) elseif ( ifailed_G == 0 ) then call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"passed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) else call run ( str ( G_command , ' type=\"end\" name=\"' , name , '\" passed=\"failed\" clicks=' , milliseconds , ' msg=\"' , ndq ( msg ), '\" ' , sep = '' ) ) endif endif if ( ifailed_G == 0 ) then if (. not . G_keep_going ) stop 1 ! stop program depending on mode endif IPASSED_G = 0 IFAILED_G = 0 duration = 0.0d0 if ( paws ()) continue end subroutine unit_test_end !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_test_bad(3f) - [M_framework__verify] call command \"goodbad NAME !!    bad\" and stop program !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test_bad(name,msg,opts) !! !!     character(len=*),intent(in) :: name !!     character(len=*),intent(in),optional :: msg !!     character(len=*),intent(in),optional :: opts !! !!##DESCRIPTION !! !!    unit_test_bad(3f) calls the shell command !! !!         goodbad NAME bad [opts] !! !!    and stops the program. It is just a shortcut for calling !!         call unit_test(name,.false.) !!         call unit_test_end(name,msg,opts) !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_test_bad !!     use M_framework, only: unit_test_start, unit_test !!     use M_framework, only: unit_test_end, unit_test_stop !!     use M_framework, only: unit_test_bad !! !!     implicit none !!     integer :: x !!     x=10 !!     call unit_test_start('myroutine') !! !!     call unit_test('myroutine', x > 3 ,'if big enough') !!     call unit_test('myroutine', x < 100 ,'if small enough') !! !!     if(x /= 0)then !!       call unit_test_bad ('myroutine',msg='checks on \"myroutine\" failed') !!       ! program execution stopped !!     endif !!     call unit_test_end ('myroutine') !!     call unit_test_stop ('myroutine') !! !!     end program demo_unit_test_bad !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine unit_test_bad ( name , opts , msg ) ! ident_6=\"@(#) M_framework__verify unit_test_bad(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_test ( name ,. false .) call unit_test_end ( name , opts_local , msg_local ) end subroutine unit_test_bad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_test_good(3f) - [M_framework__verify] call command \"goodbad !!    NAME good\" !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_test_good(name,msg,opts) !! !!     character(len=*),intent(in)          :: name !!     character(len=*),intent(in),optional :: opts !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !!    A shortcut for !! !!       call unit_test(name,.true.) !!       call unit_test_end(name,opts,msg) !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_test_good !!     use M_framework, only: unit_test_start, unit_test_end !!     use M_framework, only: unit_test, unit_test_good !! !!     implicit none !!     integer :: x !!     x=10 !!     call unit_test_start('myroutine') !! !!     call unit_test('myroutine', x > 3 ,'if big enough') !!     call unit_test('myroutine', x < 100 ,'if small enough') !! !!     call unit_test_good('myroutine',msg='checks on \"myroutine\" ') !! !!     end program demo_unit_test_good !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_good ( name , msg , opts ) ! ident_7=\"@(#) M_framework__verify unit_test_good(3f) call 'goodbad NAME good'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( G_virgin % cmdline ) call cmdline_ () if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_test ( name ,. true ., msg = msg_local ) call unit_test_end ( name , opts_local ) end subroutine unit_test_good !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function atleast_ ( line , length ) result ( strout ) ! ident_8=\"@(#) M_framework__verify atleast_(3f) return string padded to at least specified length\" character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = max ( length , len ( trim ( line )))) :: strout strout = line end function atleast_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function julian () ! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! ident_9=\"@(#) M_framework__verify julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date\" real ( kind = realtime ) :: julian ! Julian Date (non-negative, but may be non-integer) integer :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN call date_and_time ( values = dat ) year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 end function julian !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine preset_globals () integer :: iostat character ( len = :), allocatable :: arg0 G_virgin % preset_globals = . false . G_cmdline = . true . G_debug = . false . G_keep_going = . true . unit_test_level = 0 unit_test_flags = [ integer :: ] !x!G_luns=[stderr] G_luns = [ stdout ] G_interactive = . false . G_match = repeat ( ' ' , 4096 ) G_command = repeat ( ' ' , 4096 ) open ( unit = 999 , status = 'scratch' , iostat = iostat ) !  values used in prefix column for various messages !CHECK_PREFIX=prefix( null(),null(),null(),null(),null()) !x!CHECK_PREFIX=prefix(                  & !x! check_MSG    =  'check_msg:   ', & !x! check        =  'check:       ', & !x! check_START  =  'check_start: ', & !x! check_STOP   =  'check_stop:  ', & !x! check_END    =  'check_end:   '  & !x!) !x!CHECK_PREFIX=prefix(             & !x! check_MSG    =  ':       ', & !x! check        =  ':       ', & !x! check_START  =  ':start: ', & !x! check_STOP   =  ':stop:  ', & !x! check_END    =  ':end:   '  & !x!) arg0 = getarg0_ () // ': ' CHECK_PREFIX = prefix ( & check_MSG = arg0 , & check = arg0 , & check_START = arg0 , & check_STOP = arg0 , & check_END = arg0 & ) end subroutine preset_globals !=================================================================================================================================== subroutine cmdline_ () use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options ! define arguments and their default values ! use naming convention of global variables to make parsing easier logical :: G_help = . false . integer , allocatable :: G_flags (:) integer :: G_level integer , allocatable :: G_luns_hold (:) ! NOTE: assume all names in namelist start with G_ or unit_test namelist / args / G_match namelist / args / G_level namelist / args / G_debug ! debug mode namelist / args / G_flags ! values that can be used to select different tests or any conditional integer test namelist / args / G_keep_going ! logical variable that can be used to turn off program termination on errors. namelist / args / G_command ! name of command to execute. Defaults to \" \". namelist / args / G_brief namelist / args / G_luns namelist / args / G_interactive namelist / args / G_help namelist / args / G_verbose namelist / args / G_silent !    Report the beginning and end of execution of each test case or suite !    Only run cases or collections whose description contains the given string !    Don't colorize the output character ( len = 4096 ), save :: input ( 3 ) = [ character ( len = 4096 ) :: '&args' , '' , ' /' ], arg character ( len = 256 ) :: message1 , message2 integer :: i , j , k , iostat , equal_pos , iend if ( G_virgin % preset_globals ) then call preset_globals () endif if ( G_virgin % cmdline ) then G_virgin % cmdline = . false . ! read arguments from command line G_level =- 1 G_luns_hold = G_luns G_luns = [ - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 ] G_flags = [( - 1 , i = 1 , 1000 )] do i = 1 , command_argument_count () call get_command_argument ( i , arg ) do j = 1 , len_trim ( arg ) ! blank out leading - or / so \"--name=value\" or \"/name=value\" works if ( index ( '/- ' , arg ( j : j )) == 0 ) exit arg ( j : j ) = ' ' enddo ! if variable name does not start with \"unit_test\" add \"G_\" prefix so can use a nice name ! on command line, on unit_test_mode, and public variables arg = adjustl ( arg ) if ( index ( arg , 'unit_test_' ) == 1 ) then arg = ' ' // adjustl ( arg ) else arg = ' G_' // adjustl ( arg ) endif ! if no equal sign add =T if ( index ( arg , '=' ) == 0 ) then arg = trim ( arg ) // '=T' endif iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = trim ( input ( 2 )) // ',' read ( input , nml = args , iostat = iostat , iomsg = message1 ) ! assume first failure might be because of missing quotes if ( iostat /= 0 ) then equal_pos = index ( arg , '=' ) ! find position of '=' if ( any ( G_luns < - 1 ) ) then G_luns = [ integer :: ] else G_luns = pack ( G_luns , G_luns /= - 1 ) ! if G_luns is all negative at this point set it to [stderr] if ( size ( G_luns ) == 0 ) G_luns = G_luns_hold endif if ( equal_pos /= 0 ) then ! requote and try again arg = arg (: equal_pos ) // '\"' // arg ( equal_pos + 1 : len_trim ( arg )) // '\"' iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = trim ( input ( 2 )) // ' ,' read ( input , nml = args , iostat = iostat , iomsg = message2 ) if ( iostat /= 0 ) then call wrt ( G_luns , 'ERROR UNQUOTED:' // trim ( message1 ) // ': when reading ' // trim ( input ( 2 ))) call wrt ( G_luns , 'ERROR QUOTED  :' // trim ( message2 ) // ': when reading ' // trim ( input ( 2 ))) G_command = trim ( G_command ) G_match = trim ( G_match ) if ( G_level == - 1 ) G_level = unit_test_level do k = 1 , size ( G_luns ) write ( G_luns ( k ), nml = args , delim = 'quote' ) enddo stop 2 endif else call wrt ( G_luns , 'ERROR:' // trim ( message1 ) // ': when reading ' // trim ( input ( 2 ))) G_command = trim ( G_command ) G_match = trim ( G_match ) if ( G_level == - 1 ) G_level = unit_test_level do k = 1 , size ( G_luns ) write ( G_luns ( k ), nml = args , delim = 'quote' ) enddo stop 4 endif endif enddo if ( any ( G_luns < - 1 ) ) then G_luns = [ integer :: ] else G_luns = pack ( G_luns , G_luns /= - 1 ) ! if G_luns is all negative at this point set it to [stderr] if ( size ( G_luns ) == 0 ) G_luns = G_luns_hold endif G_command = trim ( G_command ) G_match = trim ( G_match ) G_flags = pack ( G_flags , G_flags >= 0 ) if ( G_verbose ) G_flags = [ G_flags , 9997 , 9998 , 9999 ] ! turn on these flags if verbose mode if ( G_silent ) G_luns = [ 999 ] ! turn on these flags if verbose mode if ( size ( G_flags ) /= 0 ) unit_test_flags = G_flags if ( G_level /= - 1 ) unit_test_level = G_level ! some pre-defined level numbers if ( any ( unit_test_flags == 9997 )) then call wrt ( G_luns , 'This file was compiled by ' , compiler_version ()) endif if ( any ( unit_test_flags == 9998 )) then call wrt ( G_luns , ' using the options ' , compiler_options ()) endif if ( any ( unit_test_flags == 9999 )) then do i = 1 , size ( G_luns ) write ( G_luns ( i ), nml = args , delim = 'quote' ) enddo endif endif if ( G_help ) then write ( * , '(g0)' ) [ character ( len = 80 ) :: & 'NAME                                                                            ' , & '    unit_tests(1f) -- unit test command line options                            ' , & 'SYNOPSIS                                                                        ' , & ' CMD --level=0 --keep_going --flags=''10000*-1'' --command=\"\" --match=\"\"          ' , & ' luns=stderr,-1,-1,-1,-1 --verbose=F --brief=F --silent=F interactive=F         ' , & '                                                                                ' , & 'DESCRIPTION                                                                     ' , & '   When using the M_framework unit test routines options are read from the      ' , & '   command line of any program built with the interface by default. To prevent  ' , & '   the command line from being parsed in case the program already parses the    ' , & '   command line add \"call unit_test_mode(cmdline=.false.)\" to the calling       ' , & '   program.                                                                     ' , & 'OPTIONS                                                                         ' , & '--command=\"system_command\"  program to call after each test                     ' , & '--luns=L,M,N,...    list of unit numbers to write to, assumed opened by program ' , & '                            * 6   typically stdout                              ' , & '                            * 0   typically stderr                              ' , & '                            * 999 scratch file deleted when program ends        ' , & '--match=\"glob expression\"   string to be tested by \"matched\" argument on        ' , & '                            unit_test_start(3f)                                 ' , & '--level=N                   user-requested debug level. Sets \"unit_test_level\". ' , & '--keep_going=F              turn on program termination on test failure         ' , & '--flags=L,M,N,...           set value for user to set different test flags      ' , & '                               values >= 9990 are reserved                      ' , & '                                  * 9997 compiler version                       ' , & '                                  * 9998 compiler options                       ' , & '                                  * 9999 command line options NAMELIST group    ' , & '--help                      display this text and exit                          ' , & '--verbose                   verbose mode                                        ' , & '--brief                     only display messages of failed tests               ' , & '--silent                    no messages from unit_test procedures is produced   ' , & '--interactive                                                                   ' , & '--debug                                                                         ' , & '                                                                                ' , & 'Note flags => unit_test_flags(:) and level => unit_test_level, which are        ' , & 'public members of M_framework.                                                  ' , & 'EXAMPLES                                                                        ' , & ' sample commands:                                                               ' , & '  fpm test                                                                      ' , & '  fpm test -- luns=6 # write to stdout instead of stderr                        ' , & '  fpm test ''*regression*''  # run tests containing specified start string      ' , & '                                                                                ' , & '  # run a test called \"crash\" with gdb(1)                                       ' , & '  fpm test --target crash --runner \"gdb -ex run --quiet\"                        ' , & '                                                                                ' , & '  # run all the tests in the gdb(1) debugger (you can enter                     ' , & '  # \"q\" after each test has run; or enter gdb commands at the prompt):          ' , & '  fpm test --target ''*'' --verbose \\                                           ' , & '     --runner ''gdb -ex \"list, 0\" -ex run --quiet --args'' \\                    ' , & '     -- flags=9997,9998,9999 luns=6 level=3                                     ' , & ' ' ] G_help = . false . stop endif end subroutine cmdline_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_test_mode(3f) - [M_framework__verify] set testing modes !!    (LICENSE:PD) !!##SYNOPSIS !! !! !!      subroutine unit_test_mode( keep_going, flags, luns, command, & !!      brief, interactive, CMDLINE, debug, match) !! !!      logical,intent(in) :: keep_going, brief, interactive,debug !!      integer,intent(in),allocatable :: luns(:), flags(:) !!      character(len=*),intent(in) :: command !!##DESCRIPTION !!    unit_test_mode(3f) changes testing mode defaults !! !!##OPTIONS !!    keep_going   keep running if a test fails. Default to TRUE !!    flags        a list of integer values that can be accessed from !!                 M_framework as unit_test_flags(:) for use in !!                 selecting various tests conditionally !!    luns         list of Fortran units to unit test messages to. Defaults !!                 to the the value of ERROR_UNIT from the intrinsic module !!                 ISO_FORTRAN_ENV (ie. defaults to \"stderr\"). It is !!                 Assumed the units have been opened by the program. !!    match        the string that is tested against the name and msg !!                 specified on unit_test_start() to set the \"matched\" !!                 argument. !!    command      filter command, typically to generate reports. It is !!                 passed data on the command line. See the example filter !!                 \"bookkeeper\" for examples. !!    brief        If present only \"FAIL\" messages are produced. !! !!    brief        Only display FAIL messages and related information !!    verbose      verbose mode displays compiler version and options and !!                 all standard messages. !!    silent       no output from unit_test_*(3f) procedures !!    interactive  prompt as each test case starts as to continue. !!    cmdline      If set to .false. do not parse command line for options. !!    debug        Debug mode for the M_framework package !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unit_test_mode !!    use M_framework !!    implicit none !! !!    call unit_test_mode(keep_going=.false.,luns=[6], & !!            & brief=.true.) !! !!    end program demo_unit_test_mode !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_test_mode ( debug , keep_going , level , flags , command , brief , verbose , silent , cmdline , interactive , luns , match ) logical , optional , intent ( in ) :: debug logical , optional , intent ( in ) :: keep_going ! logical variable that can be used to turn off program termination on errors. logical , optional , intent ( in ) :: cmdline ! flag whether to parse command line for arguments or not logical , optional , intent ( in ) :: interactive logical , optional , intent ( in ) :: brief ! flag on whether to display SUCCESS: messages logical , optional , intent ( in ) :: verbose ! flag on whether to display all messages including additional information logical , optional , intent ( in ) :: silent ! do not output any messages from unit_test_*(3f) procedures character ( len =* ), optional , intent ( in ) :: command ! name of command to execute. Defaults to the name integer , optional , intent ( in ) :: flags (:) ! an  array that can be used to select different options integer , optional , intent ( in ) :: level ! an  integer that can be used to select different debug levels integer , optional , intent ( in ) :: luns (:) ! logical unit number to write output to character ( len =* ), optional , intent ( in ) :: match if ( G_virgin % preset_globals ) then call preset_globals () endif if ( present ( match )) G_match = match if ( present ( luns )) G_luns = luns if ( present ( command )) G_command = command if ( present ( debug )) G_debug = debug if ( present ( cmdline )) G_cmdline = cmdline if ( present ( interactive )) G_interactive = interactive if ( present ( keep_going )) G_keep_going = keep_going if ( present ( flags )) unit_test_flags = flags if ( present ( level )) unit_test_level = level if ( present ( brief )) G_brief = brief if ( present ( verbose )) G_verbose = verbose if ( present ( silent )) G_silent = silent !integer,parameter,public   :: realtime=kind(0.0d0)    ! type for julian days !integer,parameter,public   :: EXIT_SUCCESS=0 !integer,parameter,public   :: EXIT_FAILURE=1 end subroutine unit_test_mode !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_test_system(3f) - [M_framework__verify] return status from !!    system command !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function unit_test_system(cmd,verbose) !! !!     character(len=*),intent(in)  :: cmd !!     logical,intent(in),optional  :: verbose !!##DESCRIPTION !!    unit_test_system(3f) executes a system command and returns the !!    exit status of the command. !! !!##OPTIONS !!    command    system command to execute. If it starts with \"* \" the !!               asterisk is replaced by the name of the current command. !!               If it starts with \"** \" the asterisks are replaced by !!               the current command including arguments. !! !!    verbose    if .true. the executed command is echoed to output. The !!               default is .false. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unit_test_system !!    use M_framework, only: & !!       unit_test_start,  & !!       unit_test,        & !!       unit_test_system, & !!       unit_test_end !!    implicit none !!    if (command_argument_count()  ==  0) then !!       call unit_test_start('myroutine') !!       call unit_test('false', unit_test_system('false') == 0, 'check false') !!       call unit_test('true', unit_test_system('true') == 0, 'check true') !!       call unit_test('notthere', unit_test_system('notthere') == 0, & !!       & 'check notthere') !!       call unit_test('*',& !!       & unit_test_system('* and options', verbose=.true.) == 0, 'check \"*\"') !!       call unit_test_end('myroutine') !!    else !!       write (*, *) 'called with an option' !!    endif !!    end program demo_unit_test_system !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain function unit_test_system ( command , verbose ) result ( istat ) !  EXITSTAT contains the integer exit code of the command, as returned by SYSTEM. !  CMDSTAT is set to zero if the command line was executed (whatever its exit status was). !          If an error condition occurs and CMDSTAT is not present, error termination of execution of the image is initiated. !     It is assigned !      + the value -1 if the processor does not support command line execution, !      + a processor-dependent positive value if an error condition occurs !      + the value -2 if no error condition occurs but WAIT is present !        with the value false and the processor does not support asynchronous !        execution. !      + Otherwise it is assigned the value 0. !  CMDMSG is assigned an error message if an error has occurred. (exitstat or cmdstat or both?) !         If an error condition occurs, it is assigned a processor- dependent explanatory message. Otherwise, it is unchanged. character ( len =* ), intent ( in ) :: command logical , intent ( in ), optional :: verbose logical :: verbose_ integer :: istat logical , parameter :: wait = . true . integer :: exitstat integer :: cmdstat character ( len = 256 ) :: cmdmsg character ( len = :), allocatable :: command_ if ( present ( verbose )) then verbose_ = verbose else verbose_ = . false . endif command_ = adjustl ( command ) // '   ' if ( index ( command_ , '* ' ) == 1 ) then command_ = getarg0_ () // command_ ( 2 :) elseif ( index ( command_ , '** ' ) == 1 ) then command_ = getall_ () // command_ ( 2 :) endif if ( verbose_ ) call wrt ( G_luns , \"command: \" , command_ ) cmdmsg = ' ' call execute_command_line ( command_ , wait , exitstat , cmdstat , cmdmsg ) flush ( unit = 6 ) if ( cmdstat /= 0 ) then call wrt ( G_luns , \"cmdstat: \" , cmdmsg , 'for command :' , command_ ) elseif ( cmdmsg /= '' ) then call wrt ( G_luns , \"exitstat: \" , cmdmsg , 'for command :' , command_ ) endif istat = merge ( - cmdstat , exitstat , exitstat == 0. and . cmdstat /= 0 ) end function unit_test_system !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    getarg0_(3f) - [M_framework__verify:QUERY] get basename of the current executable !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function getarg0_() result(name) !! !!     character(len=:),allocatable         :: getarg0_ !! !!##DESCRIPTION !!    getarg0_(3f) returns the name of the current executable using !!    get_command_argument(3f) and inquire(3f). It returns only !!    the leaf name past the last backslash or slash and trims !!    the suffix \".exe\" as well. !! !!##EXAMPLES !! !!    Sample getting a pathname of current executable: !! !!      program demo_getarg0_ !!      use M_framework__verify, only : getarg0_ !!      implicit none !!         write(*,'(*(a))')'Running ',getarg0_() !!      end program demo_getarg0_ !! !!##AUTHOR !!        John S. Urban !! !!##LICENSE !!        Public Domain function getarg0_ () ! get the pathname of getarg0_ implicit none integer :: getarg0__length integer :: ios integer :: iend character ( len = 4096 ) :: long_name character ( len = :), allocatable :: getarg0_ getarg0__length = 0 getarg0_ = '' long_name = '' call get_command_argument ( 0 , length = getarg0__length , status = ios ) if ( ios == 0 ) then if ( allocated ( getarg0_ )) deallocate ( getarg0_ ) allocate ( character ( len = getarg0__length ) :: getarg0_ ) call get_command_argument ( 0 , getarg0_ , status = ios ) if ( ios == 0 ) then inquire ( file = getarg0_ , iostat = ios , name = long_name ) if ( ios == 0 ) then getarg0_ = trim ( long_name ) else getarg0_ = getarg0_ endif else getarg0_ = '' endif else getarg0_ = '' endif iend = index ( getarg0_ , '\\',back=.true.) if(iend.ne.0) then getarg0_=getarg0_(iend+1:) else iend=index(getarg0_,' / ',back=.true.) if(iend.ne.0)getarg0_=getarg0_(iend+1:) endif iend=len_trim(getarg0_) if(iend.gt.4)then if(getarg0_(iend-3:iend)==' . exe ')getarg0_=getarg0_(:iend-4) endif end function getarg0_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    getall_(3f) - [M_framework__verify:QUERY] get name of the current executable and options !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function getall_() result(name) !! !!     character(len=:),allocatable         :: getall_ !! !!##DESCRIPTION !!    getall_(3f) returns the name of the current executable !!    and all the arguments surrounded with double-quotes !! !!##EXAMPLES !! !!    Sample getting a pathname of current executable: !! !!      program demo_getall_ !!      use M_framework__verify, only : getall_ !!      implicit none !!         write(*,' ( * ( a )) ')' Running ',getall_() !!      end program demo_getall_ !! !!##AUTHOR !!        John S. Urban !! !!##LICENSE !!        Public Domain function getall_() result(command) ! get the pathname of arg implicit none character(len=:),allocatable :: arg integer                      :: length integer                      :: ios integer                      :: i character(len=:),allocatable :: command length=0 command='' do i=1,command_argument_count() call get_command_argument(i,length=length,status=ios) if(ios == 0)then if(allocated(arg))deallocate(arg) allocate(character(len=length) :: arg) call get_command_argument(0,arg,status=ios) if(ios == 0)then command=command//' \"'//arg//'\" ' endif endif enddo command=getarg0_()//command end function getall_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine run(command) ! convenience routine so command does not cause program to stop character(len=*)             :: command logical,parameter            :: wait=.true. integer                      :: exitstat integer                      :: cmdstat character(len=256)           :: cmdmsg if(G_verbose)call wrt(G_luns,\"+ \",command) cmdmsg=' ' call execute_command_line(command,wait,exitstat,cmdstat,cmdmsg) if(cmdstat /= 0)then call wrt(G_luns,\"cmdstat: \",cmdmsg,' for command : ',command) elseif(cmdmsg /= '')then call wrt(G_luns,\"exitstat: \",cmdmsg,' for command : ',command) endif end subroutine run !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! because of shell expansion just remove doublequote character from messages for now function ndq(string) result(out) character(len=*),intent(in)  :: string character(len=len(string))   :: out integer                      :: i do i=1,len(string) select case(string(i:i)) case(' \"');    out(i:i)=' ' case default; out(i:i)=string(i:i) end select enddo end function ndq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    glob_(3f) - [M_strings:COMPARE] compare given string for match to !!    a pattern which may contain globbing wildcard characters !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    logical function glob_(string, pattern ) !! !!     character(len=*),intent(in) :: string !!     character(len=*),intent(in) :: pattern !! !!##DESCRIPTION !!    glob_(3f) compares given (entire) STRING for a match to PATTERN which may !!    contain basic wildcard \" globbing \" characters. !! !!    To get a match the entire string must be described !!    by PATTERN. Trailing whitespace is significant, so trim the input !!    string to have trailing whitespace ignored. !! !!    Patterns like \" b * ba \" fail on a string like \" babababa \" because the !!    algorithm finds an early match. To skip over the early matches insert !!    an extra character at the end of the string and pattern that does !!    not occur in the pattern. Typically a NULL is used (char(0)). !! !!##OPTIONS !!    string   the input string to test to see if it contains the pattern. !!    pattern  the following simple globbing options are available !! !!             o \" ? \" matching any one character !!             o \" * \" matching zero or more characters. !!               Do NOT use adjacent asterisks. !!             o spaces are significant and must be matched or pretrimmed !!             o There is no escape character, so matching strings with !!               literal question mark and asterisk is problematic. !! !!##EXAMPLES !! !!   Example program !! !!    program demo_glob !!    use M_framework, only : unit_test_glob !!    implicit none !!    write(*,*)glob_('abcdabcd','*cd*') !!    write(*,*)glob_('abcdabcd','*no*') !!    end program demo_glob !! !!##AUTHOR !!   John S. Urban !! !!##REFERENCE !!   The article \" Matching Wildcards : An Empirical Way to Tame an Algorithm \" !!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014 !! !!##LICENSE !!   Public Domain function glob_(tame,wild) ! ident_10=\" @ ( # ) M_strings glob_ ( 3 f ) function compares text strings one of which can have wildcards ( '*' or '?' ). \" logical                    :: glob_ character(len=*)           :: tame       ! A string without wildcards character(len=*)           :: wild       ! A (potentially) corresponding string with wildcards character(len=len(tame)+1) :: tametext character(len=len(wild)+1) :: wildtext character(len=1),parameter :: NULL=char(0) integer                    :: wlen integer                    :: ti, wi integer                    :: i character(len=:),allocatable :: tbookmark, wbookmark ! These two values are set when we observe a wildcard character. They ! represent the locations, in the two strings, from which we start once we have observed it. tametext=tame//NULL wildtext=wild//NULL tbookmark = NULL wbookmark = NULL wlen=len(wild) wi=1 ti=1 do                                            ! Walk the text strings one character at a time. if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string? do i=wi,wlen                            ! Easy: unique up on it! if(wildtext(wi:wi) == '*')then wi=wi+1 else exit endif enddo if(wildtext(wi:wi) == NULL) then        ! \" x \" matches \" * \" glob_=.true. return endif if(wildtext(wi:wi)  /=  '?') then ! Fast-forward to next possible match. do while (tametext(ti:ti)  /=  wildtext(wi:wi)) ti=ti+1 if (tametext(ti:ti) == NULL)then glob_=.false. return                         ! \" x \" doesn't match \" * y * \" endif enddo endif wbookmark = wildtext(wi:) tbookmark = tametext(ti:) elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry. if(wbookmark /= NULL) then if(wildtext(wi:) /=  wbookmark) then wildtext = wbookmark wlen=len_trim(wbookmark) wi=1 ! Don't go this far back again. if (tametext(ti:ti)  /=  wildtext(wi:wi)) then tbookmark=tbookmark(2:) tametext = tbookmark ti=1 cycle                          ! \" xy \" matches \" * y \" else wi=wi+1 endif endif if (tametext(ti:ti) /= NULL) then ti=ti+1 cycle                             ! \" mississippi \" matches \" * sip * \" endif endif glob_=.false. return                                  ! \" xy \" doesn't match \" x \" endif ti=ti+1 wi=wi+1 if (ti > len(tametext)) then glob_=.false. return elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string? if(wildtext(wi:wi) /= NULL)then do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it! wi=wi+1                           ! \" x \" matches \" x * \" if(wildtext(wi:wi) == NULL)exit enddo endif if (wildtext(wi:wi) == NULL)then glob_=.true. return                               ! \" x \" matches \" x \" endif glob_=.false. return                                  ! \" x \" doesn't match \" xy \" endif enddo end function glob_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function paws() ! prompt for a letter and return try if \" y \" or \" Y \" ! maybe choice if default is T or F; maybe raw read (not portable though) ! originally was interactive with NAMELIST group for \" expected \" and \" answer \" that could be viewed ! option to pause on each unit_test(3f) as well or not; allow system commands; ... character ( len = 1 ) :: value integer :: iostat logical :: paws paws = . false . if ( G_interactive ) then write ( * , '(*(g0))' , advance = 'no' ) 'enter RETURN to continue:' read ( * , '(a)' , iostat = iostat ) value if ( iostat . eq . 0 ) then select case ( value ) case ( 'y' , 'Y' ) paws = . true . case default paws = . false . end select endif endif end function paws !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_test_expected(3f) - [M_framework__verify] report if two scalar values !!    of like type and kind are equal. !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    impure elemental subroutine unit_test_example(name,result,expected) !! !!     character(len=*),intent(in)  :: name !!     class(*),intent(in)          :: result !!     class(*),intent(in),optional :: expected !! !!##DESCRIPTION !!    A shortcut for a common call to unit_test(3f) tests the two values !!    of like type and kind. It is equivalent to !! !!        call unit_test(name,result,expected,'result=',result,'expected=',.true.) !! !!##OPTIONS !!     RESULT    A generated value or expression of integer, real, character, !!               or complex type. !!     EXPECTED  The expected value for RESULT, of the same type and kind !!               as RESULT. If not present, it is equivalent to .TRUE. !! !!##EXAMPLES !! !!   Sample program: !! !!       program demo_unit_test_expected !!       use, intrinsic :: iso_fortran_env, only: & !!       & stdin => input_unit, stdout => output_unit, stderr => error_unit !!       use M_framework, only:                & !!       &  unit_test_mode,                    & !!       &  start     =>  unit_test_start,     & !!       &  expected  =>  unit_test_expected,  & !!       &  stop      =>  unit_test_stop,      & !!       & unit_test_level ! , unit_test_flags !!       implicit none !!       logical, parameter :: T=.true., F=.false. !!       ! optional call to change default modes !!          call unit_test_mode(  & !!              keep_going=T,     & !!              flags=[0],        & !!              luns=[stderr],    & !!              command='',       & !!              brief=F,          & !!              match='',         & !!              interactive=F,    & !!              CMDLINE=T,        & !!              debug=F) !! !!          unit_test_level=0 !!          ! unit tests for ABS(3f) intrinsic !!          call start('abs') !!          ! integer !!          call expected('abs',abs(-10),10) !!          call expected('abs',abs( 10),10) !!          ! real and elemental !!          call expected('abs',abs( [-10.0, 10.0]),10.0) !!          ! complex !!          call expected('abs',abs(( 3.0,-4.0)),5.0) !!          call expected('abs',abs((-3.0, 4.0)),5.0) !!          call expected('abs',abs((-3.0,-4.0)),5.0) !!          call expected('abs',abs(( 3.0, 4.0)),5.0) !!          call stop('abs') !!       end program demo_unit_test_expected !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain impure elemental subroutine unit_test_expected_int32 ( name , result , expected ) character ( len =* ), intent ( in ) :: name integer ( kind = int32 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_int32 impure elemental subroutine unit_test_expected_int64 ( name , result , expected ) character ( len =* ), intent ( in ) :: name integer ( kind = int64 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_int64 impure elemental subroutine unit_test_expected_real32 ( name , result , expected ) character ( len =* ), intent ( in ) :: name real ( kind = real32 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_real32 impure elemental subroutine unit_test_expected_real64 ( name , result , expected ) character ( len =* ), intent ( in ) :: name real ( kind = real64 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_real64 impure elemental subroutine unit_test_expected_cmplx32 ( name , result , expected ) character ( len =* ), intent ( in ) :: name complex ( kind = real32 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_cmplx32 impure elemental subroutine unit_test_expected_cmplx64 ( name , result , expected ) character ( len =* ), intent ( in ) :: name complex ( kind = real64 ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_cmplx64 impure elemental subroutine unit_test_expected_char ( name , result , expected ) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: result , expected call unit_test ( name , result == expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_char impure elemental subroutine unit_test_expected_boolean ( name , result , expected ) character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: result , expected call unit_test ( name , result . eqv . expected , 'result=' , result , 'expected=' , expected ) end subroutine unit_test_expected_boolean impure elemental subroutine unit_test_expected_onoff ( name , result ) character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: result call unit_test ( name , result , 'result=' , result , 'expected=' ,. true .) end subroutine unit_test_expected_onoff !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_framework__verify !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/m_framework__verify.f90.html"},{"title":"M_framework__attr.f90 – M_framework","text":"Source Code !> !!##NAME !!    M_framework__attr(3f) - [M_framework__attr::INTRO] control text attributes on terminals !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!      use M_framework__attr, only : attr, attr_mode, attr_update !! !!##DESCRIPTION !!    M_framework__attr(3f) is a Fortran module that uses common ANSI escape sequences !!    to control terminal text attributes. !! !!         use M_framework__attr !!         write(*,*)attr('<red>Red Text!</red> <green>Green Text!</green>') !!         end !! !!    It is designed to use three simple procedures to !! !!     + Specify attributes using simple HTML-like syntax !!     + allow the sequences to be suppressed when desired !!     + permit the  user program to completely customize the keywords. !!       The user can add, delete and replace the sequences associated with !!       a keyword without changing the code. !! !!    One advantage of the approach of using formatting directives which !!    are replaced with in-band escape sequences is that it is easy to turn !!    off when running batch. !! !!    Another important capability is that programs can be run in \"raw\" mode !!    and create a simple text file with the formatting directives in it !!    that can then be read back in by a simple filter program that strips !!    it back to plain text( see app/plain.f90), or displays it to a screen !!    in color(see app/light.f90) or perhaps converts it to another format. !! !!    So this approach makes it trivial to read specially-formatted data !!    from a file like a message catalog (perhaps with various versions in !!    different languages) and colorize it or display it as plain text !! !!    By making each line self-contained (by default) lines can be filtered !!    by external utilities and still display correctly. !! !!##ACCESS !!    Via git(1): !! !!        git clone https://github.com/urbanjost/M_framework__attr.git !!        cd M_framework__attr/src !!        # change Makefile if not using one of the listed compilers !!        make clean; make gfortran    # for gfortran !!        make clean; make ifort       # for ifort !!        make clean; make nvfortran   # for nvfortran !! !!    This will compile the M_framework__attr module and example programs. !! !!    Alternatively, via fpm (see https://github.com/fortran-lang/fpm): !! !!         git clone https://github.com/urbanjost/M_framework__attr.git !! !!    or just list it as a dependency in your fpm.toml project file. !! !!         [dependencies] !!         M_framework__attr = { git = \"https://github.com/urbanjost/M_framework__attr.git\" } !! !!##LIMITATIONS !!   o colors are not nestable. !!   o keywords are case-sensitive, !!   o ANSI escape sequences are not universally supported by !!     all terminal emulators; and normally should be suppressed !!     when not going to a tty device. Therefore, you should use !!     M_system::system_istty(3f) or the common Fortran extension !!     ISATTY() to set the default to \"plain\" instead of \"color\" !!     when the output file is not a conforming terminal. On basic !!     MSWindows console windows, it is best to use Windows 10+ and/or !!     the Linux mode; you may have to enable ANSI escape sequence !!     mode on MSWindows. It does work as-is with CygWin and MinGW and !!     Putty windows and mintty(1) as tested. !! !!##EXAMPLES !! !!    Sample program !! !!     program demo_M_framework__attr !!     use M_framework__attr, only : attr, attr_mode, attr_update !!     implicit none !!     character(len=256) :: line !!     character(len=*),parameter :: f='( & !!      &\"   <bo><w><G> GREAT: </G></w>& !!      &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& !!      &)' !!     real :: value !! !!        write(*,'(a)')& !!        &attr('   <r><W><bo> ERROR: </W>red text on a white background</y>') !! !!        value=3.4567 !!        write(line,fmt=f) value !!        write(*,'(a)')attr(trim(line)) !! !!        ! write same string as plain text !!        write(*,*) !!        call attr_mode(manner='plain') !!        write(*,'(a)')attr(trim(line)) !! !!        call attr_mode(manner='color') !!        ! use pre-defined or user defined strings !!        write(*,*) !!        write(*,'(a)')attr('<ERROR> Woe is nigh.') !!        write(*,'(a)')attr('<WARNING> The night is young.') !!        write(*,'(a)')attr('<INFO> It is Monday') !! !!        ! create a custom mnemonic !!        call attr_update('MYERROR',attr(& !!        ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>'& !!        )) !!        write(*,*) !!        write(*,'(a)')attr('<MYERROR> my custom message style') !! !!     end program demo_M_framework__attr !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr(3f), attr_mode(3f), attr_update(3f) !! !!    Related information: !! !!     terminfo(3c), termlib(3c), tput(1), reset(1), clear(1), !!     console_codes(4), ECMA-48, !!     https://en.wikipedia.org/wiki/ANSI_escape_code module M_framework__attr use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_c_binding , only : c_int use , non_intrinsic :: M_framework__msg , only : str implicit none private public :: attr public :: attr_mode public :: attr_update private :: attr_matrix private :: attr_scalar private :: attr_scalar_width private :: get private :: locate ! find PLACE in sorted character array where value can be found or should be placed private :: insert ! insert entry into a sorted allocatable array at specified position private :: replace ! replace entry by index from a sorted allocatable array if it is present private :: remove ! delete entry by index from a sorted allocatable array if it is present private :: wipe_dictionary private :: vt102 interface attr module procedure attr_scalar module procedure attr_matrix module procedure attr_scalar_width end interface ! direct use of constant strings character ( len = :), allocatable , save :: keywords (:) character ( len = :), allocatable , save :: values (:) character ( len = :), allocatable , save :: mono_values (:) character ( len = :), allocatable , save :: mode ! mnemonics character ( len =* ), parameter :: NL = new_line ( 'a' ) ! New line character. ! DECIMAL ! *-------*-------*-------*-------*-------*-------*-------*-------* ! | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel| ! | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si | ! | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb| ! | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us | ! | 32 sp | 33  ! | 34  \" | 35  # | 36  $ | 37  % | 38  & | 39  ' | ! | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / | ! | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 | ! | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? | ! | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G | ! | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O | ! | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W | ! | 88  X | 89  Y | 90  Z | 91  [ | 92  \\ | 93  ] | 94  &#94; | 95  _ | ! | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g | ! |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o | ! |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w | ! |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del| ! *-------*-------*-------*-------*-------*-------*-------*-------* character ( len =* ), parameter :: nul = achar ( 0 ) character ( len =* ), parameter :: bel = achar ( 7 ) ! &#94;G beeps; character ( len =* ), parameter :: bs = achar ( 8 ) ! &#94;H backspaces one column (but not past the beginning of the line); character ( len =* ), parameter :: ht = achar ( 9 ) ! &#94;I goes to next tab stop or to the end of the line if there is no earlier tab stop character ( len =* ), parameter :: lf = achar ( 10 ) ! &#94;J character ( len =* ), parameter :: vt = achar ( 11 ) ! &#94;K character ( len =* ), parameter :: ff = achar ( 12 ) ! &#94;L all give a linefeed, and if LF/NL (new-line mode) is set also a carriage return character ( len =* ), parameter :: cr = achar ( 13 ) ! &#94;M gives a carriage return; character ( len =* ), parameter :: so = achar ( 14 ) ! &#94;N activates the G1 character set; character ( len =* ), parameter :: si = achar ( 15 ) ! &#94;O activates the G0 character set; character ( len =* ), parameter :: can = achar ( 24 ) ! &#94;X interrupt escape sequences; character ( len =* ), parameter :: sub = achar ( 26 ) ! &#94;Z interrupt escape sequences; character ( len =* ), parameter :: esc = achar ( 27 ) ! &#94;[ starts an escape sequence; character ( len =* ), parameter :: del = achar ( 127 ) ! is ignored; ! codes character ( len =* ), parameter :: CODE_START = esc // '[' ! Start ANSI code, \"\". character ( len =* ), parameter :: CODE_END = 'm' ! End ANSI code, \"m\". character ( len =* ), parameter :: CODE_RESET = CODE_START // '0' // CODE_END ! Clear all styles, \"0m\". character ( len =* ), parameter :: CLEAR_DISPLAY = CODE_START // '2J' character ( len =* ), parameter :: HOME_DISPLAY = CODE_START // 'H' character ( len =* ), parameter :: BELL = achar ( 7 ) character ( len =* ), parameter :: AT_BOLD = '1' , AT_ITALIC = '3' , AT_UNDERLINE = '4' , AT_INVERSE = '7' character ( len =* ), parameter :: BLACK = '0' , RED = '1' , GREEN = '2' , YELLOW = '3' , BLUE = '4' , MAGENTA = '5' , CYAN = '6' , WHITE = '7' , DEFAULT = '9' !prefixes character ( len =* ), parameter :: FG = '3' character ( len =* ), parameter :: BG = '4' character ( len =* ), parameter :: FG_INTENSE = '9' character ( len =* ), parameter :: BG_INTENSE = '10' character ( len =* ), parameter :: ON = '' character ( len =* ), parameter :: OFF = '2' ! foreground colors character ( len =* ), parameter , public :: fg_red = CODE_START // FG // RED // CODE_END character ( len =* ), parameter , public :: fg_cyan = CODE_START // FG // CYAN // CODE_END character ( len =* ), parameter , public :: fg_magenta = CODE_START // FG // MAGENTA // CODE_END character ( len =* ), parameter , public :: fg_blue = CODE_START // FG // BLUE // CODE_END character ( len =* ), parameter , public :: fg_green = CODE_START // FG // GREEN // CODE_END character ( len =* ), parameter , public :: fg_yellow = CODE_START // FG // YELLOW // CODE_END character ( len =* ), parameter , public :: fg_white = CODE_START // FG // WHITE // CODE_END character ( len =* ), parameter , public :: fg_ebony = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_black = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_default = CODE_START // FG // DEFAULT // CODE_END ! background colors character ( len =* ), parameter , public :: bg_red = CODE_START // BG // RED // CODE_END character ( len =* ), parameter , public :: bg_cyan = CODE_START // BG // CYAN // CODE_END character ( len =* ), parameter , public :: bg_magenta = CODE_START // BG // MAGENTA // CODE_END character ( len =* ), parameter , public :: bg_blue = CODE_START // BG // BLUE // CODE_END character ( len =* ), parameter , public :: bg_green = CODE_START // BG // GREEN // CODE_END character ( len =* ), parameter , public :: bg_yellow = CODE_START // BG // YELLOW // CODE_END character ( len =* ), parameter , public :: bg_white = CODE_START // BG // WHITE // CODE_END character ( len =* ), parameter , public :: bg_ebony = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_black = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_default = CODE_START // BG // DEFAULT // CODE_END ! attributes character ( len =* ), parameter , public :: bold = CODE_START // ON // AT_BOLD // CODE_END character ( len =* ), parameter , public :: italic = CODE_START // ON // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: inverse = CODE_START // ON // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: underline = CODE_START // ON // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: unbold = CODE_START // '22' // CODE_END character ( len =* ), parameter , public :: unitalic = CODE_START // OFF // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: uninverse = CODE_START // OFF // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: ununderline = CODE_START // OFF // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: reset = CODE_RESET character ( len =* ), parameter , public :: clear = HOME_DISPLAY // CLEAR_DISPLAY contains !> !!##NAME !!    attr(3f) - [M_framework__attr] substitute escape sequences for HTML-like syntax !!               in strings !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      function attr(string,reset) result (expanded) !! !!        ! scalar !!        character(len=*),intent(in)  :: string !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded !!        ! or array !!        character(len=*),intent(in)  :: string(:) !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded(:) !!        integer,intent(in),optional  :: chars !! !!##DESCRIPTION !!    Use HTML-like syntax to add attributes to terminal output such as !!    color on devices that recognize ANSI escape sequences. !! !!##OPTIONS !!    string        input string  of form !! !!                    \"<attribute_name>string</attribute_name> ...\". !! !!                   where the current attributes are color names, !!                   bold, italic, underline, ... !! !!    reset          By default, a sequence to clear all text attributes !!                   is sent at the end of each returned line if an escape !!                   character appears in the output string. This can be !!                   turned off by setting RESET to .false. . !! !!                   Note if turning off the reset attributes may be !!                   continued across lines, but if each line is not !!                   self-contained attributes may not display properly !!                   when filtered with commands such as grep(1). !! !!    chars          For arrays, a reset will be placed after the Nth !!                   displayable column count in order to make it easier !!                   to generate consistent right borders for non-default !!                   background colors for a text block. !!##KEYWORDS !!    primary default keywords !! !!      colors: !!        r,         red,       R,  RED !!        g,         green,     G,  GREEN !!        b,         blue,      B,  BLUE !!        m,         magenta,   M,  MAGENTA !!        c,         cyan,      C,  CYAN !!        y,         yellow,    Y,  YELLOW !!        e,         ebony,     E,  EBONY !!        w,         white,     W,  WHITE !! !!      attributes: !!        it,        italic !!        bo,        bold !!        un,        underline !! !!      basic control characters: !!       nul !!       bel  (0x07, &#94;G) beeps; !!       bs   (0x08, &#94;H) backspaces one column (but not past the beginning of !!                       the line); !!       ht   (0x09, &#94;I) goes to the next tab stop or to the end of the line if !!                       there is no earlier tab stop; !!       lf   (0x0A, &#94;J), !!       vt   (0x0B, &#94;K) !!       ff   (0x0C, &#94;L) all give a linefeed, and if LF/NL (new-line mode) is !!                       set also a carriage return !!       cr   (0x0D, &#94;M) gives a carriage return; !!       so   (0x0E, &#94;N) activates the G1 character set; !!       si   (0x0F, &#94;O) activates the G0 character set; !!       can  (0x18, &#94;X) and SUB (0x1A, &#94;Z) interrupt escape sequences; !!       sub !!       esc  (0x1B, &#94;[) starts an escape sequence; !!       del  (0x7F) is ignored; !! !!      other: !!        clear !!        default !!        reset !!        gt !!        lt !!        save,DECSC     Save  current state (cursor coordinates, attributes, !!                       character sets pointed at by G0, G1). !!        restore,DECRC  Restore state most recently saved by ESC 7. !!        CSI            \"Control Sequence Introducer\"(0x9B) is equivalent to !!                       \"ESC [\". !! !!      dual-value (one for color, one for mono): !! !!        write(*,*)attr('<ERROR>an error message') !!        write(*,*)attr('<WARNING>a warning message') !!        write(*,*)attr('<INFO>an informational message') !! !!    By default, if the color mnemonics (ie. the keywords) are uppercase !!    they change the background color. If lowercase, the foreground color. !!    When preceded by a \"/\" character the attribute is returned to the !!    default. !! !!    The \"default\" keyword is typically used explicitly when reset=.false, !!    and sets all text attributes to their initial defaults. !! !!##LIMITATIONS !!    o colors are not nestable, keywords are case-sensitive, !!    o not all terminals obey the sequences. On Windows, it is best if !!      you use Windows 10+ and/or the Linux mode; although it has worked !!      with all CygWin and MinGW and Putty windows and mintty. !!    o you should use \"<gt>\" and \"<lt>\" instead of \">\" and \"<\" in a string !!      processed by attr(3f) instead of in any plain text output so that !!      the raw mode will create correct input for the attr(3f) function !!      if read back in. !! !!##EXAMPLES !! !!    Sample program !! !!     program demo_attr !!     use M_framework__attr, only : attr, attr_mode, attr_update !!        call printstuff('defaults') !! !!        call attr_mode(manner='plain') !!        call printstuff('plain:') !! !!        call printstuff('raw') !! !!        call attr_mode(manner='color') !!        call printstuff('') !! !!        write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:') !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[25m') !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!     contains !!     subroutine printstuff(label) !!     character(len=*),intent(in)  :: label !!     character(len=:),allocatable :: array(:) !!       call attr_mode(manner=label) !! !!       array=[character(len=60) ::    & !!        'TEST MANNER='//label,                      & !!        '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>',      & !!        '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>', & !!        '<w>WHITE</w> and <e>EBONY</e>'] !!       write(*,'(a)') attr(array) !! !!       write(*,'(a)') attr('Adding <bo>bold</bo>') !!       write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>') !!       write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>') !!       write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>') !! !!       write(*,'(a)') attr('Adding <ul>underline</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <ul>italic</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <in>inverse</in>') !!       write(*,'(a)') attr('<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& !!        &<b>BLUE</b></it></ul></bo></in>') !!       write(*,'(a)') attr('<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& !!        &<y>YELLOW</it></y></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>') !!     end subroutine printstuff !!     end program demo_attr !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr_mode(3f), attr_update(3f) function attr_scalar ( string , reset ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset logical :: clear_at_end character ( len = :), allocatable :: padded character ( len = :), allocatable :: expanded character ( len = :), allocatable :: name integer :: i integer :: ii integer :: maxlen integer :: place if ( present ( reset )) then clear_at_end = reset else clear_at_end = . true . endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( mode == 'raw' ) then expanded = string return endif maxlen = len ( string ) padded = string // ' ' i = 1 expanded = '' do select case ( padded ( i : i )) case ( '>' ) ! should not get here unless unmatched i = i + 1 expanded = expanded // '>' case ( '<' ) ! assuming not nested for now ii = index ( padded ( i + 1 :), '>' ) if ( ii . eq . 0 ) then expanded = expanded // '<' i = i + 1 else name = padded ( i + 1 : i + ii - 1 ) name = trim ( adjustl ( name )) call locate ( keywords , name , place ) if ( mode . eq . 'plain' ) then expanded = expanded // get ( name ) elseif ( place . le . 0 ) then ! unknown name; print what you found expanded = expanded // padded ( i : i + ii ) maxlen = maxlen - ii - 1 else expanded = expanded // get ( name ) endif i = ii + i + 1 endif case default expanded = expanded // padded ( i : i ) i = i + 1 end select if ( i >= maxlen + 1 ) exit enddo if ( ( index ( expanded , esc ). ne . 0 ). and .( clear_at_end )) then if (( mode . ne . 'raw' ). and .( mode . ne . 'plain' )) then expanded = expanded // CODE_RESET ! Clear all styles endif endif expanded = expanded end function attr_scalar function attr_matrix ( strings , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: strings (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) ! gfortran does not return allocatable array from a function properly, but works with subroutine call kludge_bug ( strings , reset , chars , expanded ) end function attr_matrix subroutine kludge_bug ( strings , reset , chars , expanded ) character ( len =* ), intent ( in ) :: strings (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) integer :: width character ( len = :), allocatable :: hold integer :: i integer :: right integer :: len_local allocate ( character ( len = 0 ) :: expanded ( 0 )) if ( present ( chars )) then right = chars else right = len ( strings ) endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif do i = 1 , size ( strings ) if ( mode . eq . 'color' ) then mode = 'plain' len_local = len ( attr_scalar ( strings ( i ))) hold = trim ( strings ( i )) // repeat ( ' ' , max ( 0 , right - len_local )) mode = 'color' else hold = strings ( i ) endif hold = trim ( attr_scalar ( hold , reset = reset )) width = max ( len ( hold ), len ( expanded )) expanded = [ character ( len = width ) :: expanded , hold ] enddo end subroutine kludge_bug function attr_scalar_width ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset integer , intent ( in ) :: chars character ( len = :), allocatable :: expanded_arr (:) character ( len = :), allocatable :: expanded expanded_arr = attr_matrix ([ string ], reset , chars ) expanded = expanded_arr ( 1 ) end function attr_scalar_width subroutine vt102 () ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list call wipe_dictionary () ! insert and replace entries call attr_update ( 'bold' , bold ) call attr_update ( '/bold' , unbold ) call attr_update ( 'bo' , bold ) call attr_update ( '/bo' , unbold ) call attr_update ( 'italic' , italic ) call attr_update ( '/italic' , unitalic ) call attr_update ( 'it' , italic ) call attr_update ( '/it' , unitalic ) call attr_update ( 'inverse' , inverse ) call attr_update ( '/inverse' , uninverse ) call attr_update ( 'in' , inverse ) call attr_update ( '/in' , uninverse ) call attr_update ( 'underline' , underline ) call attr_update ( '/underline' , ununderline ) call attr_update ( 'un' , underline ) call attr_update ( '/un' , ununderline ) call attr_update ( 'ul' , underline ) call attr_update ( '/ul' , ununderline ) call attr_update ( 'bell' , BELL ) call attr_update ( 'nul' , nul ) call attr_update ( 'bel' , bel ) call attr_update ( 'bs' , bs ) call attr_update ( 'ht' , ht ) call attr_update ( 'lf' , lf ) call attr_update ( 'vt' , vt ) call attr_update ( 'ff' , ff ) call attr_update ( 'cr' , cr ) call attr_update ( 'so' , so ) call attr_update ( 'si' , si ) call attr_update ( 'can' , can ) call attr_update ( 'sub' , sub ) call attr_update ( 'esc' , esc ) call attr_update ( 'escape' , esc ) call attr_update ( 'del' , del ) call attr_update ( 'save' , esc // '7' ) call attr_update ( 'DECSC' , esc // '7' ) call attr_update ( 'restore' , esc // '8' ) call attr_update ( 'DECRC' , esc // '8' ) call attr_update ( 'CSI' , esc // '[' ) call attr_update ( 'clear' , clear ) call attr_update ( 'reset' , reset ) call attr_update ( 'gt' , '>' , '>' ) call attr_update ( 'lt' , '<' , '<' ) ! foreground colors call attr_update ( 'r' , fg_red ) call attr_update ( '/r' , fg_default ) call attr_update ( 'red' , fg_red ) call attr_update ( '/red' , fg_default ) call attr_update ( 'fg_red' , fg_red ) call attr_update ( '/fg_red' , fg_default ) call attr_update ( 'c' , fg_cyan ) call attr_update ( '/c' , fg_default ) call attr_update ( 'cyan' , fg_cyan ) call attr_update ( '/cyan' , fg_default ) call attr_update ( 'fg_cyan' , fg_cyan ) call attr_update ( '/fg_cyan' , fg_default ) call attr_update ( 'm' , fg_magenta ) call attr_update ( '/m' , fg_default ) call attr_update ( 'magenta' , fg_magenta ) call attr_update ( '/magenta' , fg_default ) call attr_update ( 'fg_magenta' , fg_magenta ) call attr_update ( '/fg_magenta' , fg_default ) call attr_update ( 'b' , fg_blue ) call attr_update ( '/b' , fg_default ) call attr_update ( 'blue' , fg_blue ) call attr_update ( 'fg_blue' , fg_blue ) call attr_update ( '/fg_blue' , fg_default ) call attr_update ( 'g' , fg_green ) call attr_update ( '/g' , fg_default ) call attr_update ( 'green' , fg_green ) call attr_update ( '/green' , fg_default ) call attr_update ( 'fg_green' , fg_green ) call attr_update ( '/fg_green' , fg_default ) call attr_update ( 'y' , fg_yellow ) call attr_update ( '/y' , fg_default ) call attr_update ( 'yellow' , fg_yellow ) call attr_update ( '/yellow' , fg_default ) call attr_update ( 'fg_yellow' , fg_yellow ) call attr_update ( '/fg_yellow' , fg_default ) call attr_update ( 'w' , fg_white ) call attr_update ( '/w' , fg_default ) call attr_update ( 'white' , fg_white ) call attr_update ( '/white' , fg_default ) call attr_update ( 'fg_white' , fg_white ) call attr_update ( '/fg_white' , fg_default ) call attr_update ( 'e' , fg_ebony ) call attr_update ( '/e' , fg_default ) call attr_update ( 'ebony' , fg_ebony ) call attr_update ( '/ebony' , fg_default ) call attr_update ( 'fg_ebony' , fg_ebony ) call attr_update ( '/fg_ebony' , fg_default ) call attr_update ( 'x' , fg_ebony ) call attr_update ( '/x' , fg_default ) call attr_update ( 'black' , fg_ebony ) call attr_update ( '/black' , fg_default ) call attr_update ( 'fg_black' , fg_ebony ) call attr_update ( '/fg_black' , fg_default ) ! background colors call attr_update ( 'R' , bg_red ) call attr_update ( '/R' , bg_default ) call attr_update ( 'RED' , bg_red ) call attr_update ( '/RED' , bg_default ) call attr_update ( 'bg_red' , bg_red ) call attr_update ( '/bg_red' , bg_default ) call attr_update ( 'C' , bg_cyan ) call attr_update ( '/C' , bg_default ) call attr_update ( 'CYAN' , bg_cyan ) call attr_update ( '/CYAN' , bg_default ) call attr_update ( 'bg_cyan' , bg_cyan ) call attr_update ( '/bg_cyan' , bg_default ) call attr_update ( 'M' , bg_magenta ) call attr_update ( '/M' , bg_default ) call attr_update ( 'MAGENTA' , bg_magenta ) call attr_update ( '/MAGENTA' , bg_default ) call attr_update ( 'bg_magenta' , bg_magenta ) call attr_update ( '/bg_magenta' , bg_default ) call attr_update ( 'B' , bg_blue ) call attr_update ( '/B' , bg_default ) call attr_update ( 'BLUE' , bg_blue ) call attr_update ( '/BLUE' , bg_default ) call attr_update ( 'bg_blue' , bg_blue ) call attr_update ( '/bg_blue' , bg_default ) call attr_update ( 'G' , bg_green ) call attr_update ( '/G' , bg_default ) call attr_update ( 'GREEN' , bg_green ) call attr_update ( '/GREEN' , bg_default ) call attr_update ( 'bg_green' , bg_green ) call attr_update ( '/bg_green' , bg_default ) call attr_update ( 'Y' , bg_yellow ) call attr_update ( '/Y' , bg_default ) call attr_update ( 'YELLOW' , bg_yellow ) call attr_update ( '/YELLOW' , bg_default ) call attr_update ( 'bg_yellow' , bg_yellow ) call attr_update ( '/bg_yellow' , bg_default ) call attr_update ( 'W' , bg_white ) call attr_update ( '/W' , bg_default ) call attr_update ( 'WHITE' , bg_white ) call attr_update ( '/WHITE' , bg_default ) call attr_update ( 'bg_white' , bg_white ) call attr_update ( '/bg_white' , bg_default ) call attr_update ( 'E' , bg_ebony ) call attr_update ( '/E' , bg_default ) call attr_update ( 'EBONY' , bg_ebony ) call attr_update ( '/EBONY' , bg_default ) call attr_update ( 'bg_ebony' , bg_ebony ) call attr_update ( '/bg_ebony' , bg_default ) call attr_update ( 'X' , bg_ebony ) call attr_update ( '/X' , bg_default ) call attr_update ( 'BLACK' , bg_ebony ) call attr_update ( '/BLACK' , bg_default ) call attr_update ( 'bg_black' , bg_ebony ) call attr_update ( '/bg_black' , bg_default ) ! compound call attr_update ( 'ERROR' , fg_red // bold // bg_ebony // ':error:  ' // bg_default // fg_default , ':error:' ) call attr_update ( 'WARNING' , fg_yellow // bold // bg_ebony // ':warning:' // bg_default // fg_default , ':warning:' ) call attr_update ( 'INFO' , fg_green // bold // bg_ebony // ':info:   ' // bg_default // fg_default , ':info:' ) end subroutine vt102 !> !!##NAME !!    attr_mode(3f) - [M_framework__attr] select processing mode for output from attr(3f) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine attr_mode(manner) !! !!        character(len=*),intent(in) :: manner !! !!##DESCRIPTION !!    Turn off the generation of strings associated with the HTML keywords !!    in the string generated by the attr(3f) function, or display the !!    text in raw mode as it was passed to attr(3f) or return to ANSI !!    escape control sequence generation. !! !!##OPTIONS !!    MANNER  The current manners or modes supported via the attr_mode(3f) !!             procedure are !! !!         plain          suppress the output associated with keywords !!         color(default) commonly supported escape sequences !!         raw            echo the input to attr(3f) as its output !!         reload         restore original keyword meanings deleted or !!                        replaced by calls to attr_update(3f). !! !!##EXAMPLES !! !!    Sample program !! !!     program demo_attr_mode !!     use M_framework__attr, only : attr, attr_mode !!     implicit none !!     character(len=:),allocatable :: lines(:) !!     character(len=:),allocatable :: outlines(:) !!     integer :: i !!        lines=[character(len=110):: & !!        &'<M><y>',& !!        &'<M><y>  Suffice it to say that black and white are also colors',& !!        &'<M><y>  for their simultaneous contrast is as striking as that ',& !!        &'<M><y>  of green and red, for instance. & !!        & --- <y><bo>Vincent van Gogh</bo></y>',& !!        &' '] !! !!        outlines=attr(lines,chars=57) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!        call attr_mode(manner='plain') ! write as plain text !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='raw')   ! write as-is !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='ansi')  ! return to default mode !! !!     end program demo_attr_mode !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode subroutine wipe_dictionary () if ( allocated ( keywords )) deallocate ( keywords ) allocate ( character ( len = 0 ) :: keywords ( 0 )) if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 0 ) :: values ( 0 )) if ( allocated ( mono_values )) deallocate ( mono_values ) allocate ( character ( len = 0 ) :: mono_values ( 0 )) end subroutine wipe_dictionary !> !!##NAME !!    attr_update(3f) - [M_framework__attr] update internal dictionary given keyword !!                      and value !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    subroutine attr_update(key,val) !! !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: val !!     character(len=*),intent(in),optional  :: mono_val !! !!##DESCRIPTION !!    Update internal dictionary in M_framework__attr(3fm) module. !! !!##OPTIONS !!    key       name of keyword to add, replace, or delete from dictionary !!    val       if present add or replace value associated with keyword. If !!              not present remove keyword entry from dictionary. !!    mono_val  if present add or replace second value associated with !!              keyword used for plain text mode. !!              Must only be specified if VAL is also specified. !! !!##KEYWORDS !!    The following keywords are defined by default !! !!    colors: !! !!      r,red     c,cyan     w,white !!      g,green   m,magenta  e,ebony !!      b,blue    y,yellow !! !!    If the color keywords are capitalized they control the text background !!    instead of the text color. !! !!    attributes: !! !!      ul,underline !!      it,italics (often produces inverse colors on many devices !! !!##EXAMPLES !! !!    Sample program !! !!      program demo_update !!      use M_framework__attr, only : attr, attr_update !!         write(*,'(a)') attr('<clear>TEST CUSTOMIZATIONS:') !!         ! add custom keywords !!         call attr_update('blink',char(27)//'[5m') !!         call attr_update('/blink',char(27)//'[25m') !!         write(*,*) !!         write(*,'(a)') attr('<blink>Items for Friday</blink>') !!         call attr_update('ouch',attr( & !!         ' <R><bo><w>BIG mistake!</R></w> ')) !!         write(*,*) !!         write(*,'(a)') attr('<ouch> Did not see that coming.') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!         ! delete !!         call attr_update('r') !!         call attr_update('/r') !!         ! replace (or create) !!         call attr_update('b','<<<<') !!         call attr_update('/b','>>>>') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!      end program demo_update !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else if ( mode . eq . 'plain' ) then valout = trim ( mono_values ( place )) else valout = trim ( values ( place )) endif endif end function get subroutine locate ( list , value , place , ier , errmsg ) character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = nint ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif end subroutine locate subroutine remove ( list , place ) character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif end subroutine remove subroutine replace ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif end subroutine replace subroutine insert ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine insert end module M_framework__attr","tags":"","url":"sourcefile/m_framework__attr.f90.html"},{"title":"M_framework__approx.F90 – M_framework","text":"Source Code !----------------------------------------------------------------------------------------------------------------------------------- #define  __INTEL_COMP        1 #define  __GFORTRAN_COMP     2 #define  __NVIDIA_COMP       3 #define  __NAG_COMP          4 #define  __LLVM_FLANG_COMP   5 #define  __UNKNOWN_COMP   9999 #define FLOAT128 #ifdef __INTEL_COMPILER #   define __COMPILER__ __INTEL_COMP #elif __GFORTRAN__ == 1 #   define __COMPILER__ __GFORTRAN_COMP #elif __flang__ #   undef FLOAT128 #   warning  NOTE: REAL128 not supported #   define __COMPILER__ __LLVM_FLANG_COMP #elif __NVCOMPILER #   undef FLOAT128 #   warning  NOTE: REAL128 not supported #   define __COMPILER__ __NVIDIA_COMP #else #   define __COMPILER__ __UNKNOWN_COMP #   warning  NOTE: UNKNOWN COMPILER #endif !----------------------------------------------------------------------------------------------------------------------------------- module M_framework__approx use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 !  1           2           4           8 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 !  4           8          10 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT ! access computing environment implicit none private ! COMPARING AND ROUNDING FLOATING POINT VALUES public :: almost ! function compares two numbers only up to a specified number of digits public :: accdig ! compare two real numbers only up to a specified number of digits public :: in_margin ! check if two reals are approximately equal using a relative margin public :: round_to_power ! round val to specified number of digits after the decimal point public :: round ! round val to specified number of significant digits public :: significant ! round val to specified number of significant digits public :: compare_float public :: change_default_ulp public :: operator (. equalto .) public :: operator (. greaterthan .) public :: operator (. lessthan .) !=========================== ! deprecated public :: sp_accdig ! compare two real numbers only up to a specified number of digits public :: dp_accdig ! compare two double numbers or other kinds only up to a specified number of digits interface dp_accdig ! for backward compatibility, accdig(3f) preferred module procedure accdig end interface dp_accdig !=========================== interface significant module procedure significant_real32 module procedure significant_real64 end interface significant private :: anyscalar_to_realbig_ private :: anyscalar_to_double_ interface compare_float module procedure compare_float_real32 module procedure compare_float_real64 #ifdef FLOAT128 module procedure compare_float_real128 #endif end interface compare_float interface operator (. equalto .) module procedure is_equal_to_real32 module procedure is_equal_to_real64 #ifdef FLOAT128 module procedure is_equal_to_real128 #endif end interface operator (. equalto .) interface operator (. greaterthan .) module procedure is_greater_than_real32 module procedure is_greater_than_real64 #ifdef FLOAT128 module procedure is_greater_than_real128 #endif end interface operator (. greaterthan .) interface operator (. lessthan .) module procedure is_less_than_real32 module procedure is_less_than_real64 #ifdef FLOAT128 module procedure is_less_than_real128 #endif end interface operator (. lessthan .) real ( kind = real64 ), save , private :: default_ulp = 1.0_real64 contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    almost(3f) - [M_framework__approx] return true or false if two numbers !!    agree up to specified number of digits !!    (LICENSE:PD) !!##SYNOPSIS !! !!    elemental impure function almost(x,y,digits,verbose) !! !!     class(*),intent(in)         :: x,y !!     class(*),intent(in)         :: rdigits !!     logical,intent(in),optional :: verbose !!     logical                     :: almost !! !!##DESCRIPTION !!    Returns true or false depending on whether the two numbers given agree !!    to within the specified number of digits as calculated by ACCDIG(3f). !!##OPTIONS !!    x,y      expected and calculated values to be compared. May be of !!             type REAL, INTEGER, or DOUBLEPRECISION. !!    rdigits  number of digits of precision to compare. May be INTEGER or !!             REAL. !!    verbose  optional value that specifies to print the results of the !!             comparison when set to .TRUE.. !!##RETURNS !!    almost   TRUE if the input values compare up to the specified number !!             of values !!##EXAMPLES !! !!   sample: !! !!    program demo_almost !!    use M_framework__approx, only : almost !!    implicit none !!    real    :: x, y !!    logical :: z !!    integer :: i !!    x=1.2345678 !!    y=1.2300000 !!    do i=1,8 !!       z=almost(x,y,i,verbose=.true.) !!       write(*,*)i,z !!    enddo !!    end program demo_almost !! !!   Results: !! !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 1.00000000 !!     >            1 T !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 2.00000000 !!     >            2 T !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 3.00000000 !!     >            3 F !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 4.00000000 !!     >            4 F !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 5.00000000 !!     >            5 F !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 6.00000000 !!     >            6 F !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 7.00000000 !!     >            7 F !!     > *sp_accdig* significant digit request too high= 8.00000000 !!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ... !!     > digits out of requested 8.00000000 !!     >            8 F !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain elemental impure function almost ( x , y , digits , verbose ) use M_framework__journal , only : journal ! ident_1=\"@(#) M_framework__approx almost(3f) function compares two real numbers up to specified number of digits by calling ACCDIG(3f)\" class ( * ), intent ( in ) :: x , y class ( * ), intent ( in ) :: digits logical , intent ( in ), optional :: verbose logical :: almost logical :: verbose_local real :: acurcy real :: digits_local integer :: ind if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif digits_local = anyscalar_to_realbig_ ( digits ) acurcy = 0.0 select type ( x ) type is ( real ) select type ( y ) type is ( real ) call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif class default call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select class default call accdig ( x , y , digits , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select if ( ind == 0 ) then almost = . true . else almost = . false . endif end function almost !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    sp_accdig(3f) - [M_framework__approx] compare two real numbers of !!    default kind only up to a specified number of digits !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!       subroutine sp_accdig(x,y,digio,acurcy,ind) !! !!        real,intent(in)     :: X !!        real,intent(in)     :: Y !!        real,intent(in)     :: DIGI0 !!        real,intent(out)    :: acurcy !!        integer,intent(out) :: ind !! !!##DESCRIPTION !!    This procedure is used to check how closely two numbers agree. !! !!       call sp_accdig(X,Y,DIGI0,ACURCY,IND) !! !!    The values X and Y are the numbers to compare, and DIGI0 is the !!    threshold number of digits to consider significant in returning IND. !! !!    If X and Y are considered equal within DIGI0 relative tolerance, !! !!        IND    = 0, if tolerance is     satisfied. !!               = 1, if tolerance is not satisfied. !! !!    The result ACURCY gives a measure of the number of leading digits in X !!    which are the same as the number of leading digits in Y. !! !!            ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0 !!            ACURCY=-log10(X-Y)       if X != Y and Y = 0 !!            ACURCY=8                 if X=Y !! !!            ACURCY is never less than -8 or greater than 8 !! !!    TOLERANCE ... !!         X and Y are considered equal within DIGI0 relative tolerance, !!         if ACURCY is greater than DIGI0. !! !!    For example, Take some numbers and compare them to 1.2345678 ... !! !!        > ================================================ !!        > A number     |    ACURCY       |   ACURCY !!        >              |    1.2345678=Y  |   1.2345678=X !!        > ================================================ !!        >  1.234680    |    3.7900571    |   3.7901275 !!        >  1.2345378   |    4.6144510    |   4.6144404 !!        >  2.2234568   |    0.096367393  |   0.35188114 !!        >  1.2345678   |    8.0000000    |   8.0000000 !!        >  1.2345679   |    7.0732967    |   7.0731968 !!        > -1.2345678   |   -0.30103000   |  -0.30103000 !!        > 76.234567    |   -1.7835463    |   0.0070906729 !!        >  2.4691356   |    0.0          |   0.3010300 !!        >  0.0         |    0.0          |  -0.91514942. !! !!    Due to the typical limits of the log function, the number of !!    significant digits in the result is best considered to be three. !! !!    Notice that 1.2345678=Y produces different values than 1.2345678=X !! !!    A negative result indicates the two values being compared either do !!    not agree in the first digit or they differ with respect to sign. An !!    example of two numbers which do not agree in their leading digit (and !!    actually differ in order of magnitude) is given above by X=76.234567 !!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of !!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678; !!    here the accuracy reported is -0.30103000. !! !!##EXAMPLES !! !! !!   Example program: !! !!    program demo_sp_accdig ! fortran 90 example !!    use M_framework__approx, only : sp_accdig !!    implicit none !!    integer :: digi !!    integer :: i10, i20, i30 !!    integer :: ind, ind1, ind2 !!    real    :: acurcy, acurcy1, acurcy2 !!    real    :: a, b !!    real    :: vals(9) !!    data vals/ & !!      &1.234680,   1.2345378,  2.2234568, 1.2345678, & !!      &1.2345679, -1.2345678, 76.234567,  2.4691356, & !!      &0.0/ !!       write(*,*)'=========================' !!       do i10=0,16 !!          a=1.0 !!          b=a+1.0/(10.0**i10) !!          call sp_accdig(a,b,8.0,acurcy,ind) !!          write(*,*)i10,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       digi=16 !!       do i20=0,digi !!          a=1.0 !!          b=a+1.0/(10.0**i20) !!          call sp_accdig(a,b,real(digi),acurcy,ind) !!          write(*,*)i20,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       do i30=1,9 !!          call sp_accdig(1.2345678,vals(i30),8.0,acurcy1,ind1) !!          call sp_accdig(vals(i30),1.2345678,8.0,acurcy2,ind2) !!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2 !!       enddo !!    end program demo_sp_accdig !! !!##REFERENCES !! !!   based on ... !! !!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. accdig V 7.00  2/14/90. ** !!       David Hogben, !!       Statistical Engineering Division, !!       Center for Computing and Applied Mathematics, !!       A337 Administration Building, !!       National Institute of Standards and Technology, !!       Gaithersburg, MD 20899 !!                      TELEPHONE 301-975-2845 !!           ORIGINAL VERSION -  October, 1969. !!            CURRENT VERSION - February, 1990. !!            JSU     VERSION - February, 1991. !! !!##DEPENDENCIES !!    o M_framework__journal(),log10(), abs(1) !! !!##AUTHOR !!    David Hogben, John S. Urban !! !!##LICENSE !!    Public Domain !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- SUBROUTINE sp_accdig ( X , Y , digi0 , ACURCY , IND ) use M_framework__journal , only : journal implicit none ! ident_2=\"@(#) M_framework__approx sp_accdig(3f) compare two real numbers only up to a specified number of digits\" !     INPUT ... real , intent ( in ) :: x ! First  of two real numbers to be compared. real , intent ( in ) :: y ! Second of two real numbers to be compared. real , intent ( in ) :: digi0 ! Number of digits to be satisfied in relative tolerance. !     OUTPUT ... real , intent ( out ) :: acurcy ! = -LOG10(ABS((X-Y)/Y))) integer , intent ( out ) :: ind ! = 0, If tolerance is     satisfied. ! = 1, If tolerance is not satisfied. real :: diff real :: digi integer , parameter :: ireal_significant_digits = int ( log10 ( 2. ** digits ( 0.0 ))) ! maximum number of significant digits in a real number. digi = digi0 if ( digi <= 0 ) then call journal ( 'sc' , '*sp_accdig* bad number of significant digits=' , digi ) digi = ireal_significant_digits elseif ( digi > ireal_significant_digits ) then call journal ( 'sc' , '*sp_accdig* significant digit request too high=' , digi ) digi = min ( digi , real ( ireal_significant_digits )) endif diff = x - y if ( diff == 0.0 ) then acurcy = ireal_significant_digits elseif ( y == 0.0 ) then acurcy = - log10 ( abs ( x )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif END SUBROUTINE sp_accdig !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!      accdig(3f) - [M_framework__approx] compare two numbers only up to !!      a specified number of digits !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       elemental impure subroutine accdig(x,y,digio,acurcy,ind) !! !!        class(*),intent(in)  :: X !!        class(*),intent(in)  :: Y !!        class(*),intent(in)  :: DIGI0 !!        real,intent(out)     :: acurcy !!        integer,intent(out)  :: ind !! !!##DESCRIPTION !! !!    This procedure is used to check how closely two numbers agree. !! !!       call accdig(X,Y,DIGI0,ACURCY,IND) !! !!    The values X and Y are the numbers to compare, and DIGI0 is the !!    threshold number of digits to consider significant in returning IND. !! !!    If X and Y are considered equal within DIGI0 relative tolerance, !! !!        IND    = 0, if tolerance is     satisfied. !!               = 1, if tolerance is not satisfied. !! !!    The result ACURCY gives a measure of the number of leading digits in X !!    which are the same as the number of leading digits in Y. !! !!         ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0 !!         ACURCY=-log10(X-Y)       if X != Y and Y = 0 !!         ACURCY=8                 if X=Y !! !!         ACURCY is never less than -8 or greater than 8 for 32-bit REAL values !! !!    TOLERANCE ... !!         X and Y are considered equal within DIGI0 relative tolerance, !!         if ACURCY is greater than DIGI0. !! !!    For example, Take some numbers and compare them  to 1.2345678 ... !! !!       >  ================================================ !!       >  A number     |    ACURCY       |   ACURCY !!       >               |    1.2345678=Y  |   1.2345678=X !!       >  ================================================ !!       >   1.234680    |    3.7900571    |   3.7901275 !!       >   1.2345378   |    4.6144510    |   4.6144404 !!       >   2.2234568   |    0.096367393  |   0.35188114 !!       >   1.2345678   |    8.0000000    |   8.0000000 !!       >   1.2345679   |    7.0732967    |   7.0731968 !!       >  -1.2345678   |   -0.30103000   |  -0.30103000 !!       >  76.234567    |   -1.7835463    |   0.0070906729 !!       >   2.4691356   |    0.0          |   0.3010300 !!       >   0.0         |    0.0          |  -0.91514942. !! !!    Due to the typical limits of the log function, the number of !!    significant digits in the result is best considered to be three. !! !!    Notice that 1.2345678=Y produces different values than 1.2345678=X !! !!    A negative result indicates the two values being compared either do !!    not agree in the first digit or they differ with respect to sign. An !!    example of two numbers which do not agree in their leading digit (and !!    actually differ in order of magnitude) is given above by X=76.234567 !!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of !!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678; !!    here the accuracy reported is -0.30103000. !! !!##EXAMPLES !! !! !!   Example program: !! !!    program demo_accdig ! fortran 90 example !!    use M_framework__approx, only : accdig !!    implicit none !!    integer         :: digi !!    doubleprecision :: a, b !!    integer         :: i10, i20, i30 !!    integer         :: ind, ind1, ind2 !!    real            :: acurcy, acurcy1, acurcy2 !!    doubleprecision :: vals(9) !!    data vals/ & !!      &1.234680d0,   1.2345378d0,  2.2234568d0, 1.2345678d0, & !!      &1.2345679d0, -1.2345678d0, 76.234567d0,  2.4691356d0, & !!      &0.0d0/ !!       write(*,*)'=========================' !!       do i10=0,16 !!          a=1.0d0 !!          b=a+1.0d0/(10.0d0**i10) !!          call accdig(a,b,8.0,acurcy,ind) !!          write(*,*)i10,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       digi=16 !!       do i20=0,digi !!          a=1.0d0 !!          b=a+1.0d0/(10.0d0**i20) !!          call accdig(a,b,dble(digi),acurcy,ind) !!          write(*,*)i20,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       do i30=1,9 !!          call accdig(1.2345678d0,vals(i30),8.0,acurcy1,ind1) !!          call accdig(vals(i30),1.2345678d0,8.0,acurcy2,ind2) !!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2 !!       enddo !!    end program demo_accdig !! !!##NOTES !!##REFERENCES !! !!   based on ... !! !!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. ** !!       David Hogben, !!       Statistical Engineering Division, !!       Center for Computing and Applied Mathematics, !!       A337 Administration Building, !!       National Institute of Standards and Technology, !!       Gaithersburg, MD 20899 !!                      TELEPHONE 301-975-2845 !!           ORIGINAL VERSION -  October, 1969. !!            CURRENT VERSION - February, 1990. !!            JSU     VERSION - February, 1991. !! !!##DEPENDENCIES !!         o M_framework__journal(), log10(), abs(1) !! !!##AUTHORS !!      David Hogben, John S. Urban !! !!##LICENSE !!      Public Domain !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- elemental impure SUBROUTINE accdig ( x , y , digi0 , ACURCY , IND ) #ifdef FLOAT128 use , intrinsic :: iso_fortran_env , only : wp => real128 #else use , intrinsic :: iso_fortran_env , only : wp => real64 #endif use M_framework__journal , only : journal implicit none ! ident_3=\"@(#) M_framework__approx accdig(3f) compare two values only up to a specified number of digits\" !  INPUT ... class ( * ), intent ( in ) :: x ! FIRST  OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: y ! SECOND OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: digi0 ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE. real ( kind = wp ) :: x_local real ( kind = wp ) :: y_local !  OUTPUT ... real , intent ( out ) :: acurcy ! = -LOG10(ABS((x_local-y_local)/y_local))) integer , intent ( out ) :: ind ! = 0, IF TOLERANCE IS     SATISFIED. ! = 1, IF TOLERANCE IS NOT SATISFIED. real ( kind = wp ) :: diff real ( kind = wp ) :: digi ! Maximum number of significant digits in a number of biggest real kind. integer , parameter :: idble_significant_digits = int ( log10 ( 2.0_wp ** digits ( 0.0_wp ))) x_local = anyscalar_to_realbig_ ( x ) y_local = anyscalar_to_realbig_ ( y ) digi = anyscalar_to_realbig_ ( digi0 ) if ( digi <= 0 ) then call journal ( 'sc' , '*accdig* bad number of significant digits=' , real ( digi , kind = wp )) digi = idble_significant_digits elseif ( digi > idble_significant_digits ) then call journal ( 'sc' , '*accdig* significant digit request too high=' , real ( digi , kind = wp )) digi = min ( digi , real ( idble_significant_digits , kind = wp )) endif diff = x_local - y_local if ( diff == 0.0_wp ) then acurcy = idble_significant_digits elseif ( y_local == 0.0_wp ) then acurcy = - log10 ( abs ( x_local )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y_local )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif end subroutine accdig !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!   in_margin(3f) - [M_framework__approx] check if two reals are !!   approximately equal using a relative margin !! !!##SYNOPSIS !! !!     elemental pure function in_margin( expected_value, measured_value, !!     allowed_margin ) !! !!      real, intent(in)    :: expected_value !!      real, intent(in)    :: measured_value !!      real, intent(in)    :: allowed_margin !!      class(*),intent(in) :: invalue !! !!##DESCRIPTION !!   Compare two values to see if they are relatively equal using the !!   specified allowed margin. That is, see if VALUE_MEASURED is in !!   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error !!   varies with the magnitude of the values, such that the allowed error !!   is margin * average magnitude of measured and expected). !! !!   So the allowed error is smaller when the magnitudes are smaller. !! !!##OPTIONS !!   expected_value   First value !!   measured_value   Second value !!   allowed_margin   Allowed relative margin !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_in_margin !!    use :: M_framework__approx, only : in_margin !!    implicit none !!    write(*,*) in_margin(4.00000,3.99999,0.000000001) !!    write(*,*) in_margin(4.00000,3.99999,0.00000001) !!    write(*,*) in_margin(4.00000,3.99999,0.0000001) !!    write(*,*) in_margin(4.00000,3.99999,0.000001) !! !!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], & !!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.000001) !!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], & !!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.00001) !! !!    write(*,*) in_margin(4.00000,3.99999,0.00001) !!    write(*,*) in_margin(4.00000,3.99999,0.0001) !!    write(*,*) in_margin(4.00000,3.99999,0.001) !!    write(*,*) in_margin(4.00000,3.99999,0.01) !! !!    end program demo_in_margin !! !!   Results: !! !!        > F !!        > F !!        > F !!        > F !!        > F F F F F !!        > F F F F T !!        > T !!        > T !!        > T !!        > T !=================================================================================================================================== elemental impure function in_margin ( expected_value , measured_value , allowed_margin ) implicit none ! ident_4=\"@(#) M_framework__approx in_margin(3f) check if two reals are approximately equal using a relative margin\" class ( * ), intent ( in ) :: expected_value , measured_value , allowed_margin logical :: in_margin doubleprecision :: expected , measured , margin expected = anyscalar_to_double_ ( expected_value ) measured = anyscalar_to_double_ ( measured_value ) margin = anyscalar_to_double_ ( allowed_margin ) if ( abs ( expected - measured ) > 0.50d0 * margin * ( abs ( expected ) + abs ( measured )) ) then in_margin = . false . ! values not comparable else in_margin = . true . ! values comparable endif end function in_margin !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function round_to_power ( val , n ) ! ident_5=\"@(#) M_framework__approx round_to_power(3f) round val to specified given decimal (power) position\" real , intent ( in ) :: val integer , intent ( in ) :: n real :: round_to_power round_to_power = anint ( val * 1 0.0 ** n ) / 1 0.0 ** n end function round_to_power !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function round ( val , idigits0 ) implicit none ! ident_6=\"@(#) M_framework__approx round(3f) round val to specified number of significant digits\" integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ), intent ( in ) :: val integer , intent ( in ) :: idigits0 integer :: idigits , ipow real ( kind = dp ) :: aval , rnormal real ( kind = dp ) :: round !  this does not work very well because of round-off errors. !  Make a better one, probably have to use machine-dependent bit shifting ! make sure a reasonable number of digits has been requested idigits = max ( 1 , idigits0 ) aval = abs ( val ) !  select a power that will normalize the number !  (put it in the range 1 > abs(val) <= 0) if ( aval >= 1 ) then ipow = int ( log10 ( aval ) + 1 ) else ipow = int ( log10 ( aval )) endif rnormal = val / ( 1 0.0d0 ** ipow ) if ( rnormal == 1 ) then ipow = ipow + 1 endif !normalize, multiply by 10*idigits to an integer, and so on round = real ( anint ( val * 1 0.d0 ** ( idigits - ipow ))) * 1 0.d0 ** ( ipow - idigits ) end function round !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   significant(3f) - [M_framework__approx] round val to specified number !!   of significant digits !! !!##SYNOPSIS !! !!     pure elemental function significant(val,digits,round) !! !!      real,intent(in)                      :: val !!      integer,intent(in)                   :: digits !!      character(len=*),intent(in),optional :: round !!      real                                 :: significant !! !!##DESCRIPTION !! !! Round real value to specified number of significant digits !! !!##OPTIONS !! !! val     value to round !! digits  number of significant digits to produce !! round   Use the round edit descriptor !! !!           RU  UP : the value resulting from conversion shall be the !!                    smallest representable value that is greater than or !!                    equal to the original value !!           RD  DOWN : the value resulting from conversion shall be the !!                    largest representable value that is less than or !!                    equal to the original value !!           RZ  ZERO : the value resulting from conversion shall be the value !!                    closest to the original value and no greater in !!                    magnitude than the original value. !!           RN  NEAREST : modeis NEAREST,thevalueresulting from conversion !!                        shall be the closer of the two nearest !!                        representable values if one is closer than the !!                        other. If the two nearest representable values !!                        are equidistant from the original value, it is !!                        processor dependent which one of them is chosen. !!           RC  COMPATIBLE : the value resulting from conversion shall be !!                          the closer of the two nearest representable !!                          values or the value away from zero if halfway !!                          between them. !!           RP  PROCESSOR_DEFINED : rounding during conversion shall be !!                                   a processor-dependent default mode, !!                                   which may correspond to one of the !!                                   other modes. !! !!##EXAMPLES !! !!  Sample program !! !!    program demo_significant !!    use M_framework__approx, only : significant !!    implicit none !!    character(len=*),parameter :: g='(*(g0.7,1x))' !! !!       write(*,g)significant([8765.43210,0.1234567890],5) !! !!       write(*,*)'default:',1.23456789012345 !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9]) !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RU'),'RU' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RD'),'RD' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RZ'),'RZ' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RN'),'RN' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RC'),'RC' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RP'),'RP' !!    end program demo_significant !! !!   Results: !! !!       > 8765.400 .1234600 !!       >  default:   1.234568 !!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ... !!       > 1.234568 1.234568 1.234568 !!       > 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ... !!       > 1.234568 1.234568 1.234568 RU !!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ... !!       > 1.234567 1.234568 1.234568 RD !!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ... !!       > 1.234567 1.234568 1.234568 RZ !!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ... !!       > 1.234568 1.234568 1.234568 RN !!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ... !!       > 1.234568 1.234568 1.234568 RC !!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ... !!       > 1.234568 1.234568 1.234568 RP pure elemental function significant_real32 ( val , digits , round ) result ( significant ) ! ident_7=\"@(#) M_framework__approx significant_real32(3f) round val to specified number of significant digits\" integer , parameter :: wp = real32 real ( kind = wp ), intent ( in ) :: val integer , intent ( in ) :: digits character ( len =* ), intent ( in ), optional :: round real ( kind = wp ) :: significant character ( len = 80 ) :: line , fmt if ( present ( round )) then write ( fmt , '(\"(\",a,\",e0.\",i0,\")\")' ) trim ( round ), digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE else write ( fmt , '(\"(e0.\",i0,\")\")' ) digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE endif write ( line , fmt ) val ! write with specified number of significant diguts read ( line , '(e80.30)' ) significant ! read back into a value end function significant_real32 !----------------------------------------------------------------------------------------------------------------------------------- pure elemental function significant_real64 ( val , digits , round ) result ( significant ) ! ident_8=\"@(#) M_framework__approx significant_real64(3f) round val to specified number of significant digits\" integer , parameter :: wp = real64 real ( kind = wp ), intent ( in ) :: val integer , intent ( in ) :: digits character ( len =* ), intent ( in ), optional :: round real ( kind = wp ) :: significant character ( len = 80 ) :: line , fmt if ( present ( round )) then write ( fmt , '(\"(\",a,\",d0.\",i0,\")\")' ) trim ( round ), digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE else write ( fmt , '(\"(d0.\",i0,\")\")' ) digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE endif write ( line , fmt ) val ! write with specified number of significant diguts read ( line , '(d80.30)' ) significant ! read back into a value end function significant_real64 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function anyscalar_to_realbig_ ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit #ifdef FLOAT128 use , intrinsic :: iso_fortran_env , only : wp => real128 #else use , intrinsic :: iso_fortran_env , only : wp => real64 #endif implicit none ! ident_9=\"@(#) M_framework__approx anyscalar_to_realbig_(3f) convert integer or real parameter of any kind to real128 or biggest available\" class ( * ), intent ( in ) :: valuein real ( kind = wp ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = wp ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = wp ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = wp ) #ifdef FLOAT128 Type is ( real ( kind = real128 )); d_out = valuein #endif type is ( logical ); d_out = merge ( 0.0_wp , 1.0_wp , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !!d_out=huge(0.0_wp) readable = 'NaN' read ( readable , * ) d_out !!stop '*M_framework__approx::anyscalar_to_realbig_: unknown type' end select end function anyscalar_to_realbig_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function anyscalar_to_double_ ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_10=\"@(#) M_framework__approx anyscalar_to_double_(3f) convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out doubleprecision , parameter :: big = huge ( 0.0d0 ) select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) #ifdef FLOAT128 Type is ( real ( kind = real128 )) #endif !!if(valuein > big)then !!   write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein !!endif d_out = dble ( valuein ) type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out !type is (real(kind=real128)) !   if(valuein > big)then !      write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein !   endif !   d_out=dble(valuein) class default d_out = 0.0d0 !!stop '*M_framework__approx::anyscalar_to_double_: unknown type' end select end function anyscalar_to_double_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    compare_float(3f) - [M_framework__approx] compare floating point !!    values with adjustable tolerance. !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     result = compare_float( x, y,ulp = SCALING_VALUE) !! !!      elemental function (x,y,ulp) !!      real(kind=KIND),intent(in) :: x,y !!      real|integer,intent(in),optional :: ulp !! !!     Additional convenience operators: !! !!        X.equalto.Y !!        X.lessthan.Y !!        X.greaterthan.Y !! !!     Developer procedure (Do not use in production): !! !!       change_default_ulp(ulp) !! !!##DESCRIPTION !!    compare_float(3f) is a function for comparing floating point numbers !!    within an automatically adjusted tolerance. !! !!    The test performed is !! !!        abs( x - y ) < ( ulp * spacing( max(abs(x),abs(y)) ) ) !! !!    where ULP is a user-selected scaling factor that defaults to 1. The !!    default is intentionally low so that default behavior is close to !!    that of the default operators. Setting it to zero(0.0) essentially !!    causes no values to compare equal. !! !!    If the result is .TRUE., the numbers are considered equal. Both single !!    and double precision scalar and array values can be compared, as the !!    function is elemental. !! !!    By definition of an elemental function the returned data entity is the !!    same shape as the input array size or scalar if all values are scalar. !! !!    It can be useful to empirically test your code for numeric !!    sensitivities by changing the value of the ULP scaling factor and !!    noting any result changes. !! !!    As a convenience relational operators .EqualTo., .GreaterThan., !!    and .LessThan. are provided. Note the comparisons return .TRUE> !!    if the difference between the two values is .lt., .ge., and .le. . !!    The algorithm for each operator is shown in the following OPERATORS !!    section. !! !!    The default ULP value is 1.0. A procedure is available to change the !!    default but it should only be used for examining code behavior during !!    development, as it changes the default for calls from all procedures !!    (even those in other modules or procedures). !! !!       call default_ulp(ulp=VALUE) !! !!##DETAILS !! !!    It is generally acknowledged that real numbers should not be compared !!    directly but within some tolerance. However, the magnitude of an !!    appropriate tolerance value will vary depending on the magnitudes !!    of the numbers being compared and the precision of the computing !!    environment. !! !!    The Fortran standard does not specify functions or operators !!    specifically for comparing float values, but leaves some latitude !!    in how the compilers address floating point comparisons. It does !!    specify functions that return platform-specific values useful in !!    applying different methods to the problem such as !! !!     + epsilon(3f)       - Epsilon function !!     + nearest(3f)       - Nearest representable number !!     + spacing(3f)       - Smallest distance between two numbers of a given type !!     + rrspacing(3f)     - Reciprocal of the relative spacing of a numeric type !! !!    and in some cases !! !!     + scale(3f)         - Scale a real value by a whole power of the radix !!     + digits(3f)        - Significant digits in the numeric model !!     + exponent(3f)      - Exponent of floating-point number !!     + fraction(3f)      - Fractional part of the model representation !!     + huge(3f)          - Largest number of a type and kind !!     + maxexponent(3f)   - Maximum exponent of a real kind !!     + minexponent(3f)   - Minimum exponent of a real kind !!     + precision(3f)     - Decimal precision of a real kind !!     + radix(3f)         - Base of a numeric model !!     + range(3f)         - Decimal exponent range of a numeric kind !!     + set_exponent(3f)  - real value with specified exponent !!     + tiny(3f)          - Smallest positive number of a real kind !! !!    Books have been written on the behavior of floating point math. !! !!    As is used here, a commonly used simple floating point !!    comparison algorithm is !! !!        if(abs(x < y) < (ulp * spacing(max(abs(x),abs(y))))) then !!          : !!        endif !! !!    where the intrinsic function SPACING(3f) determines the distance !!    between the argument X and the nearest adjacent representable number !!    of the same type and ULP is an optional user-supplied scaling factor. !! !!##OPTIONS !! !!    x,y   Two congruent floating point values to compare. !! !!    ulp   The ULP (\"unit in the last place\") scaling value allows for !!          users to control the scaling of the value returned by SPACING(3f) !!          in order to relax or tighten what is considered \"equal\". That !!          is, the ULP value can be used to scale the comparison based !!          on knowledge of the \"numerical quality\" of the values being used !!          in the comparison. !! !!          The value should be positive. The absolute value of the value is !!          taken if it is negative. !! !!          The default ULP scaling value is 1.0. !! !!          The value may be of type integer or real. !! !!          A 0.5 ULP maximum error is the best you could hope for, since !!          this corresponds to always rounding to the nearest representable !!          floating point number. !! !!##RESULT !! !!    The return value is a logical value indicating whether the inputs !!    are equal to within the requested precision. !! !!##OPERATORS !! !! Additional operators based on compare_float(3f) are included: !! !! X.equalto.Y  If the result is .TRUE., the numbers are considered equal. !!              The test performed is !! !!                abs( x - y ) < spacing( max(abs(x),abs(y)) ) !! !! X.greaterthan.Y  If the result is .TRUE., x is considered greater than y. !!                  The result is a logical value indicating whether the !!                  operand x is greater than y by more than the spacing !!                  between representable floating point numbers. !! !!                  The test performed is !! !!                   ( x - y ) >= SPACING( MAX(ABS(x),ABS(y)) ) !! !! X.lessthan.Y  Test if one operand is less than another. !!               The result is a logical value indicating whether !!               the operand x is less than y by more than the !!               spacing between representable floating point !!               numbers. !! !!               The test performed is !! !!                  ( y - x ) >= SPACING( MAX(ABS(x),ABS(y)) ) !! !!               If the result is .TRUE., x is considered less than y. !! !!##EXAMPLES !! !!  Sample programs: !! !!    program demo_compare_float !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    use,intrinsic :: iso_fortran_env, only : error_unit,output_unit !!    use M_framework__approx,          only : compare_float !!    use M_framework__approx,          only : & !!    & operator(.equalto.), operator(.greaterthan.), operator(.lessthan.) !!    implicit none !!    integer,parameter       :: wp=int32 !!    integer                 :: i !!    character(len=80),save  :: line='10*0.1' !!    real(kind=wp)           :: a(10), x, y, ulp !!       write(*,*)'is 10*0.1 == 1.0?' !!       ! sum up 0.1 ten times hopefully in a manner compiler does not !!       ! optimize it and in the process make it equal !!       a=0.1_wp !!       read(line,*)a !!       x=sum(a) !!       y=1.0_wp !!       write(*, *)merge('    EQUAL ','NOT EQUAL!',x .eq. y) !!       write(*,'(*(g0,1x,z0,1x))')x,x,y,y ! show decimal and hexadecimal value !!       write(*, *)'regular',x .eq. y, x .gt. y, x .lt. y ! standard operators !!       ! For the default ULP=1.0, the relational operators can be used !!       write(*, *)'compare',x .equalto. y, x .greaterthan. y, x .lessthan. y !!       do i=0,10 !!          ulp=real(i,kind=wp)/2.0 !!          write(*,*) i, compare_float( x, y, ulp=ulp ) ,'ULP=',ulp !!       enddo !!    end program demo_compare_float !! !!  Results: !! !!     >  is 10*0.1 == 1.0? !!     >  NOT EQUAL! !!     > 1.00000012 3F800001 1.00000000 3F800000 !!     >  regular F T F !!     >  compare F T F !!     >            0 F ULP=   0.00000000 !!     >            1 F ULP=  0.500000000 !!     >            2 F ULP=   1.00000000 !!     >            3 T ULP=   1.50000000 !!     >            4 T ULP=   2.00000000 !!     >            5 T ULP=   2.50000000 !!     >            6 T ULP=   3.00000000 !!     >            7 T ULP=   3.50000000 !!     >            8 T ULP=   4.00000000 !!     >            9 T ULP=   4.50000000 !!     >           10 T ULP=   5.00000000 subroutine change_default_ulp ( ulp ) ! developer routine for changing default ulp class ( * ), intent ( in ) :: ulp default_ulp = abs ( anyscalar_to_double_ ( ulp )) end subroutine change_default_ulp elemental function compare_float_real32 ( x , y , ulp ) result ( compare ) integer , parameter :: wp = real32 real ( kind = wp ), intent ( in ) :: x real ( kind = wp ), intent ( in ) :: y class ( * ), optional , intent ( in ) :: ulp logical :: compare real ( kind = wp ) :: rel if ( present ( ulp ) ) then rel = abs ( anyscalar_to_double_ ( ulp )) else rel = default_ulp endif compare = abs ( x - y ) < ( rel * spacing ( max ( abs ( x ), abs ( y )) ) ) end function compare_float_real32 elemental function is_less_than_real32 ( x , y ) result ( less_than ) integer , parameter :: wp = real32 real ( kind = wp ), intent ( in ) :: x , y logical :: less_than if ( ( y - x ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then less_than = . true . else less_than = . false . endif end function is_less_than_real32 elemental function is_greater_than_real32 ( x , y ) result ( greater_than ) integer , parameter :: wp = real32 real ( kind = wp ), intent ( in ) :: x , y logical :: greater_than if ( ( x - y ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then greater_than = . true . else greater_than = . false . endif end function is_greater_than_real32 elemental function is_equal_to_real32 ( x , y ) result ( equal_to ) integer , parameter :: wp = real32 real ( kind = wp ), intent ( in ) :: x , y logical :: equal_to equal_to = abs ( x - y ) < spacing ( max ( abs ( x ), abs ( y )) ) end function is_equal_to_real32 elemental function compare_float_real64 ( x , y , ulp ) result ( compare ) integer , parameter :: wp = real64 real ( kind = wp ), intent ( in ) :: x real ( kind = wp ), intent ( in ) :: y class ( * ), optional , intent ( in ) :: ulp logical :: compare real ( kind = wp ) :: rel if ( present ( ulp ) ) then rel = abs ( anyscalar_to_double_ ( ulp )) else rel = default_ulp endif compare = abs ( x - y ) < ( rel * spacing ( max ( abs ( x ), abs ( y )) ) ) end function compare_float_real64 elemental function is_less_than_real64 ( x , y ) result ( less_than ) integer , parameter :: wp = real64 real ( kind = wp ), intent ( in ) :: x , y logical :: less_than if ( ( y - x ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then less_than = . true . else less_than = . false . endif end function is_less_than_real64 elemental function is_greater_than_real64 ( x , y ) result ( greater_than ) integer , parameter :: wp = real64 real ( kind = wp ), intent ( in ) :: x , y logical :: greater_than if ( ( x - y ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then greater_than = . true . else greater_than = . false . endif end function is_greater_than_real64 elemental function is_equal_to_real64 ( x , y ) result ( equal_to ) integer , parameter :: wp = real64 real ( kind = wp ), intent ( in ) :: x , y logical :: equal_to equal_to = abs ( x - y ) < spacing ( max ( abs ( x ), abs ( y )) ) end function is_equal_to_real64 #ifdef FLOAT128 elemental function compare_float_real128 ( x , y , ulp ) result ( compare ) integer , parameter :: wp = real128 real ( kind = wp ), intent ( in ) :: x real ( kind = wp ), intent ( in ) :: y class ( * ), optional , intent ( in ) :: ulp logical :: compare real ( kind = wp ) :: rel if ( present ( ulp ) ) then rel = abs ( anyscalar_to_double_ ( ulp )) else rel = default_ulp endif compare = abs ( x - y ) < ( rel * spacing ( max ( abs ( x ), abs ( y )) ) ) end function compare_float_real128 elemental function is_less_than_real128 ( x , y ) result ( less_than ) integer , parameter :: wp = real128 real ( kind = wp ), intent ( in ) :: x , y logical :: less_than if ( ( y - x ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then less_than = . true . else less_than = . false . endif end function is_less_than_real128 elemental function is_greater_than_real128 ( x , y ) result ( greater_than ) integer , parameter :: wp = real128 real ( kind = wp ), intent ( in ) :: x , y logical :: greater_than if ( ( x - y ) >= spacing ( max ( abs ( x ), abs ( y ) ) ) ) then greater_than = . true . else greater_than = . false . endif end function is_greater_than_real128 elemental function is_equal_to_real128 ( x , y ) result ( equal_to ) integer , parameter :: wp = real128 real ( kind = wp ), intent ( in ) :: x , y logical :: equal_to equal_to = abs ( x - y ) < spacing ( max ( abs ( x ), abs ( y )) ) end function is_equal_to_real128 #endif !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_framework__approx !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/m_framework__approx.f90.html"},{"title":"M_framework.f90 – M_framework","text":"NAME M_framework(3f) - [M_framework::INTRO] unit test framework\n (LICENSE:PD) SYNOPSIS M_framework(3f) is an aggregate of Fortran modules brought together to\n provide unit testing for Fortran; and is particularly well suited for\n use with the Fortran Package Manager (fpm). The support modules are useful for creating terminal messages, comparing\n expected values to results, writing logfiles and playback journals\n independent of unit testing as well. Typically unit testing can be integrated seamlessly into the fpm(1) subcommand\n “test” making unit testing from github/gitlab CD/CI utilities as simple as\n “fpm test” in many cases. BASIC TIMING IS INCLUDED\n As well as the expected pass/fail/skipped unit testing report.\n basic timing information can be produced by the unit testing module\n M_framework__verify(3f). HOOKS ARE PROVIDED TO EXTERNAL LOCAL APPLICATIONS M_framework(3f) comes with a unique hook that allows calling your own\n programs to integrate with local logging tools, report generators,\n spreadsheets or other local infrastructure. The example program\n “bookkeeper” is included that uses the hook to write example report\n data files: CSV , HTML NAMELIST The hook can call any local program with an interface similar to\n “bookkeeper”. This allows modifying the program for local needs such\n as sending e-mail alerts and so on without having to change the tests. MESSAGES CAN BE COMPOSED ALMOST LIKE LIST-DIRECTED I/O\n Messages can be composed of up to twenty scalar intrinsic variables,\n allowing freedom in writing messages akin to that of list-directed I/O;\n but simultaneously to a list of output units. This easily lets messages\n go to stdout or stderr and a file of the user’s choosing as well. Output\n can even be sent to a scratch file, essentially creating a quiet mode. DESIGNED FOR INTEGRATION WITH FPM ( 1 ) In conjunction with fpm(1) it is easy to run the tests with the –runner\n option, allowing for integration with other utilities as well such as\n the GNU debugger gdb(1), valgrind(1), and other tools. PROGRAMS INCLUDED TO GENERATE SKELETON TEST PROGRAM Example programs are provided to create unit test skeleton programs to\n ease usage. EASILY USED WITH GITHUB CD/CI Example CD/CI scripts that can be used with github are in the .github/\n directory that assume your tests can by run by using “fpm test”. MOTIVATION Including unit testing is strongly encouraged for any software package,\n but particularly when it is to be used in programming environments the\n package was not developed in. This is the typical case for public fpm(1) packages on github. Additionally the proposed rules for registered fpm(1) package repositories\n include requiring package candidates themselves only have external\n dependencies that are also registered repository packages ( of course\n wrappers of C libraries or other existing libraries cannot easily be\n conformed to this). As a result – this project concentrates on tools for a procedural unit\n testing framework based on nothing but standard Fortran that specifically\n can be used as a remote fpm(1) dependency in fpm(1) packages that may\n reside in public github repositories. That is, it is designed to be integrated with the fpm(1) “test” subcommand\n as an external dependency. It is intended to have little or no other\n dependencies and ultimately become a registered fpm(1) package to aid in\n the development of the fpm(1) repository. That being said, it can be used standalone as well. DESCRIPTION Unit testing allows you to automatically confirm changes are acceptable\n so you can quickly and confidently make and release changes. But many of\n the operations required for testing are useful generically. So this\n project is broken down into small general-purpose modules and\n one unit-testing-specific one. M_framework(3f) is composed of the following individual modules: M_framework__msg is a small module that in particular\n    can convert a list of variables of any of the common default types\n    to a string. It performs low-level operations that are often used by other larger\nmodules so it is its own module to prevent circular dependencies. M_framework__journal__ allows for creating log and journal files M_framework__approx contains routines for rounding and comparing\n    floating-point values. M_framework__help provides for creating a standard simple\n    interactive help facility M_framework__verify is at the heart of the collection and\n    handles virtually all the unit-test-specific operations. The procedures can be used in a variety of ways. After using them for\n a long time my typical usage has changed completely several times. As part of private software there was little problem calling the\n procedures directly from within the modules where they resided; and even\n auto-detecting the routines (a naming convention of “test_suite_$NAME”\n was used). The routines were pre-installed on virtually all platforms\n so using them was no more a burden than say, calling an intrinsic. Put autodetecting tools (at least the ones employed) are not generally\n portable; and with public packages there is a strong incentive to\n minimize the amount of infrastructure and external dependencies. It is\n generally imperative to make package use as simple and generic as possible. So the suggested scheme is to create a small test program for each\n procedure or closely related procedures in the fpm test/ directory. make a subroutine for each component to be tested in each test procedure start it with a call to UNIT_TEST_START(3f) end each test procedure it with a call to UNIT_TEST_END(3f) make multiple calls to UNIT_TEST(3f) in-between to generate\n    test results call each of those test routines from the main program end the main program with a call to UNIT_TEST_STOP(3f) Optionally, before starting set preferred non-default modes. Use the ‘fpm test’ command to run specific tests; all tests (the default);\n a list of tests or test names using simple globbing. As desired, command line options can be used to control various test\n behaviors. As an example, we can create a skeleton program to test a few\n routines. Using fpm test_suite sqrt cos sin > test/test_suite.f90 to create the skeleton program and then adding a few actual\n calls to unit_test_test(3f) results in Sample program: program M_test_suite_M_intrinsics use , intrinsic :: iso_fortran_env , only : & & stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT ! use M_framework , only : unit_test_start , unit_test , unit_test_end , & unit_test_mode , unit_test_level , unit_test_stop use M_framework , only : CHECK_PREFIX ! change column one of messages ! ! use M_mymodule ! load any modules you will be testing implicit none double precision , allocatable :: expected (:), answers (:), input (:) double precision , parameter :: PI = atan ( 1.0 d0 ) * 4 !! setup !--------------------------------------------------- ! OPTIONAL : ! values used in prefix column for various messages ! the default is to set them all to the basename of ! the executable running tests , but they can be ! altered . For example : CHECK_PREFIX = prefix ( & test_MSG = 'test_msg:   ' , & test = 'test:      ' , & test_START = 'test_start: ' , & test_STOP = 'test_stop:  ' , & test_END = 'test_end:   ' & ) !--------------------------------------------------- ! OPTIONAL : ! the options available at run - time on the command ! line can have their defaults selected . See the ! man - page for the procedure for details . call unit_test_mode ( ( keep_going =. true . , flags = [ character ( len = 0 ) ::], luns = [ stdout ], command , & brief =. false . , interactive =. false . , CMDLINE = '' , debug =. false . , match ) !--------------------------------------------------- !! test each subroutine call test_sqrt () call test_cos () call test_sin () !! teardown call unit_test_stop () contains subroutine test_sqrt () integer :: i call unit_test_start ( 'sqrt' , msg = 'calculate the square root' ) input = [ 1.0 d0 , 4.0 d0 , 9.0 d0 ] expected = [ 1.0 d0 , 2.0 d0 , 3.0 d0 ] answers = [( sqrt ( input ( i )), i = 1 , size ( input ))] call unit_test ( 'sqrt' , all ( expected . eq . answers ), & & 'check table of values' ) call unit_test ( 'sqrt' , sqrt ( 25.0 d0 ) . eq . 5.0 d0 , & & 'got' , sqrt ( 25.0 d0 ), 'expected' , 5.0 d0 ) call unit_test_end ( 'sqrt' , msg = '' ) end subroutine test_sqrt subroutine test_sin () call unit_test_start ( 'sin' , msg = 'calculate the sine of a value' ) call unit_test_end ( 'sin' , msg = '' ) end subroutine test_sin subroutine test_cos () call unit_test_start ( 'cos' , msg = 'calculate the cosine of a value' ) call unit_test_end ( 'cos' , msg = '' ) end subroutine test_cos end program M_test_suite_M_intrinsics The output now looks like this (note if no calls to unit_test\n routines are made between unit_test_start(3f) and unit_test_end(3f)\n the procedure gets an “UNTESTED” entry to remind you to make\n some tests ..). > test:       sqrt   SUCCESS : check table of values\n> test:       sqrt   SUCCESS : got 5.0000000000000000 expected 5.0000000000000000\n> test_end:   sqrt   PASSED  : GOOD:        2 BAD:        0 DURATION:00000000012000:\n> test_end:   cos    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:\n> test_end:   sin    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:\n> test_stop:  TALLY  PASSED  : GOOD:        2 BAD:        0 DURATION:00000000000000\n> STOP 0 this is a model that works particularly well for basic numeric procedures. Now it is just a matter of adding more calls to unit_test(3f). This is\n where procedures from the other modules become useful, as they provide\n methods for comparing float values, for example. Since Fortran has\n many powerful masking intrinsics usually just the unit_test(3f) procedure\n is required. In particular, be familiar with the ALL(3f), ANY(3f),\n and PACK(3f) procedures. There are options to call a system command and use the initial string as\n options, to interactively pause after each check, and to change options\n like which output file to write on, what error level to use, and other\n things I will hopefully solidify and document here. RECOMMENDED BASIC USAGE So for an fpm(1) user a recommended process is to create and/or enter the\n test/ directory and use the “unit_test” program. It will make a test\n program called “unit_test_$NAME.f90” for each name given on the command\n line. There is a case made for closely related groups of procedures to share\n a single test file that will be made a little bit later. For that, the\n command “test_suite” is used instead of “unit_test”. For now lets assume we have or plan to have the procedures\n “a”,”b”, and “c” in our package, and that we want to create a test for\n each ( and that unit_test(1) has been installed in your path): cd $TOP_OF_FPM_PACKAGE\n cd test\n unit_test a b c If you then run “fpm test” the skeleton should run indicating the\n procedures are not tested. Change the routines to actually call the\n “unit_test” procedure and you have the beginnings of a unit test for\n your procedures. The “unit_test(3f)” procedure in its simplest form takes a string that\n is usually the procedure name and a logical expression, along with up\n to twenty completely optional intrinsic scalar values which will be used\n to create an optional message. The example programs also contain a placeholder call to unit_test_mode(3f). PROC EDURAL AND COMMAND LINE MODE OPTIONS The dummy skeleton routines all start with a call to unix_test_mode(3f).\n Its documentation describes a few default modes you can change with the\n routine. Essentially the same options are available on the command line\n of the test program(s) as well. # options may be specified in NAMELIST input format with no\n # extraneous spaces on the command line\n fpm test -- flags=100,200,300 keep_going=T\n # a little more Unix-like or MSWindows-like syntax is allowed, as\n # these are equivalent to the original command ...\n fpm test -- --flags=100,200,300 --keep_going\n fpm test -- /flags=100,200,300 /keep_going=T M_framework(3f) uses a built-in command line parser instead of\n packages like M_CLI or M_CLI2 to minimize the number of dependencies\n required. SUGGEST ONE TEST PER PROGRAM There are advantages to each procedure being tested with a separate\n program. A large number of individual test programs works well with fpm(1).\n fpm defaults to running all the tests, but can execute subgroups\n easily because it can execute a list of tests and the names can\n use simple globbing. If you autogenerate a list of procedure names to test and call the\n sample program “unit_test” with the names of the procedures it will\n generate new names but skip existing files; allowing for a simple form\n of auto-generation assuming you have a way of listing all the procedure\n names to test. individual procedure tests can be deleted or added or moved easily when\n each is in its own file. It is easier to test with debuggers and other tools like gdb and valgrind\n on small units. This is true with other tools that you can use with –runner as well.\n See “fpm help runner” or “fpm manual >manual.txt” for more information. TESTING MANY PROCEDURES IN A SINGLE FILE If it is preferred, one program can test multiple procedures. The\n main disadvantage is that the complete test suite is always run unless\n conditional coding is added. One of the uses of the unit_test_flags(:)\n array is to allow integer values to be passed at execution time that\n can be tested to provide such conditional testing. When many tests are\n in one file the unit_test_start(3f) procedure includes a “matched” argument\n which can detect if a simple globbing expression that can be given on the\n command line matches the string composed of the test name and message.\n This allows you to optionally select specific groups of tests from a set. UNIQUE FEATURES CALLING AN EXTERNAL PROGRAM A unique feature of the M_framework(3f) test harness is a hook to call\n a custom program. You can ignore it is there, but it is a very powerful\n feature if you want to do bookkeeping on the test results or enter\n the results into a tracking tool. This allows you a way to sent alerts\n if something fails in automated tests, to create spreadsheets with the\n test results, to retain results in a database or SQLite3 file, or make\n a custom tool to convert the data to something else like TAP (Test Anywhere\n Protocol) reports. An example program called “bookkeeper” is included that shows how to\n parse the information passed to the program that generates several files: + bookkeeper.csv\n+ bookkeeper.html\n+ bookkeeper.nml\n+ bookkeeper\\_clicks.csv To use the defaults you simply enter fpm test -- command=bookkeeper The CSV files can typically be read directly into a spreadsheet program. They can also be read using the SQLite3 tool. This is very powerful,\n letting you use SQL to select specific data, generate reports, and\n convert the subsequent results to HTML, CSV, flat text and other formats. The NAMELIST output file is essentially a record of the harness calls\n using the standardized NAMELIST format that is almost trivial to read\n in with a custom Fortran program. This might be considered a metafile\n format for a test run. You can replay the data and do whatever you want\n with it including generating alternate output file types; plotting\n timing data and so on. The HTML file is handy for importing into word processors or viewing\n via browsers. Example output files from an fpm(1) package that uses\n M_framemaker illustrate the different types of output that can be\n generated.\n  + CSV .\n    Generally. comma-separated files can be read directly into spreadsheet\n    programs, sqlite3, and several common databases.\n  + CSV runtimes Another CSV file that is a record of the runtimes between a\n    unit test start and end.\n  + HTML An example of a formatted report that can be displayed in a browser.\n  + NAMELIST .\n    Essentially this is a metafile that records the unit test calls.\n    It is very easy for a custom Fortran program to read back a NAMELIST\n    file and generate custom outputs instead of modifying bookkeeper(1). The bookkeeper(1) program is an example program that is expected to\n be customized. It provides for parsing the parameters passed to a\n M_framemaker external program. IMPORTING INTO SQLLITE3 Here is an example SQLite3 Tool input file that if placed in “test.sql”\n can be run with sqlite3 -batch -init test.sql bookkeeper.db .quit if you have sqlite3(1) installed. . mode csv . import bookkeeper.csv unit_test . schema unit_test --- --- show all data to show it worked SELECT * FROM unit_test ; --- --- example lists unique names SELECT name FROM unit_test GROUP BY name ORDER BY name ; --- --- tally up passed , failed , skipped in a text table . header on . mode column unit_test . width 64 9 9 9 SELECT name , --- depending on SQL version a simpler IIF / IF , IFNULL , or TOTAL might be better but this works well --- and is relatively \"standard\" as much as something like a standard is actually adhered to in --- SQL - land . CASE sum ( passed == 'passed' ) WHEN NULL THEN 0 ELSE sum ( passed == 'passed' ) END AS 'ok' , CASE sum ( passed == 'failed' ) WHEN NULL THEN 0 ELSE sum ( passed == 'failed' ) END AS 'not ok' , CASE sum ( passed == 'skipped' ) WHEN NULL THEN 0 ELSE sum ( passed == 'skipped' ) END AS 'skip' FROM unit_test --- WHERE condition GROUP BY name ORDER BY name ; --- --- If the table already exists , the sqlite3 tool uses all the rows , --- including the first row , in the CSV file as the actual data to import . --- Therefore , you should delete the first row of the CSV file with the --- header labels if adding to an existing table instead of creating DROP TABLE IF EXISTS unit_test ; --- CREATE TABLE unit_test ( --- name TEXT NOT NULL , --- date DATE NOT NULL , --- passed TEXT NOT NULL , --- msg TEXT --- ); The last select generates a little tally table showing for all the runs\n in the input DataBaseFile the number of pass, fail, and skips of the test\n names. you could tally over a particular date range, only show failures,\n display the last test status, generating output in HTML or CSV or …\n See the SQLite3 Tool documentation for sqlite3(3f) for more information. name                                          ok         not ok     skip\n--------------------------------------------  ---------  ---------  ---------\naccdig                                        3          0          0\nalmost                                        24         0          0\nflush_trail                                   0          0          3\nin_margin                                     30         0          0\nround                                         0          0          3\nset_stdout_lun                                0          0          3\nsignificant                                   15         1          2\nunit_test                                     0          0          3\nunit_test_bad                                 0          0          3\nunit_test_end                                 0          0          3\nunit_test_good                                0          0          3\nunit_test_start                               0          0          6\nunit_test_stop                                0          0          3\nwhere_write_message_all                       0          0          3\nwrite_message_only                            4          2          4 UNIQUE FEATURES fpm(1), gdb(1), and M_framework(3f) work together It is easy to debug an individual test in a debugger. For example to run\n a test called “crash” with gdb(1) use fpm test --target crash --runner \"gdb -ex run --quiet\" A more elaborate example passing arguments to M_framework(3f) to change\n default behavior to for example write output to stdout instead of stderr\n and display compiler version and options and to run all the tests in\n the gdb(1) debugger (you can enter “q” after each test has run; or enter\n gdb commands at the prompt): > fpm test --target '*' --verbose \\\n > --runner 'gdb -ex \"list, 0\" -ex run --quiet --args' \\\n > -- flags=9997,9998,9999 luns=6 level=3 This is long enough that an alias or script would facilitate its use,\n with one changing it to use one’s favorite options. EASILY CALLED BY STANDARDIZED CD/CI SCRIPTS If a CD/CI github automated test script creates a Fortran\n environment including fpm and simply calls “fpm test” you can standardize\n your testing and use the same CD/CI scripts for any package. The testing\n framework is designed with just that scenario in mind. The .github subdirectory in M_framework package contains examples of just\n such files that you can copy as-is into your fpm project. Activate test\n actions in your github repository after adding the .github directory and\n your package will be automatically tested on several different platforms\n by the scripts whenever a “push” to the repository occurs. SUPPORTS FPM The impatient can try this, assuming git(1) and fpm(1) are installed. Download the github repository and build it with fpm(1)\n and create a test fpm(1) project: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # first you need to install a few example programs cd /tmp\ngit clone https://github.com/urbanjost/M_framework.git cd M_framework # install the \"unit_test\", \"bookkeeper\", and \"test_suite\" # example programs; assuming the default install puts # them in your path: fpm install # \"fpm help install\" describes how to customize where the # programs are installed. # # go to your fpm package test/ directory. # here, we will make one up fpm new /tmp/tryit # create test project cd /tmp/tryit/test # so lets say you plan on adding procedures \"a\",\"b\",and \"c\" to your src/tryit.f90 # project code. Set up individual skeleton tests for each procedure. unit_test a b c # a file for each test test_suite a b c > test_suite_tryit.f90 # or a single file cd .. # go to the top of the project # add M_framework to the developer dependencies cat >> fpm.toml <<\\EOF [dev-dependencies] M_framework    = { git = \"https://github.com/urbanjost/M_framework.git\" } EOF # # test the package fpm test # if will say the procedures are untested. Put real calls # in to unit_test(3f) and see how the default report # changes # # so now to run the default tests is as simple as fpm test # run just one test fpm test unit_test_a # run tests using globbing; eg. all tests beginning with \"unit\\_\" fpm test 'unit_*' # display help on the interactive command options fpm test -- --help # you can pass parameters and/or change the unit_test_mode(3f) # calls to change some of the test behavior So once you want to use this on your own projects, you would normally\n just add M_framework(3f) as a developer dependency\n in your fpm.toml project file and start making tests that call M_framework(3f). The optional programs demonstrated (“unit_test”, “test_suite”) are just simple\n stand-alone programs that make skeleton programs to run tests that you can\n customize (and rename too to avoid confusion). # some useful things to try . Check out the man - pages for all the unit_test_ * ( 3 f ) # procedures .\n# Then look at unit_test -- help fpm test -- help # run the demo bookkeeper script fpm test -- command = bookkeeper # and look at the bookkeeper * . * files in the top of the project DOCUMENTATION USER An index to HTML versions\n    of the manpages single pages that uses javascript to combine all the HTML descriptions\n    of the man-pages is at BOOK_M_framework__verify BOOK_M_framework__approx BOOK_M_framework__journal BOOK_M_framework__msg man-pages in manpages.zip manpages.tgz DEVELOPER\n+ ford-generated developers’ document + github action status ADDITIONAL DIRECTORY DESCRIPTIONS - src / is where the source for the M_framework ( 3 f ) module code resides - docs / contains HTML documentation and the manpage archives - test / contains simple test programs - example / has demos REFERENCES See the .github directory in easy for examples of CD/CI scripts that assume your package can be tested with an “fpm test” command. examples that use M_framework in github fpm packages: M_strings M_process These packages used a different reincarnation of the testing harness and are in the process of\nbeing changed to use M_framework(3f) more appropriately, but still contain some useful examples. Fortran Package Manager fpm(1) registry Fortran Wiki: unit testing list ford(1) for generating documentation for your projects NOTE\n M_framework(3f) is subject to interface changes so the generally recommended\n practice of using a specific commit when using it an an external\n fpm(1) dependency is highly encouraged. Any feedback (features, performance, ease of use, …) is appreciated,\n particularly in the ongoing development phase. QUOTE Do not let your victories go to your head , nor let your failures go to your heart . AUTHOR John S. Urban LICENSE Public Domain Source Code module M_framework use M_framework__journal use M_framework__msg use M_framework__verify use M_framework__approx use M_framework__utility use M_framework__timing !use M_framework__attr implicit none ( type , external ) !private ! public ... !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    M_framework(3f) - [M_framework::INTRO] unit test framework !!     (LICENSE:PD) !!##SYNOPSIS !! !! !! M_framework(3f) is an aggregate of Fortran modules brought together to !! provide unit testing for Fortran; and is particularly well suited for !! use with the Fortran Package Manager (fpm). !! !! The support modules are useful for creating terminal messages, comparing !! expected values to results, writing logfiles and playback journals !! independent of unit testing as well. !! !! Typically unit testing can be integrated seamlessly into the fpm(1) subcommand !! \"test\" making unit testing from github/gitlab CD/CI utilities as simple as !! \"fpm test\" in many cases. !! !! !!  BASIC TIMING IS INCLUDED !! As well as the expected **pass/fail/skipped unit testing** report. !! basic **timing information** can be produced by the unit testing module !! M_framework__verify(3f). !! !!  HOOKS ARE PROVIDED TO EXTERNAL LOCAL APPLICATIONS !! !! M_framework(3f) comes with a unique hook that allows calling your own !! programs to integrate with local logging tools, report generators, !! spreadsheets or other local infrastructure. The example program !! \"bookkeeper\" is included that uses the hook to write example report !! data files: !! !!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv), !!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html) !!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml) !! !! The hook can call any local program with an interface similar to !! \"bookkeeper\". This allows modifying the program for local needs such !! as sending e-mail alerts and so on without having to change the tests. !! !!   MESSAGES CAN BE COMPOSED ALMOST LIKE LIST-DIRECTED I/O !! Messages can be composed of up to twenty scalar intrinsic variables, !! allowing freedom in writing messages akin to that of list-directed I/O; !! but simultaneously to a list of output units. This easily lets messages !! go to stdout or stderr and a file of the user's choosing as well. Output !! can even be sent to a scratch file, essentially creating a quiet mode. !! !!    DESIGNED FOR INTEGRATION WITH FPM(1) !! In conjunction with fpm(1) it is easy to run the tests with the --runner !! option, allowing for integration with other utilities as well such as !! the GNU debugger gdb(1), valgrind(1), and other tools. !! !!    PROGRAMS INCLUDED TO GENERATE SKELETON TEST PROGRAM !! Example programs are provided to create unit test skeleton programs to !! ease usage. !! !!    EASILY USED WITH GITHUB CD/CI !! Example CD/CI scripts that can be used with github are in the .github/ !! directory that assume your tests can by run by using \"fpm test\". !! !!    MOTIVATION !! Including **unit testing** is strongly encouraged for any software package, !! but particularly when it is to be used in programming environments the !! package was not developed in. !! !! This is the typical case for public fpm(1) packages on github. !! !! Additionally the proposed rules for registered fpm(1) package repositories !! include requiring package candidates themselves only have external !! dependencies that are also registered repository packages ( of course !! wrappers of C libraries or other existing libraries cannot easily be !! conformed to this). !! !! As a result -- this project concentrates on tools for a procedural unit !! testing framework based on nothing but standard Fortran that specifically !! can be used as a remote fpm(1) dependency in fpm(1) packages that may !! reside in public github repositories. !! !! That is, it is designed to be integrated with the fpm(1) \"test\" subcommand !! as an external dependency. It is intended to have little or no other !! dependencies and ultimately become a registered fpm(1) package to aid in !! the development of the fpm(1) repository. !! !! That being said, it can be used standalone as well. !! !!##DESCRIPTION !! !! Unit testing allows you to automatically confirm changes are acceptable !! so you can quickly and confidently make and release changes. But many of !! the operations required for testing are useful generically. So this !! project is broken down into small general-purpose modules and !! one unit-testing-specific one. !! !! M_framework(3f) is composed of the following individual modules: !! !!  + **M\\_framework__msg** is a small module that in particular !!    can convert a list of variables of any of the common default types !!    to a string. !! !!    It performs low-level operations that are often used by other larger !!    modules so it is its own module to prevent circular dependencies. !! !!  + **M\\_framework__journal__** allows for creating log and journal files !! !!  + **M\\_framework__approx** contains routines for rounding and comparing !!    floating-point values. !! !!  + **M\\_framework__help** provides for creating a standard simple !!    interactive help facility !! !!  + **M\\_framework__verify** is at the heart of the collection and !!    handles virtually all the unit-test-specific operations. !! !! The procedures can be used in a variety of ways. After using them for !! a long time my typical usage has changed completely several times. !! !! As part of private software there was little problem calling the !! procedures directly from within the modules where they resided; and even !! auto-detecting the routines (a naming convention of \"test\\_suite\\_$NAME\" !! was used). The routines were pre-installed on virtually all platforms !! so using them was no more a burden than say, calling an intrinsic. !! !! Put autodetecting tools (at least the ones employed) are not generally !! portable; and with public packages there is a strong incentive to !! minimize the amount of infrastructure and external dependencies. It is !! generally imperative to make package use as simple and generic as possible. !! !! So the suggested scheme is to create a small test program for each !! procedure or closely related procedures in the fpm test/ directory. !! !!  + make a subroutine for each component to be tested !!  + in each test procedure start it with a call to UNIT\\_TEST\\_START(3f) !!  + end each test procedure it with a call to UNIT\\_TEST\\_END(3f) !!  + make multiple calls to UNIT\\_TEST(3f) in-between to generate !!    test results !!  + call each of those test routines from the main program !!  + end the main program with a call to UNIT\\_TEST\\_STOP(3f) !! !! Optionally, before starting set preferred non-default modes. !! !! Use the 'fpm test' command to run specific tests; all tests (the default); !! a list of tests or test names using simple globbing. !! !! As desired, command line options can be used to control various test !! behaviors. !! !! As an example, we can create a skeleton program to test a few !! routines. Using !! !!      fpm test_suite sqrt cos sin > test/test_suite.f90 !! !! to create the skeleton program and then adding a few actual !! calls to unit\\_test\\_test(3f) results in !! !!   Sample program: !! !!    program M_test_suite_M_intrinsics !!    use,intrinsic :: iso_fortran_env, only : & !!    & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT !!    ! !!    use M_framework, only : unit_test_start,unit_test,unit_test_end, & !!                     unit_test_mode, unit_test_level, unit_test_stop !!    use M_framework, only : CHECK_PREFIX ! change column one of messages !!    ! !!    !use M_mymodule ! load any modules you will be testing !!    implicit none !!    double precision,allocatable :: expected(:), answers(:), input(:) !!    double precision,parameter :: PI=atan(1.0d0)*4 !!    !! setup !!       !--------------------------------------------------- !!       !OPTIONAL: !!       !  values used in prefix column for various messages !!       !  the default is to set them all to the basename of !!       !  the executable running tests, but they can be !!       !  altered. For example: !!       CHECK_PREFIX=prefix(                  & !!        test_MSG    =  'test_msg:   ', & !!        test        =  'test:      ',  & !!        test_START  =  'test_start: ', & !!        test_STOP   =  'test_stop:  ', & !!        test_END    =  'test_end:   '  & !!       ) !!       !--------------------------------------------------- !!       !OPTIONAL: !!       ! the options available at run-time on the command !!       ! line can have their defaults selected. See the !!       ! man-page for the procedure for details. !!       call unit_test_mode( !!         ( keep_going=.true. , !!         flags=[character(len=0) ::], !!         luns=[stdout], !!         command, & !!         brief=.false. , !!         interactive=.false. , !!         CMDLINE='', !!         debug=.false. , !!         match !!         ) !!       !--------------------------------------------------- !!    !! test each subroutine !!       call test_sqrt() !!       call test_cos() !!       call test_sin() !!    !! teardown !!       call unit_test_stop() !!    contains !!    subroutine test_sqrt() !!    integer :: i !!       call unit_test_start('sqrt',msg='calculate the square root') !!       input   =[1.0d0,4.0d0,9.0d0] !!       expected=[1.0d0,2.0d0,3.0d0] !!       answers=[(sqrt(input(i)),i=1,size(input))] !!       call unit_test('sqrt', all(expected.eq.answers),& !!          & 'check table of values') !!       call unit_test('sqrt', sqrt(25.0d0).eq.5.0d0,& !!          & 'got',sqrt(25.0d0),'expected',5.0d0) !!       call unit_test_end('sqrt',msg='') !!    end subroutine test_sqrt !! !!    subroutine test_sin() !!       call unit_test_start('sin',msg='calculate the sine of a value') !!       call unit_test_end('sin',msg='') !!    end subroutine test_sin !! !!    subroutine test_cos() !!       call unit_test_start('cos',msg='calculate the cosine of a value') !!       call unit_test_end('cos',msg='') !!    end subroutine test_cos !! !!    end program M_test_suite_M_intrinsics !! !! The output now looks like this (note if no calls to unit\\_test !! routines are made between unit_test_start(3f) and unit_test_end(3f) !! the procedure gets an \"UNTESTED\" entry to remind you to make !! some tests ..). !! !!    > test:       sqrt   SUCCESS : check table of values !!    > test:       sqrt   SUCCESS : got 5.0000000000000000 expected 5.0000000000000000 !!    > test_end:   sqrt   PASSED  : GOOD:        2 BAD:        0 DURATION:00000000012000: !!    > test_end:   cos    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000: !!    > test_end:   sin    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000: !!    > test_stop:  TALLY  PASSED  : GOOD:        2 BAD:        0 DURATION:00000000000000 !!    > STOP 0 !! !! this is a model that works particularly well for basic numeric procedures. !! !! Now it is just a matter of adding more calls to unit\\_test(3f). This is !! where procedures from the other modules become useful, as they provide !! methods for comparing float values, for example. Since Fortran has !! many powerful masking intrinsics usually just the unit\\_test(3f) procedure !! is required. In particular, be familiar with the ALL(3f), ANY(3f), !! and PACK(3f) procedures. !! !! There are options to call a system command and use the initial string as !! options, to interactively pause after each check, and to change options !! like which output file to write on, what error level to use, and other !! things I will hopefully solidify and document here. !! !!    RECOMMENDED BASIC USAGE !! !! So for an fpm(1) user a recommended process is to create and/or enter the !! test/ directory and use the \"unit\\_test\" program. It will make a test !! program called \"unit\\_test\\_$NAME.f90\" for each name given on the command !! line. !! !! There is a case made for closely related groups of procedures to share !! a single test file that will be made a little bit later. For that, the !! command \"test\\_suite\" is used instead of \"unit\\_test\". !! !! For now lets assume we have or plan to have the procedures !! \"a\",\"b\", and \"c\" in our package, and that we want to create a test for !! each ( and that unit\\_test(1) has been installed in your path): !! !!     cd $TOP_OF_FPM_PACKAGE !!     cd test !!     unit_test a b c !! !! If you then run \"fpm test\" the skeleton should run indicating the !! procedures are not tested. Change the routines to actually call the !! \"unit\\_test\" procedure and you have the beginnings of a unit test for !! your procedures. !! !! The \"unit\\_test(3f)\" procedure in its simplest form takes a string that !! is usually the procedure name and a logical expression, along with up !! to twenty completely optional intrinsic scalar values which will be used !! to create an optional message. !! !! The example programs also contain a placeholder call to unit\\_test\\_mode(3f). !! !!    PROCEDURAL AND COMMAND LINE MODE OPTIONS !! The dummy skeleton routines all start with a call to unix\\_test\\_mode(3f). !! Its documentation describes a few default modes you can change with the !! routine. Essentially the same options are available on the command line !! of the test program(s) as well. !! !!     # options may be specified in NAMELIST input format with no !!     # extraneous spaces on the command line !!     fpm test -- flags=100,200,300 keep_going=T !!     # a little more Unix-like or MSWindows-like syntax is allowed, as !!     # these are equivalent to the original command ... !!     fpm test -- --flags=100,200,300 --keep_going !!     fpm test -- /flags=100,200,300 /keep_going=T !! !! M_framework(3f) uses a built-in command line parser instead of !! packages like M\\_CLI or M\\_CLI2 to minimize the number of dependencies !! required. !! !!    SUGGEST ONE TEST PER PROGRAM !! !! There are advantages to each procedure being tested with a separate !! program. !! !! A large number of individual test programs works well with fpm(1). !! fpm defaults to running all the tests, but can execute subgroups !! easily because it can execute a list of tests and the names can !! use simple globbing. !! !! If you autogenerate a list of procedure names to test and call the !! sample program \"unit_test\" with the names of the procedures it will !! generate new names but skip existing files; allowing for a simple form !! of auto-generation assuming you have a way of listing all the procedure !! names to test. !! !! individual procedure tests can be deleted or added or moved easily when !! each is in its own file. !! !! It is easier to test with debuggers and other tools like gdb and valgrind !! on small units. !! !! This is true with other tools that you can use with --runner as well. !! See \"fpm help runner\" or \"fpm manual \\>manual.txt\" for more information. !! !!     TESTING MANY PROCEDURES IN A SINGLE FILE !! !! If it is preferred, one program can test multiple procedures. The !! main disadvantage is that the complete test suite is always run unless !! conditional coding is added. One of the uses of the unit\\_test\\_flags(:) !! array is to allow integer values to be passed at execution time that !! can be tested to provide such conditional testing. When many tests are !! in one file the unit_test_start(3f) procedure includes a \"matched\" argument !! which can detect if a simple globbing expression that can be given on the !! command line matches the string composed of the test name and message. !! This allows you to optionally select specific groups of tests from a set. !! !!##UNIQUE FEATURES !! !!    CALLING AN EXTERNAL PROGRAM !! !! A unique feature of the M\\_framework(3f) test harness is a hook to call !! a custom program. You can ignore it is there, but it is a very powerful !! feature if you want to do bookkeeping on the test results or enter !! the results into a tracking tool. This allows you a way to sent alerts !! if something fails in automated tests, to create spreadsheets with the !! test results, to retain results in a database or SQLite3 file, or make !! a custom tool to convert the data to something else like TAP (Test Anywhere !! Protocol) reports. !! !! An example program called \"bookkeeper\" is included that shows how to !! parse the information passed to the program that generates several files: !! !!    + bookkeeper.csv !!    + bookkeeper.html !!    + bookkeeper.nml !!    + bookkeeper\\_clicks.csv !! !! To use the defaults you simply enter !! !!     fpm test -- command=bookkeeper !! !! The CSV files can typically be read directly into a spreadsheet program. !! !! They can also be read using the SQLite3 tool. This is very powerful, !! letting you use SQL to select specific data, generate reports, and !! convert the subsequent results to HTML, CSV, flat text and other formats. !! !! The NAMELIST output file is essentially a record of the harness calls !! using the standardized NAMELIST format that is almost trivial to read !! in with a custom Fortran program. This might be considered a metafile !! format for a test run. You can replay the data and do whatever you want !! with it including generating alternate output file types; plotting !! timing data and so on. !! !! The HTML file is handy for importing into word processors or viewing !! via browsers. Example output files from an fpm(1) package that uses !! M_framemaker illustrate the different types of output that can be !! generated. !!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv). !!    Generally. comma-separated files can be read directly into spreadsheet !!    programs, sqlite3, and several common databases. !!  + [CSV runtimes](https://urbanjost.github.io/M_framework/bookkeeper_clicks.csv) !!    Another CSV file that is a record of the runtimes between a !!    unit test start and end. !!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html) !!    An example of a formatted report that can be displayed in a browser. !!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml). !!    Essentially this is a metafile that records the unit test calls. !!    It is very easy for a custom Fortran program to read back a NAMELIST !!    file and generate custom outputs instead of modifying bookkeeper(1). !! !! The bookkeeper(1) program is an example program that is expected to !! be customized. It provides for parsing the parameters passed to a !! M_framemaker external program. !! !!     IMPORTING INTO SQLLITE3 !! Here is an example SQLite3 Tool input file that if placed in \"test.sql\" !! can be run with !! !!      sqlite3 -batch -init test.sql bookkeeper.db .quit !! !! if you have sqlite3(1) installed. !! !!    .mode csv !!    .import bookkeeper.csv unit_test !!    .schema unit_test !!    --- !!    --- show all data to show it worked !!    SELECT * FROM unit_test; !!    --- !!    --- example lists unique names !!    SELECT name FROM unit_test GROUP BY name ORDER BY name ; !!    --- !!    --- tally up passed, failed, skipped in a text table !!    .header on !!    .mode column unit_test !!    .width 64 9 9 9 !!    SELECT name, !!    --- depending on SQL version a simpler IIF/IF, IFNULL, or TOTAL might be better but this works well !!    --- and is relatively \"standard\" as much as something like a standard is actually adhered to in !!    --- SQL-land. !!    CASE  sum( passed == 'passed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'passed')  END  AS 'ok', !!    CASE  sum( passed == 'failed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'failed')  END  AS 'not ok', !!    CASE  sum( passed == 'skipped' ) WHEN NULL THEN 0 ELSE sum ( passed == 'skipped') END  AS 'skip' !!    FROM unit_test !!    --- WHERE condition !!    GROUP BY name !!    ORDER BY name ; !!    --- !!    --- If the table already exists, the sqlite3 tool uses all the rows, !!    --- including the first row, in the CSV file as the actual data to import. !!    --- Therefore, you should delete the first row of the CSV file with the !!    --- header labels if adding to an existing table instead of creating !!    DROP TABLE IF EXISTS unit_test; !!    --- CREATE TABLE unit_test( !!    ---   name   TEXT NOT NULL, !!    ---   date   DATE NOT NULL, !!    ---   passed TEXT NOT NULL, !!    ---   msg    TEXT !!    --- ); !! !! The last select generates a little tally table showing for all the runs !! in the input DataBaseFile the number of pass, fail, and skips of the test !! names. you could tally over a particular date range, only show failures, !! display the last test status, generating output in HTML or CSV or ... !! See the SQLite3 Tool documentation for sqlite3(3f) for more information. !! !!    name                                          ok         not ok     skip !!    --------------------------------------------  ---------  ---------  --------- !!    accdig                                        3          0          0 !!    almost                                        24         0          0 !!    flush_trail                                   0          0          3 !!    in_margin                                     30         0          0 !!    round                                         0          0          3 !!    set_stdout_lun                                0          0          3 !!    significant                                   15         1          2 !!    unit_test                                     0          0          3 !!    unit_test_bad                                 0          0          3 !!    unit_test_end                                 0          0          3 !!    unit_test_good                                0          0          3 !!    unit_test_start                               0          0          6 !!    unit_test_stop                                0          0          3 !!    where_write_message_all                       0          0          3 !!    write_message_only                            4          2          4 !! !!##UNIQUE FEATURES !! !! fpm(1), gdb(1), and M\\_framework(3f) work together !! !! It is easy to debug an individual test in a debugger. For example to run !! a test called \"crash\" with gdb(1) use !! !!      fpm test --target crash --runner \"gdb -ex run --quiet\" !! !! A more elaborate example passing arguments to M\\_framework(3f) to change !! default behavior to for example write output to stdout instead of stderr !! and display compiler version and options and to run all the tests in !! the gdb(1) debugger (you can enter \"q\" after each test has run; or enter !! gdb commands at the prompt): !! !!     > fpm test --target '*' --verbose \\ !!     > --runner 'gdb -ex \"list, 0\" -ex run --quiet --args' \\ !!     > -- flags=9997,9998,9999 luns=6 level=3 !! !! This is long enough that an alias or script would facilitate its use, !! with one changing it to use one's favorite options. !! !!    EASILY CALLED BY STANDARDIZED CD/CI SCRIPTS !! !! If a CD/CI github automated test script creates a Fortran !! environment including fpm and simply calls \"fpm test\" you can standardize !! your testing and use the same CD/CI scripts for any package. The testing !! framework is designed with just that scenario in mind. !! !! The .github subdirectory in M\\_framework package contains examples of just !! such files that you can copy as-is into your fpm project. Activate test !! actions in your github repository after adding the .github directory and !! your package will be automatically tested on several different platforms !! by the scripts whenever a \"push\" to the repository occurs. !! !! ------------------------------------------------------------------------------------------ !! !!##SUPPORTS FPM !! !! The impatient can try this, assuming git(1) and fpm(1) are installed. !! !! Download the github repository and build it with fpm(1) !! and create a test fpm(1) project: !! !!    #!/bin/bash !!    # first you need to install a few example programs !!    cd /tmp !!    git clone https://github.com/urbanjost/M_framework.git !!    cd M_framework !!    # install the \"unit_test\", \"bookkeeper\", and \"test_suite\" !!    # example programs; assuming the default install puts !!    # them in your path: !!    fpm install !!    # \"fpm help install\" describes how to customize where the !!    # programs are installed. !!    # !!    # go to your fpm package test/ directory. !!    # here, we will make one up !!    fpm new /tmp/tryit  # create test project !!    cd /tmp/tryit/test !!    # so lets say you plan on adding procedures \"a\",\"b\",and \"c\" to your src/tryit.f90 !!    # project code. Set up individual skeleton tests for each procedure. !!    unit_test a b c                         # a file for each test !!    test_suite a b c > test_suite_tryit.f90 # or a single file !!    cd ..  # go to the top of the project !!    # add M_framework to the developer dependencies !!    cat >> fpm.toml <<\\EOF !!    [dev-dependencies] !!    M_framework    = { git = \"https://github.com/urbanjost/M_framework.git\" } !!    EOF !!    # !!    # test the package !!    fpm test !!    # if will say the procedures are untested. Put real calls !!    # in to unit_test(3f) and see how the default report !!    # changes !!    # !!    # so now to run the default tests is as simple as !!    fpm test !!    # run just one test !!    fpm test unit_test_a !!    # run tests using globbing; eg. all tests beginning with \"unit\\_\" !!    fpm test 'unit_*' !!    # display help on the interactive command options !!    fpm test -- --help !! !!    # you can pass parameters and/or change the unit_test_mode(3f) !!    # calls to change some of the test behavior !! !! So once you want to use this on your own projects, you would normally !! just add M\\_framework(3f) as a developer dependency !! in your fpm.toml project file and start making tests that call M\\_framework(3f). !! !! The optional programs demonstrated (\"unit\\_test\", \"test\\_suite\") are just simple !! stand-alone programs that make skeleton programs to run tests that you can !! customize (and rename too to avoid confusion). !! !!    # some useful things to try. Check out the man-pages for all the unit_test_*(3f) !!    # procedures. !!    # Then look at !!    unit_test --help !!    fpm test -- help !!    # run the demo bookkeeper script !!    fpm test -- command=bookkeeper !!    # and look at the bookkeeper*.* files in the top of the project !! !!##DOCUMENTATION !! !!   USER !! !!  - An [index](https://urbanjost.github.io/M_framework/man3.html) to HTML versions !!    of the manpages !! !!  - single pages that uses javascript to combine all the HTML descriptions !!    of the man-pages is at !!     + [BOOK_M_framework__verify](https://urbanjost.github.io/M_framework/BOOK_M_framework__verify.html) !!     + [BOOK_M_framework__approx](https://urbanjost.github.io/M_framework/BOOK_M_framework__approx.html) !!     + [BOOK_M_framework__journal](https://urbanjost.github.io/M_framework/BOOK_M_framework__journal.html) !!     + [BOOK_M_framework__msg](https://urbanjost.github.io/M_framework/BOOK_M_framework__msg.html) !! !!  - man-pages in !!     + [manpages.zip](https://urbanjost.github.io/M_framework/manpages.zip) !!     + [manpages.tgz](https://urbanjost.github.io/M_framework/manpages.tgz) !! !!    DEVELOPER !!    + [ford-generated developers' document](https://urbanjost.github.io/M_framework/fpm-ford/index.html) !!    + [github action status](docs/STATUS.md) !! !!##ADDITIONAL DIRECTORY DESCRIPTIONS !! !!    - src/ is where the source for the M_framework(3f) module code resides !!    - docs/ contains HTML documentation and the manpage archives !!    - test/ contains simple test programs !!    - example/ has demos !! !!##REFERENCES !!  + See the .github directory in [easy](https://github.com/urbanjost/easy) !!  + for examples of CD/CI scripts that assume your package can be tested with an \"fpm test\" command. !!  + examples that use M_framework in github fpm packages: !!      * [M_strings](https://github.com/urbanjost/M_strings) !!      * [M_process](https://github.com/urbanjost/M_process) !! !!    These packages used a different reincarnation of the testing harness and are in the process of !!    being changed to use M_framework(3f) more appropriately, but still contain some useful examples. !! !!  + [Fortran Package Manager](https://github.com/fortran-lang/fpm) !!  + [fpm(1) registry](https://github.com/fortran-lang/fpm-registry) !!  + [Fortran Wiki: unit testing list](https://fortranwiki.org/fortran/show/Unit+testing+frameworks) !!  + [ford(1)](https://politicalphysicist.github.io/ford-fortran-documentation.html) for generating documentation for your projects !! !!    NOTE !! M_framework(3f) is subject to interface changes so the generally recommended !! practice of using a specific commit when using it an an external !! fpm(1) dependency is highly encouraged. !! !! Any feedback (features, performance, ease of use, ...) is appreciated, !! particularly in the ongoing development phase. !! !! !!##QUOTE !!    Do not let your victories go to your head, nor let your failures go !!    to your heart. !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_framework","tags":"","url":"sourcefile/m_framework.f90.html"},{"title":"demo_unit_test_end.f90 – M_framework","text":"Source Code program demo_unit_test_end use M_framework , only : unit_test_start use M_framework , only : unit_test use M_framework , only : unit_test_end implicit none integer :: x x = 10 call unit_test_start ( 'myroutine' ) call unit_test ( 'myroutine' , x > 3 , 'if big enough' ) call unit_test ( 'myroutine' , x < 100 , 'if small enough' ) ! program execution stopped call unit_test_end ( 'myroutine' , msg = 'checks on \"myroutine\"' ) end program demo_unit_test_end","tags":"","url":"sourcefile/demo_unit_test_end.f90.html"},{"title":"demo_unit_test_msg.f90 – M_framework","text":"Source Code program demo_unit_test_msg use M_framework , only : unit_test_start , unit_test_msg , & & unit_test_end implicit none call unit_test_start ( 'myroutine' ) call unit_test_msg ( 'myroutine' , 'HUGE(3f) integers' , & & huge ( 0 ), 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) call unit_test_msg ( 'myroutine' , 'real            :' , & & huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) call unit_test_msg ( 'myroutine' , 'doubleprecision :' , & & huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) call unit_test_msg ( 'myroutine' , 'complex         :' , & & cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) call unit_test_end ( 'myroutine' ) end program demo_unit_test_msg","tags":"","url":"sourcefile/demo_unit_test_msg.f90.html"},{"title":"demo_set.f90 – M_framework","text":"Source Code program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_framework__msg , only : set implicit none real ( kind = real32 ) :: a ; namelist / all / a real ( kind = real64 ) :: b ; namelist / all / b real ( kind = real128 ) :: c ; namelist / all / c integer ( kind = int8 ) :: i ; namelist / all / i integer ( kind = int16 ) :: j ; namelist / all / j integer ( kind = int32 ) :: k ; namelist / all / k integer ( kind = int64 ) :: l ; namelist / all / l call set ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set","tags":"","url":"sourcefile/demo_set.f90.html"},{"title":"M_framework__journal.f90 – M_framework","text":"Source Code !> !!##NAME !!     M_framework__journal(3fm) - [M_framework__journal::INTRO] write !!     program messages to stdout and/or !!     a log file !!     (LICENSE:PD) !!##SYNOPSIS !! !!     use, M_framework__journal , only : journal !!##DESCRIPTION !! !!    For large interactive programs in particular it is useful if all !!    messages go thru a JOURNAL(3f) call. This makes it easy to !!    write messages to a log file as well as standard output; to toggle !!    time prefixes on and off; to turn on and off debug-mode messages; !!    control output paging and create replayable input journals. !! !!    The primary use of JOURNAL(3f) is to create journal files for !!    interactive programs that !! !!        + provide various levels of verbosity on demand, often for !!          debugging purposes. !!        + can be replayed even when interactive input was provided !!        + and/or be used to verify program executions !! !!    Typically, you would echo what the user typed to the trail file as-is, !!    and write output you write to stdout as comments to the trail file so !!    that the trail file can easily be read back in (by ignoring comments). !! !!    Even though there is essentially one procedure (journal(3f) calls !!    that are more than just a single message have an action specified as !!    the first parameter. This action might specify to open a log file, to !!    change the \"level\" required by messages for them to appear, whether !!    output it written as a comment or not, and on what files the output !!    should appear. So the interface can be used in a very simple manner !!    but has more options than is evident at first glance, as detailed in !!    the man-page for journal(3f). !! !!    to stdout is written with WHERE='SC' in the JOURNAL(3f) call. !! !!     >      : !!     >      : !!     > call journal('O','my_trail_file')  ! open trail file !!     > ! write output to stdout as-is and as comment to trail file !!     > call journal(output) !!     > ! echo message to trail/log file only !!     > call journal('T',userline) !!     > ! write to stdout as-is and trail as a comment. !!     > ! up to twenty scalar values of any intrinsic type are allowed !!     > call journal('SC','i1=',i1,'i2=',i2,'i3=',i3) !!     > ! for more complex messages you can build them with non-advancing !!     > ! I/O journal calls, or build the message with internal writes !!     > ! into a string and print that. !! !!       I=10 !!       R=20.3 !!       ! write to stdout and trail file without advancing I/O !!       call journal('+SC','I=',i) !!       ! write to stdout and trail file without advancing I/O !!       call journal('SC','AND R=',r) !! !!    writes to the trail file(s) are ignored unless a trail file was opened, !!    but output continues to stdout by default. !! !!    That is, destinations 'T' and 'C' are ignored unless a trail file !!    has been requested, allowing journal to be used with programs that !!    do not generate trails or journals. !! !!    Note that with no parameters, the trail file is flushed. !! !!##EXAMPLES !! !! !!    The man-page for journal(3f) describes all the options for the !!    action field WHERE. In addition to being used to generate a journal, !!    the routine can be used for producing optional debug messages and !!    timing information. !! !!    Sample program for debug messages: !! !!      program demo_journal !!      !! showing creating debug messages !!      use M_framework__journal, only : journal !!      implicit none !!      !! produces no output because trail is not on !!      call journal('D','*demo* DEBUG MESSAGE 001 IGNORED') !!      !! turn on debug messages !!      call journal('>','debug on') !!      !! produces output on stdout because debug mode !!      !! is on but no named trail file !!      call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT') !!      !! open trail file !!      call journal('O','mytrail.txt') !!      !! debug messages now go to the trail file only !!      call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL') !!      !! or always to stdout and trail file only if on !!      call journal('DS','*demo* DEBUG MESSAGE 003 TO TRAIL') !!      !! close trail file so messages go only to stdout again !!      call journal('O','') !!      !! debug on stdout now !!      call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT') !!      !! turn off debug messages !!      call journal('<','debug off') !!      !! back to no output from the next message !!      call journal('D','*demo* DEBUG MESSAGE 005 IGNORED') !!      end program demo_journal !! !! !!   Sample program for trail messages with optional timing information: !! !!      program testit !!      use M_framework__journal,only : journal !!      implicit none !!      call journal('a single string A -should be on S') !! !!      ! add time prefix to output !!      call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b') !!      ! !!      call journal('a single string B -should be on S with prefix') !!      ! change to CPU time and number of calls prefix !!      call journal('%','CPU_TIME: %c:CALLS: %C: %b') !!      ! !!      call journal('a single string B-1 -should be on S with prefix') !!      call journal('a single string B-2 -should be on S with prefix') !!      call journal('a single string B-3 -should be on S with prefix') !!      !  Other useful time formats: !!      !     %E -- Unix Epoch time !!      !     %e -- integer value of Unix Epoch time !!      !     %C -- number of times this format is used !!      !     %c -- CPU_time(3f) output !!      !     %S -- seconds since last use of this format !!      !     %k -- CPU time in seconds from system_clock !!      call journal('%','') ! turn off time prefix !!      ! !!      call journal('a single string C -should be on S') !!      ! !!      call journal('O','aaa.out') ! turn on trail file !!      call journal('a single string D -should be on SC') !!      call journal('a single string E -should be on SC') !!      call journal('a single string F -should be on SC') !!      call journal('O','') ! turn off trail file !!      ! !!      call journal('a single string G -should be on S') !!      call journal('a single string H -should be on S') !!      call journal('a single string I -should be on S') !! !!      ! build one line of output with intrinsic scalar values added !!      call journal('+sc','APPEND:') !!      call journal('+sc',' integer',         1234) !!      call journal('+sc',' and real',        1234.5678) !!      call journal('+sc',' and double',1234567890.123456d0) !!      call journal('+sc',' and logical',    .true.) !!      call journal('sc','') !!      ! !!      end program testit !! !!##AUTHOR !!     John S. Urban !!##LICENSE !!     Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_framework__journal use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , INPUT_UNIT , OUTPUT_UNIT ! access computing environment use :: M_framework__msg , only : str implicit none private !> !!##NAME !!      journal(3f) - [M_framework__journal] provides public message routine, no paging or graphic mode change !!      (LICENSE:PD) !!##SYNOPSIS !! !! !!    subroutine journal([where,],[VALUE(s)]) !! !!     character(len=*),intent(in) :: where !!     class(*),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !! !!   WRITE MESSAGES !!    basic messages !! !!       call journal(where,[VALUE(S)]) !!       call journal(message) # a shortcut for \"call journal('sc',message)\": !!   OPEN OR CLOSE TRAIL FILE !!    trail file !! !!       call journal('O',trailfile_name) # open trail file !!       call journal('O','')             # close trail file !!   SET OUTPUT TIME PREFIX !!    set the function display format for timestamps. See the NOW(3f) !!    procedure for allowable timestamp macros !! !!       call journal('%',time_stamp_prefix_specification) !! !!   MODES !! !!    Turn on/off writing DEBUG messages to trail file !! !!       call journal('>','debug on') # turn on debug mode !!       call journal('<','debug off') # turn off debug mode !! !!   ASSIGN STDOUT TO AN ALTERNATE FILE !!    change stdout to iunit and open filename; or close unit and go back to stdout if filename='' !! !!       call journal(iunit,filename) !! !!    change stdout to iunit to use a file already open !! !!       call journal(iunit) !! !!##DESCRIPTION !! !!    If a user procedure is used for outputting messages instead of calling !!    WRITE(3f) it is easy to provide control of when messages are printed !!    (ie. a \"verbose\" mode, or \"quite\" mode), creating files to replay !!    program execution, duplicating output, ... !! !!##OPTIONS !!   WHERE  indicates where messages are written. A combination of the !!          following characters can be used... !! !!      Usually one of these to write to the standard output files ... !! !!      S   write to stdout or iounit set with journal(unit) or !!          journal(unit,filename). !!      E   write to stderr !! !!      And one of these to write to trail file (ignore if no trail file !!      defined) ... !! !!      C   write to trail file as a comment (if file is open) !!          Writing output \"as a comment\" means it is preceded by a pound(#) !!          character. !!      T   write to trail file (if file is open) !! !!      Usually used by itself !! !!      D   write to trail file as a comment with \"DEBUG:\" prefix in front !!          of message (if file is open) if debug mode is on. Write to stdout !!          if no trail file and debug mode is on. !! !!      Modifier for S|E|C|T|D specifiers !! !!      +   subsequent files are written to with advance='no'. Position is !!          important. '+sc' does an advance='no' on both files, 's+c' !!          only does the advance='no' for the trail file. !! !!      Mode changing options used by themselves: !! !!      >   turn off debug messages !!      <   turn on debug messages !!      O   open trail file using value of \"message\" parameter or close !!          trail file if no filename or a blank filename. !!      A   Auxiliary programs that also want to write to the current log file !!          (a2b, z2a, ...) call this routine to see if there is a trail file !!          being generated and then add to it so that a program like ush(1f) !!          can call the auxiliary programs and still just generate one log file, !!          but if the auxiliary program is used as a stand-alone program no trail !!          is generated. !! !!   VALUES(S)   message to write to stdout, stderr, and the trail file. !!               a numeric or character value to optionally be appended !!               to the message. Up to twenty values are allowed. The WHERE !!               field is required if there is anything other than a single !!               character string or not values at all. !!   FILENAME    when WHERE=\"O\" to turn the trail file on or off, the \"message\" !!               field becomes the trail filename to open. If blank, writing !!               to the trail file is turned off. !!   TIMEFORMAT  when WHERE=\"%\" the message is treated as a time format !!               specification as described under now(3f). !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_journal !!    use M_framework__journal, only : journal !!    !! BASIC USAGE !!    call journal(& !!    & 'write to standard output as-is, and trail file as a comment if open') !!    ! since trail file is not yet open, only stdout will display output !!    call journal('c','ignored, as trail file is not open') !!    ! now open trail file \"trail\" !!    call journal('o','trail') !!    call journal('sc','same thing except now trail file is open') !!    ! only write to trail file if open !!    call journal('c',& !!    & 'not ignored, as trail file is open. Written with # suffix') !!    call journal('t',& !!    & 'not ignored, as trail file is open. Written as-is') !!    ! turn off trail file !!    call journal('o','') !!    end program demo_journal !! !!   Adding intrinsic scalar values to the message: !! !!    program test_journal !!    use M_framework__journal, only: journal !!    implicit none !!       call journal('S','This is a test with no optional value') !!       call journal('S','This is a test with a logical value',.true.) !!       call journal('S', & !!         & 'This is a test with a double value',1234567890.123456789d0) !!       call journal('S', & !!         & 'This is a test with a real value',1234567890.123456789) !!       call journal('S','This is a test with an integer value',1234567890) !!       call journal('STDC','This is a test using STDC',1234567890) !!       call journal('stdc','This is a test using stdc',1234567890) !!       call journal('o','journal.txt')  ! open trail file !!       call journal('S', & !!         & 1,12.34,56789.111111111d0,.false.,'a bunch of values') !!       ! the combinations that make sense !!       call journal('st','stdout and trail') !!       call journal('s' ,'stdout only') !!       call journal('t' ,'trail only') !!       call journal('sc','stdout and trail_comment') !!       call journal('c' ,'trail_comment only ') !!       call journal('d' ,'debug only') !!       call journal('e' ,'stderr only') !!       call journal('o' ,' ') ! closing trail file !!    end program test_journal !! !!    program testit !!    ! this is a utility program that calls the module routines. It is !!    ! typically built using ccall(1). !!    use M_framework__journal, only : journal !!    character(len=:),allocatable :: time_stamp_prefix !!     call journal('s', & !!     & '------------------------------------------------------------') !!     call journal('s','SIMPLE WRITES') !!     call one() !!     call two() !!     call journal('sc', & !!     & 'called ONE() and TWO() but did not generate a log file') !!     call journal('s', & !!     & '------------------------------------------------------------') !!     call journal('s','SIMPLE WRITES WITH LOG FILE') !!     call journal('o','journal.txt')     ! open trail file !!     call one() !!     call two() !!     call journal('sc', & !!     & 'called ONE() and TWO() and generated log file journal.txt') !!     call journal('','journal.txt')      ! close trail file !!     call journal('s', & !!     & '------------------------------------------------------------') !!     call journal('s','SIMPLE WRITES WITH TIMING INFORMATION') !!     ! change time prefix !!     time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b' !!     call journal('%',time_stamp_prefix) ! set a message time prefix !!     call journal('o','timed.txt')       ! open trail file !!     call one() !!     call two() !!     call journal('sc', & !!     & 'called ONE() and TWO() and generate log file timed.txt') !!     call journal('','timed.txt')        ! close trail file !!     call journal('%','')                ! turn off time prefix !!     call journal('o','timed.txt')       ! open trail file !!     call journal('s', & !!     & '------------------------------------------------------------') !! !!    contains !! !!       subroutine two() !!          call journal('Entered subroutine two') !!          call journal('Exited subroutine two') !!       end subroutine two !! !!       subroutine one() !!          call journal('Entered subroutine one') !!          sum=-HUGE(1.0) !!          do i=1,10000000 !!            sum=sum+sqrt(real(i)) !!          enddo !!          write(*,*)'SUM=',sum !!          call journal('Exited subroutine one') !!       end subroutine one !! !!    end program testit !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain public journal interface journal module procedure flush_trail ! journal()                ! no options module procedure write_message_only ! journal(c)               ! must have one string module procedure where_write_message_all ! journal(where,[g1-g9])   ! must have two strings module procedure set_stdout_lun ! journal(i)               ! first is not a string end interface journal ! ident_1=\"@(#) M_framework__journal journal(3fg) provides public message routine no paging or graphic mode change\" ! global variables !integer,parameter,private  :: stdin=INPUT_UNIT integer , save , private :: my_stdout = OUTPUT_UNIT logical , save :: debug = . false . integer , save :: last_int = 0 integer , parameter , private :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: secday = 8640 0.0d0 ! 24:00:00 hours as seconds contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine where_write_message ( where , msg ) ! ident_2=\"@(#) M_framework__journal where_write_message(3fp) basic message routine used for journal files\" character ( len =* ), intent ( in ) :: where character ( len =* ), intent ( in ) :: msg ! !  writes error messages and general information text to stdout and the trace file !     where=*C* write to trail file as a comment (if file is open) !     where=*D* write to trail file as a comment with DEBUG: prefix in front of message (if file is open and debug mode on) !     where=*E* write to stderr !     where=*S* write to stdout or iounit set with journal(unit) or journal(unit,filename) !     where=*T* write to trail file (if file is open) !     where=*+* subsequent writes for this call are written with advance='no' !     where=> turn on debug messages (change mode), which are ones with WHERE='D' !     where=< turn off debug messages  (change mode), which are ones with WHERE='D' !     where=O open trail file \"msg\" or close trail file if blank filename is given !     where=% set prefix to run thru now(3f) to generate time prefix strings, blank turns off time prefix !     where=N open new file and assign stdout to the file unless file name is blank; then revert to my_stdout being original stdout. ! !  the trail file messages are preceded by a pound character (#) by default so they can easily be interpreted as comments !  if the trace file is subsequently used as input data for a program ! logical , save :: trailopen = . false . integer , save :: itrail character , save :: comment = '#' integer :: i integer :: ios integer :: times ! number of times written to stdout character ( len = 3 ) :: adv ! whether remaining writes from this call use advancing I/O character ( len = :), allocatable , save :: prefix_template ! string to run thru now_ex(3f) to make prefix character ( len = :), allocatable :: prefix ! the prefix string to add to output logical , save :: prefix_it = . false . ! flag whether time prefix mode is on or not character ( len = 4096 ) :: mssge !----------------------------------------------------------------------------------------------------------------------------------- adv = 'yes' !----------------------------------------------------------------------------------------------------------------------------------- if ( prefix_it ) then prefix = now_ex ( prefix_template ) else prefix = '' endif !----------------------------------------------------------------------------------------------------------------------------------- times = 0 do i = 1 , len_trim ( where ) select case ( where ( i : i )) case ( 'T' , 't' ) if ( trailopen ) then write ( itrail , '(a)' , advance = adv ) prefix // trim ( msg ) !!elseif(times == 0)then !!   write(my_stdout,'(a)',advance=adv)prefix//trim(msg) !!   times=times+1 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'S' , 's' ) write ( my_stdout , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( 'E' , 'e' ) write ( stderr , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( '+' ); adv = 'no' !----------------------------------------------------------------------------------------------------------------------------- case ( '>' ); debug = . true . !----------------------------------------------------------------------------------------------------------------------------- case ( '<' ); debug = . false . !----------------------------------------------------------------------------------------------------------------------------- case ( '%' ) ! setting timestamp prefix if ( msg == '' ) then ! if message is blank turn off prefix prefix_it = . false . else ! store message as string to pass to now_ex() on subsequent calls to make prefix prefix_template = msg prefix_it = . true . endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'N' ) ! new name for my_stdout if ( msg /= ' ' . and . msg /= '#N#' . and . msg /= '\"#N#\"' ) then ! if filename not special or blank open new file close ( unit = last_int , iostat = ios ) open ( unit = last_int , file = adjustl ( trim ( msg )), iostat = ios ) if ( ios == 0 ) then my_stdout = last_int else write ( * , * ) '*journal* error opening redirected output file, ioerr=' , ios write ( * , * ) '*journal* msg=' // trim ( msg ) endif elseif ( msg == ' ' ) then close ( unit = last_int , iostat = ios ) my_stdout = 6 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'C' , 'c' ) if ( trailopen ) then write ( itrail , '(3a)' , advance = adv ) prefix , comment , trim ( msg ) elseif ( times == 0 ) then !! write(my_stdout,'(2a)',advance=adv)prefix,trim(msg) !! times=times+1 endif case ( 'D' , 'd' ) if ( debug ) then if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'DEBUG: ' , trim ( msg ) elseif ( times == 0 ) then write ( my_stdout , '(3a)' , advance = adv ) prefix , 'DEBUG:' , trim ( msg ) times = times + 1 endif endif case ( 'F' , 'f' ) flush ( unit = itrail , iostat = ios , iomsg = mssge ) if ( ios /= 0 ) then write ( * , '(a)' ) trim ( mssge ) endif case ( 'A' , 'a' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )),& & form = 'formatted' , iostat = ios , position = 'append' ) trailopen = . true . endif case ( 'O' , 'o' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )), form = 'formatted' , iostat = ios ) trailopen = . true . else if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'closing trail file:' , trim ( msg ) endif close ( unit = itrail , iostat = ios ) trailopen = . false . endif case default write ( my_stdout , '(a)' , advance = adv ) '*journal* bad WHERE value ' // trim ( where ) // ' when msg=[' // trim ( msg ) // ']' end select enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine where_write_message !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine flush_trail () ! ident_3=\"@(#) M_framework__journal flush_trail(3fp) flush trail file\" call where_write_message ( 'F' , 'IGNORE THIS STRING' ) end subroutine flush_trail !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine set_stdout_lun ( iounit ) ! ident_4=\"@(#) M_framework__journal set_stdout_lun(3fp) change I/O logical unit value for standard writes\" integer , intent ( in ) :: iounit my_stdout = iounit end subroutine set_stdout_lun !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    where_write_message_all(3f) - [M_framework__journal] converts any !!    standard scalar type to a string and calls journal(3f) !!    (LICENSE:PD) !!##SYNOPSIS !! !!   subroutine where_write_message_all(where,g0,g1,g2,..,gj,sep) !! !!     character(len=*),intent(in)   :: where !!     class(*),intent(in)           :: g0 !!     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!     character,intent(in),optional :: sep !! !!##DESCRIPTION !!    where_write_message_all(3f) builds and writes a space-separated string !!    from up to twenty scalar values. !! !!##OPTIONS !! !!    where       string designating where to write message, as with journal(3f) !!    g0          value to print. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!                or CHARACTER. !!    g[1-9a-j]   optional additional values to print the value of after g0. !!    sep         separator to add between values. Default is a space. Should !!                always be called with a keyword, as in \"sep=VALUE\". !!##RETURNS !!    where_write_message_all  description to print !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_wm_all !!    use M_framework__journal, only : where_write_message_all !!    implicit none !!    end program program demo_wm_all !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine where_write_message_all ( where , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , sep ) implicit none ! ident_5=\"@(#) M_framework__journal where_write_message_all(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: where class ( * ), intent ( in ) :: g0 class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character , intent ( in ), optional :: sep call where_write_message ( where , str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , sep = sep )) end subroutine where_write_message_all !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine write_message_only ( message ) ! ident_6=\"@(#) M_framework__journal write_message_only(3fp) calls JOURNAL('sc' message)\" character ( len =* ), intent ( in ) :: message !----------------------------------------------------------------------------------------------------------------------------------- call where_write_message ( 'sc' , trim ( message )) !----------------------------------------------------------------------------------------------------------------------------------- end subroutine write_message_only !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine d2j ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- ! * Author:    John S. Urban ! * Version:   1.0 2015-12-21 ! * Reference: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Day must be non-negative ! * Julian Day starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_7=\"@(#) d2j(3f) Converts proleptic Gregorian date array to Julian Day\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = dp ), intent ( out ) :: julian ! Julian Day (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return, 0 for successful execution,-1=invalid year,-2=invalid month,-3=invalid day, ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = dp ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or Febuary, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for Febuary !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.d0 ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine d2j !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine d2u ( dat , unixtime , ierr ) ! ident_8=\"@(#) d2u(3f) Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970)\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = dp ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on successful, otherwise 1 real ( kind = dp ) :: julian real ( kind = dp ), save :: julian_at_epoch logical , save :: first = . true . !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Compute zero of Unix Time in Julian days and save call d2j ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ], julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call d2j ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine d2u !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION d2o ( dat ) RESULT ( ordinal ) ! ident_9=\"@(#) d2o(3f) Converts date-time array to Ordinal day\" INTEGER , INTENT ( IN ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME INTEGER :: ordinal ! the returned number of days REAL ( KIND = dp ) :: unixtime ! Unix time (seconds) REAL ( KIND = dp ) :: unix_first_day INTEGER :: ierr ! return 0 on successful, otherwise 1 from d2u(3f) CALL d2u ( dat , unixtime , ierr ) ! convert date to Unix Epoch Time IF ( ierr . NE . 0 ) THEN write ( * , * ) '*d2o* bad date array' ordinal =- 1 ! initialize to bad value ELSE CALL d2u ([ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ], unix_first_day , ierr ) ordinal = int (( unixtime - unix_first_day ) / secday ) + 1 ENDIF END FUNCTION d2o !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION v2mo ( imonth ) RESULT ( month_name ) ! ident_10=\"@(#) v2mo(3f) returns the month name of a Common month\" CHARACTER ( LEN = :), ALLOCATABLE :: month_name ! string containing month name or abbreviation. INTEGER , INTENT ( IN ) :: imonth ! the number of the month(1-12) CHARACTER ( LEN =* ), PARAMETER :: names ( 12 ) = [ character ( len = 9 ) :: & & 'January  ' , 'February ' , 'March    ' , 'April    ' , 'May      ' , 'June     ' , & & 'July     ' , 'August   ' , 'September' , 'October  ' , 'November ' , 'December ' ] SELECT CASE ( imonth ) CASE ( 1 : 12 ); month_name = TRIM ( names ( imonth )) CASE DEFAULT ; month_name = 'UNKNOWN' END SELECT END FUNCTION v2mo !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION now ( format ) ! ident_11=\"@(#) JSU 2015-10-24\" CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: format CHARACTER ( LEN = :), ALLOCATABLE :: now INTEGER :: values ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- CALL DATE_AND_TIME ( VALUES = values ) IF ( PRESENT ( format )) THEN IF ( format . NE . ' ' ) THEN now = fmtdate ( values , format ) ELSE now = fmtdate ( values , '%Y-%M-%D %h:%m:%s %z' ) ENDIF ELSE NOW = fmtdate ( values , '%Y-%M-%D %h:%m:%s %z Julian date is %J Epoch time is %E ' ) ENDIF END FUNCTION now !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION fmtdate ( values , format ) RESULT ( timestring ) ! Read the FORMAT string and replace the \"%\" strings per the following rules: !----------------------------------------------------------------------------------------------------------------------------------- ! ident_12=\"@(#) fmtdate(3f) given date array return date as string using format\" CHARACTER ( LEN =* ), INTENT ( IN ) :: format ! input format string INTEGER , DIMENSION ( 8 ), INTENT ( IN ) :: values ! numeric time values as DATE_AND_TIME(3f) intrinsic returns CHARACTER ( LEN = :), ALLOCATABLE :: timestring !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - INTEGER :: i10 LOGICAL :: keyword ! flag that previous character was a % character CHARACTER ( LEN = 9 ) :: day ! day of week CHARACTER ( LEN = 1 ) :: chara ! character being looked at in format string CHARACTER ( LEN = 4096 ) :: text ! character array INTEGER :: iout INTEGER :: weekday INTEGER :: ierr INTEGER , SAVE :: called = 0 LOGICAL , SAVE :: since = . FALSE . REAL ( KIND = dp ) :: julian REAL ( KIND = dp ) :: cputime INTEGER :: ii REAL ( KIND = dp ) :: unixtime REAL ( KIND = dp ), save :: unixtime_last INTEGER :: systemclock , countrate INTEGER :: iso_year , iso_week , iso_weekday CHARACTER ( LEN = 10 ) :: iso_name CHARACTER ( LEN = 2 ) :: dayend text = ' ' !  write string, when encounter a percent character do a substitution keyword = . FALSE . iout = 1 DO i10 = 1 , LEN ( format ) chara = format ( i10 : i10 ) IF ( chara . eq . '%' . and .. not . keyword ) THEN keyword = . TRUE . CYCLE ENDIF IF ( keyword ) THEN keyword = . FALSE . SELECT CASE ( chara ) !===================================================================================== CASE ( '%' ); WRITE ( text ( iout :), '(A1)' ) chara ! literal percent character !===================================================================================== CASE ( 'b' ); WRITE ( text ( iout :), '(A1)' ) ' ' ! space character !===================================================================================== CASE ( 'c' ); CALL cpu_time ( cputime ) ! CPU_TIME() WRITE ( text ( iout :), '(G0)' ) cputime !===================================================================================== CASE ( 'C' ); called = called + 1 ! number of times this routine called WRITE ( text ( iout :), '(I0)' ) called !===================================================================================== CASE ( 'd' ); ! the day of the month 1st..31st dayend = '  ' select case ( values ( 3 )) case ( 1 , 21 , 31 ); dayend = 'st' case ( 2 , 22 ); dayend = 'nd' case ( 3 , 23 ); dayend = 'rd' case ( 4 : 20 , 24 : 30 ); dayend = 'th' case default end select WRITE ( text ( iout :), '(I2,a)' ) values ( 3 ), dayend !===================================================================================== CASE ( 'D' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 3 ) ! the day of the month 1..31 !===================================================================================== CASE ( 'e' ); CALL d2u ( values , unixtime , ierr ) ! integer Unix Epoch time in seconds WRITE ( text ( iout :), '(G0)' ) int ( unixtime ) !===================================================================================== CASE ( 'E' ); CALL d2u ( values , unixtime , ierr ) ! Unix Epoch time in seconds WRITE ( text ( iout :), '(G0)' ) unixtime !===================================================================================== CASE ( 'h' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 5 ) ! the hour of the day, in the range of 0 to 23 !===================================================================================== CASE ( 'H' ); ii = mod ( values ( 5 ), 12 ) ! hour of day in range 1..12 if ( ii . eq . 0 ) then ii = 12 endif WRITE ( text ( iout :), '(I2.2)' ) ii !===================================================================================== CASE ( 'i' ); CALL woy ( values , iso_year , iso_week , iso_weekday , iso_name ) ! ISO week of year WRITE ( text ( iout :), '(I0)' ) iso_week !===================================================================================== CASE ( 'I' ); CALL woy ( values , iso_year , iso_week , iso_weekday , iso_name ) ! iso-8601 Week-numbering year date WRITE ( text ( iout :), '(a)' ) iso_name !===================================================================================== CASE ( 'j' ); CALL d2j ( values , julian , ierr ) ! integer Julian date (truncated to integer) WRITE ( text ( iout :), '(I0)' ) int ( julian ) !===================================================================================== CASE ( 'J' ); CALL d2j ( values , julian , ierr ) ! Julian date to milliseconds WRITE ( text ( iout :), '(I0,\".\",i3.3)' ) int ( julian ), int (( julian - int ( julian )) * 100 0.0 ) !===================================================================================== CASE ( 'k' ); call system_clock ( count = systemclock , count_rate = countrate ) ! systemclock/countrate WRITE ( text ( iout :), '(G0)' ) real ( systemclock ) / countrate !===================================================================================== CASE ( 'l' ); WRITE ( text ( iout :), '(A3)' ) v2mo ( values ( 2 )) ! three characters of the name of the month of the year !===================================================================================== CASE ( 'L' ); WRITE ( text ( iout :), '(A)' ) v2mo ( values ( 2 )) ! name of the month of the year !===================================================================================== CASE ( 'm' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 6 ) ! the minutes of the hour, in the range 0 to 59 !===================================================================================== CASE ( 'M' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 2 ) ! month of year (1..12) !===================================================================================== CASE ( 'N' ); if ( values ( 5 ). ge . 12 ) then ! AM||PM WRITE ( text ( iout :), '(\"PM\")' ) else WRITE ( text ( iout :), '(\"AM\")' ) endif !===================================================================================== CASE ( 'O' ); WRITE ( text ( iout :), '(I3.3)' ) d2o ( values ) ! Ordinal day of year !===================================================================================== CASE ( 's' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 7 ) ! the seconds of the minute, in the range 0 to 60 !===================================================================================== CASE ( 'S' ); IF (. NOT . since ) THEN ! seconds since last called since = . TRUE . CALL d2u ( values , unixtime_last , ierr ) ENDIF CALL d2u ( values , unixtime , ierr ) WRITE ( text ( iout :), '(G0)' ) unixtime - unixtime_last unixtime_last = unixtime !===================================================================================== CASE ( 't' ); WRITE ( text ( iout :), '(A1)' ) CHAR ( 9 ) ! tab character !===================================================================================== CASE ( 'U' ); CALL dow ( values , weekday , day , ierr ) ! Return the day of the week, 1..7 Sunday=1 WRITE ( text ( iout :), '(I1)' ) weekday !===================================================================================== CASE ( 'u' ); CALL dow ( values , weekday , day , ierr ) ! Return the day of the week, 1..7 Monday=1 WRITE ( text ( iout :), '(I1)' ) mod ( weekday + 5 , 7 ) + 1 !===================================================================================== CASE ( 'W' ); CALL dow ( values , weekday , day , ierr ) ! Return the name of the day of the week WRITE ( text ( iout :), '(a)' ) day !===================================================================================== CASE ( 'w' ); CALL dow ( values , weekday , day , ierr ) ! Return the first three characters of the day of the week WRITE ( text ( iout :), '(A3)' ) day ( 1 : 3 ) !===================================================================================== CASE ( 'x' ); WRITE ( text ( iout :), '(I3.3)' ) values ( 8 ) ! the milliseconds of the second, in the range 0 to 999 !===================================================================================== CASE ( 'Y' ); WRITE ( text ( iout :), '(I4.4)' ) values ( 1 ) ! the year, including the century (for example, 1990) !===================================================================================== CASE ( 'Z' ); WRITE ( text ( iout :), '(SP,I5.4)' ) values ( 4 ) ! time difference with respect to UTC in minutes !===================================================================================== CASE ( 'z' ); WRITE ( text ( iout :), '(I3.2,\":\",I2.2)' ) int ( values ( 4 ) / 60 ), abs ( mod ( values ( 4 ), 60 )) ! time from UTC as +-hh:mm !===================================================================================== CASE DEFAULT WRITE ( text ( iout :), '(A1)' ) chara !===================================================================================== END SELECT !===================================================================================== iout = len_trim ( text ) + 1 ELSE WRITE ( text ( iout :), '(A1)' ) chara ; iout = iout + 1 ENDIF ENDDO timestring = trim ( text ) END FUNCTION fmtdate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine dow ( values , weekday , day , ierr ) ! ident_13=\"@(#) dow(3f) Return the day of the week\" real ( kind = dp ) :: julian ! the julian day for which the weekday is required, integer , intent ( in ) :: values ( 8 ) ! date and time array used to get time zone integer , intent ( out ), optional :: weekday ! The day of the week, 1 = Sunday character * ( * ), intent ( out ), optional :: day ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9 integer , intent ( out ) :: ierr ! Error return,0=correct,-1=invalid Julian day,-2=neither day nor weekday specified integer :: iweekday call d2j ( values , julian , ierr ) ! need julian date to calculate day of week for first day of month ierr = 0 if ( julian < 0 ) then ierr = - 1 return endif if (. not . present ( day ). and . . not . present ( weekday )) then ierr =- 2 return endif ! julian day starts at noon so add 1/2 day ! add time zone iweekday = mod ( int (( julian + dble ( values ( 4 ) / 6 0.0d0 / 2 4.0d0 ) + 0.5d0 ) + 1.0d0 ), 7 ) iweekday = iweekday + 1 if ( present ( day )) then select case ( iweekday ) case ( 1 ) ; day = 'Sunday' case ( 2 ) ; day = 'Monday' case ( 3 ) ; day = 'Tuesday' case ( 4 ) ; day = 'Wednesday' case ( 5 ) ; day = 'Thursday' case ( 6 ) ; day = 'Friday' case ( 7 ) ; day = 'Saturday' case default ; day = 'E-R-R-O-R' end select endif if ( present ( weekday )) then weekday = iweekday endif end subroutine dow !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine woy ( dat , iso_year , iso_week , iso_weekday , iso_name ) !----------------------------------------------------------------------------------------------------------------------------------- !  The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO). !  It is used (mainly) in government and business for fiscal years, as well as in timekeeping. !  The system specifies a week year atop the Gregorian calendar by defining a notation for ordinal weeks of the year. ! !  An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks. !  That is 364 or 371 days instead of the usual 365 or 366 days. !  The extra week is referred to here as a leap week, although ISO 8601 does not use this term. !  Weeks start with Monday. !  The first week of a year is the week that contains the first Thursday of the year (and, hence, always contains 4 January). !  ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January. !----------------------------------------------------------------------------------------------------------------------------------- !CALCULATION: !  The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year) !  and its day of the week. !METHOD: !   Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday), !   subtract the weekday from the ordinal date, then add 10. Divide the result !   by 7. Ignore the remainder; the quotient equals the week number. If !   the week number thus obtained equals 0, it means that the given date !   belongs to the preceding (week-based) year. If a week number of 53 is !   obtained, one must check that the date is not actually in week 1 of the !   following year. ! These two statements are assumed true when correcting the dates around January 1st ... !   o  The number of weeks in a given year is equal to the corresponding week number of 28 December. !   o  January 4th is always in the first week. ! !ISO_NAME: !  Week date representations are in the format YYYYWww-D. !  o [YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year. !  o [Www] is the week number prefixed by the letter W, from W01 through W53. !  o [D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday. ! !  For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written !     2006-W52-7 (extended form) !  or 2006W527 (compact form). ! !REFERENCE: !  From Wikipedia, the free encyclopedia 2015-12-19 !AUTHOR: !  John S. Urban, 2015-12-19 !----------------------------------------------------------------------------------------------------------------------------------- ! ident_14=\"@(#) woy(3f) Calculate iso-8601 Week-numbering year date yyyy-Www-d\" integer , parameter :: dp = kind ( 0.0d0 ) integer , intent ( in ) :: dat ( 8 ) ! input date array integer , intent ( out ) :: iso_year , iso_week , iso_weekday character ( len = 10 ), intent ( out ) :: iso_name integer :: shared_weekday integer :: last_week_this_year integer :: dec28_lastyear ( 8 ) ! December 28th is always in last week integer :: dec28_thisyear ( 8 ) ! December 28th is always in last week character ( len = 9 ) :: day integer :: ierr iso_year = dat ( 1 ) ! initially assume the iso_year is the same as the data array year iso_week = uncorrected_week_of_year ( dat ) ! this is the week number unless around January 1st iso_weekday = shared_weekday ! this is the number of the day of the week assuming Monday=1 dec28_thisyear = [ dat ( 1 ), 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week; use this to get number of weeks last_week_this_year = uncorrected_week_of_year ( dec28_thisyear ) ! get the number of the last week of the year (52 or 53) ! correct dates around January 1st if ( iso_week < 1 ) then ! if week < 1 then week = lastWeek(year -1) dec28_lastyear = [ dat ( 1 ) - 1 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week, we want its week number iso_week = uncorrected_week_of_year ( dec28_lastyear ) ! got the week number for the last week of last year (52 or 53) iso_year = dat ( 1 ) - 1 ! our date belongs to last year elseif ( iso_week > last_week_this_year ) then ! if week > lastweek(year) then week = 1 iso_week = iso_week - last_week_this_year ! our date belongs to next year iso_year = dat ( 1 ) + 1 endif write ( iso_name , '(i4.4,\"-W\",i2.2,\"-\",i1)' ) iso_year , iso_week , iso_weekday ! create ISO string designation for our date contains function uncorrected_week_of_year ( datin ) implicit none integer :: uncorrected_week_of_year integer , intent ( in ) :: datin ( 8 ) integer :: ordinal call dow ( datin , shared_weekday , day , ierr ) ! formula needs day of week 1..7 where Monday=1 shared_weekday = mod ( shared_weekday + 5 , 7 ) + 1 ! change from Sunday=1 to Monday=1 ordinal = d2o ( datin ) ! formula needs ordinal day of year where Jan 1st=1 uncorrected_week_of_year = ( ordinal - shared_weekday + 10 ) / 7 end function uncorrected_week_of_year end subroutine woy !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function now_ex ( format ) ! ident_15=\"@(#) M_time now_ex(3f) use of now(3f) outside of a module\" character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: now_ex now_ex = now ( format ) end function now_ex !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_framework__journal !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/m_framework__journal.f90.html"},{"title":"test_suite.f90 – M_framework","text":"Source Code program maketest use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none character ( len = :), allocatable :: words (:) character ( len =* ), parameter :: g = '(*(g0))' logical , parameter :: T = . true ., F = . false . integer :: out = stdout integer :: i ! a program to call the test_suite_* Fortran procedures write ( out , g ) \"program runtest\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only : real_kinds,real32,real64,real128\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only : integer_kinds,int8,int16,int32,int64\" write ( out , g ) \"use, intrinsic :: iso_fortran_env, only: &\" write ( out , g ) \"& stdin => input_unit,   &\" write ( out , g ) \"& stdout => output_unit, &\" write ( out , g ) \"& stderr => error_unit\" write ( out , g ) \"use M_framework, only : unit_test_start, unit_test, unit_test_msg\" write ( out , g ) \"use M_framework, only : unit_test_end, unit_test_stop, unit_test_mode\" write ( out , g ) \"use M_framework, only : unit_test_level, unit_test_flags\" write ( out , g ) \"!use M_xxxx\" write ( out , g ) \"implicit none\" write ( out , g ) \"logical, parameter :: T=.true., F=.false.\" write ( out , g ) \"logical            :: matched\" write ( out , g ) \"! optional call to change default modes\" write ( out , g ) \"   call unit_test_mode(       &\" write ( out , g ) \"       keep_going=T,           &\" write ( out , g ) \"       flags=[0],              &\" write ( out , g ) \"       luns=[stdout],          &\" write ( out , g ) \"       command='',             &\" write ( out , g ) \"       brief=F,                &\" write ( out , g ) \"       match='',               &\" write ( out , g ) \"       interactive=F,          &\" write ( out , g ) \"       CMDLINE=T,              &\" write ( out , g ) \"       debug=F)\" write ( out , g ) \"\" write ( out , g ) '   unit_test_level=0' words = get_stack () if ( size ( words ) . eq . 0 ) words = [ \"sample\" ] write ( out , g ) '' do i = 1 , size ( words ) write ( out , g ) '   call test_suite_' // trim ( words ( i )) // '()' end do write ( out , g ) '   call unit_test_stop()' write ( out , g ) '' write ( out , g ) 'contains' do i = 1 , size ( words ) write ( out , g ) '' write ( out , g ) 'subroutine test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_start(\"' // trim ( words ( i )) // '\",msg=\"\",matched=matched)' write ( out , g ) '   if(.not.matched)return' write ( out , g ) '   !!call unit_test(\"' // trim ( words ( i )) // '\", 0 .eq. 0, \"checking\",100)' write ( out , g ) '   call unit_test_end(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) 'end subroutine test_suite_' // trim ( words ( i )) end do write ( out , g ) '' write ( out , g ) 'end program runtest' contains function get_stack () result ( args ) character ( len = :), allocatable :: args (:) integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i exit GET_ARGS end if end do GET_ARGS end function get_stack end program maketest","tags":"","url":"sourcefile/test_suite.f90.html"},{"title":"unit_test.f90 – M_framework","text":"Source Code program maketest ! writes an individual file for each argument name use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none character ( len = :), allocatable :: words (:) character ( len =* ), parameter :: g = '(*(g0))' logical , parameter :: T = . true ., F = . false . integer :: out , i , iostat character ( len = 256 ) :: iomsg ! a program to call the test_suite_* Fortran procedures words = get_stack () if ( size ( words ) . eq . 0 ) words = [ '--help' ] if ( words ( 1 ). eq . '--help' ) then write ( stderr , g ) '--------------------------------------------------------------------------------' write ( stderr , g ) 'NAME                                                                            ' write ( stderr , g ) ' unit-test(1f) - create unit-test skeleton programs for use with M_framework(1) ' write ( stderr , g ) 'SYNOPSIS                                                                        ' write ( stderr , g ) '     unit_test ARG1 ARG2 ARG3 ARG4 ...                                          ' write ( stderr , g ) 'DESCRIPTION                                                                     ' write ( stderr , g ) '   generate skeleton programs in current directory named \"unit_test_ARG.f90\"    ' write ( stderr , g ) '   for use with \"fpm test\". Will not overwrite existing files.                  ' write ( stderr , g ) 'EXAMPLE                                                                         ' write ( stderr , g ) 'Create a new fpm project to try it out                                          ' write ( stderr , g ) '   fpm new tryit;cd tryit/test  # go to test/ directory of an fpm(1) project    ' write ( stderr , g ) ' unit_test a b c             # create three skeleton test files                 ' write ( stderr , g ) 'Ensure your fpm.toml file includes M_framework as a dependency with lines like  ' write ( stderr , g ) '[dev-dependencies]                                                              ' write ( stderr , g ) '   M_framework    = { git = \"https://github.com/urbanjost/M_framework.git\" }    ' write ( stderr , g ) 'Run tests                                                                       ' write ( stderr , g ) '    fpm test   # run all tests                                                  ' write ( stderr , g ) '    fpm test unit_test_c # run test \"c\"                                        ' write ( stderr , g ) '    fpm test \"timing_*\" # run tests starting with \"timing_\"                     ' write ( stderr , g ) '    fpm test -- command=bookkeeper  # use sample bookkeeper command to generate ' write ( stderr , g ) '                                    # CSV and HTML and NAMELIST files.          ' write ( stderr , g ) 'Now try it in a real fpm(1) test/ directory and add real tests or results in the' write ( stderr , g ) 'unit_test(3f) calls.                                                           ' write ( stderr , g ) '--------------------------------------------------------------------------------' !      write (stderr, g) '    [[test]]                                                                    ' !      write (stderr, g) '    name=\"test_suite\"                                                           ' !      write (stderr, g) '    source-dir=\"test\"                                                           ' !      write (stderr, g) '    main=\"check.f90\"                                                            ' !      write (stderr, g) '    [test.dependencies]                                                         ' !      write (stderr, g) '    M_framework = { git = \"https://github.com/urbanjost/M_framework.git\" }      ' stop endif do i = 1 , size ( words ) open ( newunit = out , file = 'unit_test_' // trim ( words ( i )) // '.f90' , status = 'new' , iostat = iostat , iomsg = iomsg ) if ( iostat . ne . 0 ) then write ( stderr , g ) trim ( iomsg ) cycle endif write ( out , g ) \"program unit_test_\" , trim ( words ( i )) write ( out , g ) \"use, intrinsic :: iso_fortran_env, only: &\" write ( out , g ) \"& real32, real64, real128,   &\" write ( out , g ) \"& int8, int16, int32, int64, &\" write ( out , g ) \"& stdin => input_unit,       &\" write ( out , g ) \"& stdout => output_unit,     &\" write ( out , g ) \"& stderr => error_unit\" write ( out , g ) \"use M_framework, only : unit_test_start, unit_test\" write ( out , g ) \"use M_framework, only : unit_test_end,   unit_test_stop\" write ( out , g ) \"use M_framework, only : unit_test_mode,  unit_test_msg\" write ( out , g ) \"use M_framework, only : unit_test_level, unit_test_flags\" write ( out , g ) \"!use M_xxxx\" write ( out , g ) \"implicit none\" write ( out , g ) \"logical, parameter :: T=.true., F=.false.\" write ( out , g ) \"! optional call to change default modes\" write ( out , g ) \"   call unit_test_mode(       &\" write ( out , g ) \"       keep_going=T,           &\" write ( out , g ) \"       flags=[0],              &\" write ( out , g ) \"       luns=[stdout],          &\" write ( out , g ) \"       command='',             &\" write ( out , g ) \"       brief=F,                &\" write ( out , g ) \"       silent=F,               &\" write ( out , g ) \"       verbose=F,              &\" write ( out , g ) \"       interactive=F,          &\" write ( out , g ) \"       cmdline=T,              &\" write ( out , g ) \"       debug=F)\" write ( out , g ) \"\" write ( out , g ) '   unit_test_level=0' write ( out , g ) '' write ( out , g ) '   call test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_stop()' write ( out , g ) '' write ( out , g ) 'contains' write ( out , g ) '' write ( out , g ) 'subroutine test_suite_' // trim ( words ( i )) // '()' write ( out , g ) '   call unit_test_start(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) '   !!call unit_test(\"' // trim ( words ( i )) // '\", 0 .eq. 0, \"checking\",100)' write ( out , g ) '   call unit_test_end(\"' // trim ( words ( i )) // '\",msg=\"\")' write ( out , g ) 'end subroutine test_suite_' // trim ( words ( i )) write ( out , g ) '' write ( out , g ) \"end program unit_test_\" , trim ( words ( i )) close ( unit = out , iostat = iostat ) enddo contains function get_stack () result ( args ) character ( len = :), allocatable :: args (:) character ( len = 256 ) :: errmsg = '' integer :: ilength , ilongest , iargs , istatus , i ilength = 0 ilongest = 1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0 iargs = command_argument_count () GET_LONGEST : do i = 1 , iargs ! look at all arguments call get_command_argument ( number = i , length = ilength , status = istatus ) !,errmsg=errmsg)    ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining length for argument ' , i , trim ( errmsg ) exit GET_LONGEST elseif ( ilength . gt . 0 ) then ilongest = max ( ilongest , ilength ) end if end do GET_LONGEST allocate ( character ( len = ilongest ) :: args ( iargs )) args (:) = '' GET_ARGS : do i = 1 , command_argument_count () ! copy array of arguments call get_command_argument ( number = i , value = args ( i ), length = ilength , status = istatus ) !,errmsg=errmsg)  ! get next argument if ( istatus /= 0 ) then ! stop program on error write ( stderr , * ) '*get_stack* error obtaining argument ' , i , trim ( errmsg ) exit GET_ARGS end if end do GET_ARGS end function get_stack end program maketest","tags":"","url":"sourcefile/unit_test.f90.html"},{"title":"test_suite_M_framework.f90 – M_framework","text":"Source Code program runtest use M_framework unit_test_level = 0 call test_framework () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_framework () call unit_test_start ( 'unit_test_start' , msg = '' ) !      call unit_test('unit_test_start', .true.,'expression is true') !      call unit_test('unit_test_start', .false.,'expression is false') call unit_test_end ( 'unit_test_start' , msg = '' ) end subroutine test_framework !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","url":"sourcefile/test_suite_m_framework.f90.html"},{"title":"demo_attr.f90 – M_framework","text":"Source Code program demo_attr use M_framework__attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_attr","tags":"","url":"sourcefile/demo_attr.f90.html"},{"title":"fsh.f90 – M_framework","text":"Source Code program testtype ! evaluate an interactive environment wrapped around fpm(1) and M_framework(1) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_framework , only : str , wrt implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: ios integer :: iostat character ( len = :), allocatable :: string character ( len = 256 ) :: line character ( len = 256 ) :: iomsg character ( len = 256 ) :: answer integer :: lun character ( len = :), allocatable :: strlevel integer :: level = 0 ; namelist / args / level character ( len = 80 ) :: compiler = '' ; namelist / args / compiler character ( len = 80 ) :: profile = '' ; namelist / args / profile character ( len = 80 ) :: link_flag = '' ; namelist / args / link_flag character ( len = 80 ) :: flag = '' ; namelist / args / flag character ( len = 80 ) :: cxx_flag = '' ; namelist / args / cxx_flag character ( len = 80 ) :: cxx_compiler = '' ; namelist / args / cxx_compiler character ( len = 80 ) :: c_flag = '' ; namelist / args / c_flag character ( len = 80 ) :: c_compiler = '' ; namelist / args / c_compiler character ( len = 80 ) :: archiver = '' ; namelist / args / archiver character ( len = :), allocatable :: options options = ' --compiler gfortran --profile debug' strlevel = 'level=0' write ( * , g ) ' try different fpm(1) test commands, setting values via NAMELIST:' write ( * , g ) ' Enter command (\"help\" for more information):' INFINITE : do write ( * , g , iostat = ios , iomsg = iomsg , advance = 'no' ) 'fsh>' read ( * , '(a)' , iostat = ios , iomsg = iomsg ) line if ( ios . ne . 0 ) then write ( * , g ) trim ( iomsg ) cycle INFINITE endif if ( adjustl ( line ( 1 : 1 )) . eq . '#' ) cycle select case ( line ) case ( 'test' ) string = str ( 'fpm test --target ''*'' ' , options , ' -- luns=6' , strlevel ) call run ( string ) case ( 'brief' ) string = str ( 'fpm test --target ''*'' ' , options , ' -- luns=6 brief' , strlevel ) call run ( string ) case ( 'build' ) string = str ( 'fpm build                ' , options , ' -- luns=6' , strlevel ) call run ( string ) case ( 'run' ) call run ( str ( 'fpm run --target ''*'' ' , options , ' -- luns=6 brief' , strlevel )) case ( 'example' ) call run ( str ( 'fpm run --target ''*'' ' , options , ' --example -- luns=6 brief' , strlevel )) case ( 'valgrind' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --runner ''valgrind'' -- luns=6 brief interactive ' , strlevel )) case ( 'valgrind+' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --runner ''valgrind --leak-check=full '' -- luns=6 brief interactive ' , strlevel )) case ( 'debug' ) call run ( str ( 'fpm test --target ''*'' ' , options , & & ' --verbose --runner ''gdb -ex \"list,0\" -ex run --quiet --args'' -- luns=6 ' , strlevel )) case ( 'shell' , 'sh' ) call run ( 'bash' ) case ( 'list' ) write ( * , g ) 'APPLICATIONS:' call run ( 'fpm run --list' ) write ( * , g ) 'EXAMPLES:' call run ( 'fpm run --example --list' ) write ( * , g ) 'TESTS:' call run ( 'fpm test --list' ) case ( 'q' , 'stop' , 'quit' , 'exit' , 'end' , '.' ) exit INFINITE case ( 'help' , '?' ) write ( * , '(a)' ) [ character ( len = 80 ) :: & 'Any unrecognized command is passed to the system. Verbs are                     ' , & 'TESTS:                                                                          ' , & '   test      -- run \"fpm test\"  with current options                            ' , & '   brief     -- run \"fpm test\" tests in brief mode                              ' , & '   build     -- run \"fpm build\" with current options                            ' , & '   run       -- run \"fpm run\" with current options                              ' , & '   example   -- run \"fpm run --example \" with current options                   ' , & '   debug     -- run tests with gdb(1)                                           ' , & '   valgrind  -- run tests with \"valgrind\"                                       ' , & '   valgrind+ -- run tests with \"valgrind --leak-check=full\"                     ' , & 'NAMELIST VARIABLES: set current options                                         ' , & '   save      -- write NAMELIST config file using current settings               ' , & '   load      -- read NAMELIST config file to set options                        ' , & '   show      -- show variables that may be set                                  ' , & '   set       -- set NAMELIST values in submode                                  ' , & 'HOUSEKEEPING:                                                                   ' , & '   list      -- list targets                                                    ' , & '   bash|sh   -- bash shell                                                      ' , & '   stop|q|quit|exit|end                                                         ' , & 'EXAMPLE:                                                                        ' , & '    set                                                                         ' , & '    compiler=\"ifx\"                                                              ' , & '    level=3                                                                     ' , & '    .                                                                           ' , & '    brief                                                                       ' , & '    debug                                                                       ' , & '    quit                                                                        ' , & ' ' ] case ( 'show' ) write ( * , g ) 'options...' write ( * , nml = args , delim = 'quote' ) !! something where you could restrict nml output to just listed names would be nice !!write(*,nml=args)['A','H'] !!write(*,nml=*NML)args['A','H'] case ( 'load' ) write ( * , '(a)' , advance = 'no' ) 'filename:' read ( * , '(a)' , iostat = iostat ) answer if ( iostat . ne . 0 ) exit open ( file = answer , iostat = iostat , newunit = lun ) if ( iostat . ne . 0 ) exit read ( lun , args , iostat = iostat ) close ( unit = lun , iostat = iostat ) case ( 'save' ) write ( * , g , advance = 'no' ) 'filename:' read ( * , '(a)' , iostat = iostat ) answer if ( iostat . ne . 0 ) exit open ( file = answer , iostat = iostat , newunit = lun ) if ( iostat . ne . 0 ) exit write ( lun , args , iostat = iostat ) close ( unit = lun , iostat = iostat ) case ( 'set' ) UPDATE : block character ( len = :), allocatable :: intmp do write ( * , g ) 'enter \".\" to exit set mode. Current values are ...' write ( * , nml = args , iostat = iostat , iomsg = iomsg ) read ( * , '(a)' , iostat = iostat ) line if ( line . eq . '.' ) exit intmp = '&ARGS ' // trim ( line ) // '/' read ( intmp , nml = args , iostat = iostat , iomsg = iomsg ) if ( iostat . ne . 0 ) then write ( * , * ) 'ERROR:' , trim ( iomsg ) endif enddo strlevel = str ( 'level=' , level , sep = '' ) end block UPDATE ! add //'' to avoid gfortran-11 bug options = str ( & & str ( ' --compiler \"' , compiler , '\"' , if = compiler . ne . '' , sep = '' ) // '' , & & str ( ' --profile \"' , profile , '\"' , if = profile . ne . '' , sep = '' ) // '' , & & str ( ' --link-flag \"' , link_flag , '\"' , if = link_flag . ne . '' , sep = '' ) // '' , & & str ( ' --flag flag \"' , flag , '\"' , if = flag . ne . '' , sep = '' ) // '' , & & str ( ' --cxx-flag \"' , cxx_flag , '\"' , if = cxx_flag . ne . '' , sep = '' ) // '' , & & str ( ' --cxx-compiler \"' , cxx_compiler , '\"' , if = cxx_compiler . ne . '' , sep = '' ) // '' , & & str ( ' --c-flag \"' , c_flag , '\"' , if = c_flag . ne . '' , sep = '' ) // '' , & & str ( ' --c-compiler \"' , c_compiler , '\"' , if = c_compiler . ne . '' , sep = '' ) // '' , & & str ( ' --archiver \"' , archiver , '\"' , if = archiver . ne . '' , sep = '' ) // '' ) case default call run ( line ) end select enddo INFINITE contains subroutine run ( command ) ! convenience routine so command does not cause program to stop character ( len =* ) :: command logical , parameter :: wait = . true . integer :: exitstat integer :: cmdstat character ( len = 256 ) :: cmdmsg call wrt ([ error_unit ], \"+ \" , command ) cmdmsg = ' ' call execute_command_line ( command , wait , exitstat , cmdstat , cmdmsg ) if ( cmdstat /= 0 ) then call wrt ([ error_unit ], \"cmdstat: \" , cmdmsg , 'for command :' , command ) elseif ( cmdmsg /= '' ) then call wrt ([ error_unit ], \"exitstat: \" , cmdmsg , 'for command :' , command ) endif end subroutine run end program testtype","tags":"","url":"sourcefile/fsh.f90.html"},{"title":"test_suite_M_framework__approx.f90 – M_framework","text":"Source Code program runtest use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT use M_framework__msg use M_framework__verify use M_framework__journal use M_framework__approx implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' call unit_test_mode ( level = 0 , luns = [ OUTPUT_UNIT ]) call test_accdig () ! compare two real numbers only up to a specified number of digits call test_almost () ! function compares two numbers only up to a specified number of digits call test_in_margin () ! check if two reals are approximately equal using a relative margin call test_round () ! round val to specified number of significant digits call test_significant () ! round val to specified number of significant digits call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_in_margin () call unit_test_start ( 'in_margin' , msg = '' ) !!call unit_test('in_margin', 0.eq.0, 'checking', 100) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_test ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_test ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_test ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_test ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_test_end ( 'in_margin' , msg = '' ) end subroutine test_in_margin !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_significant () doubleprecision , allocatable :: answers (:) doubleprecision , allocatable :: expected (:) call unit_test_start ( 'significant' , msg = '' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ) expected = [ 2.0d0 , 1.3d0 , 1.24d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.2345679d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RU, round up' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RD, round down ' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.234d0 , 1.2345d0 , 1.23456d0 , 1.234567d0 , 1.2345678d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RZ, round towards zero' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RN, round towards nearest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RC, compatible rounding rounds to closest representable number' ) answers = significant ( 1.23456789012345d0 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ) expected = [ 1.0d0 , 1.2d0 , 1.23d0 , 1.235d0 , 1.2346d0 , 1.23457d0 , 1.234568d0 , 1.2345679d0 , 1.23456789d0 ] call unit_test ( 'significant' , all ( answers == expected ), 'RP, processor-dependent rounding ' ) call unit_test_end ( 'significant' , msg = '' ) end subroutine test_significant !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_round () call unit_test_start ( 'round' , msg = '' ) !!call unit_test('round', 0.eq.0, 'checking', 100) call unit_test_end ( 'round' , msg = '' ) end subroutine test_round !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_accdig () integer , parameter :: sz = 16 doubleprecision :: a , b , aarr ( sz ), barr ( sz ) integer :: i , ind , indarr ( sz ) real :: acurcy , acurcyarr ( sz ) call unit_test_start ( 'accdig' , msg = '' ) do i = 1 , sz a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i ) call accdig ( a , b , 8.0 , acurcy , ind ) if ( unit_test_level > 0 ) write ( * , g ) i , a , b , acurcy , ind aarr ( i ) = a barr ( i ) = b enddo call accdig ( aarr , barr , 8.0 , acurcyarr , indarr ) if ( unit_test_level > 0 ) write ( * , g )( aarr ( i ), barr ( i ), acurcyarr ( i ), indarr ( i ), new_line ( 'a' ), i = 1 , sz ) call unit_test ( 'accdig' , all ( indarr . eq .[ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'expected 7 bad, got ' , count ( indarr . eq . 1 ) + 0 ) call unit_test_end ( 'accdig' , msg = '' ) end subroutine test_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_test_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_test ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i ), 'for' , x , y , r , 'expected' , expected ( i )) enddo call unit_test_end ( 'almost' , msg = '' ) end subroutine test_almost !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !   call test_accdig()         ! compare two real numbers only up to a specified number of digits !   call test_round()          ! round val to specified number of significant digits !   call test_significant()    ! round val to specified number of significant digits","tags":"","url":"sourcefile/test_suite_m_framework__approx.f90.html"},{"title":"demo_assert.f90 – M_framework","text":"Source Code program demo_assert use M_framework__msg , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( 'myroutine' , 101 , a > toobig , & & 'The value is too large' , a , ' > ' , toobig ) end program demo_assert","tags":"","url":"sourcefile/demo_assert.f90.html"},{"title":"demo_fmt.f90 – M_framework","text":"Source Code program demo_fmt use :: M_framework__msg , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","url":"sourcefile/demo_fmt.f90.html"},{"title":"demo_in_margin.f90 – M_framework","text":"Source Code program demo_in_margin use :: M_framework__approx , only : in_margin implicit none write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], & & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], & & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.01 ) end program demo_in_margin","tags":"","url":"sourcefile/demo_in_margin.f90.html"},{"title":"demo_pdec.f90 – M_framework","text":"Source Code program demo_pdec use M_framework__msg , only : pdec call pdec ( ' ABCDEFG abcdefg    ' ) end program demo_pdec","tags":"","url":"sourcefile/demo_pdec.f90.html"},{"title":"demo_stderr.f90 – M_framework","text":"Source Code program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_framework__msg , only : stderr implicit none call stderr ( 'A simple message' ) call stderr ( 'error: RVALUE=' , 3.0 / 4.0 ) call stderr ( 'error: IVALUE=' , 123456789 ) call stderr ( 'error: LVALUE=' ,. true .) SEVERAL : block integer :: least = 10 , most = 999 , ival =- 10 call stderr ( 'error: value' , ival , & & 'should be between' , least , 'and' , most ) endblock SEVERAL call stderr ( 'real32  :' , huge ( 0.0_real32 ), 0.0_real32 , & & 1234 5.6789_real32 , tiny ( 0.0_real32 )) call stderr ( 'real64  :' , huge ( 0.0_real64 ), 0.0_real64 , & & 1234 5.6789_real64 , tiny ( 0.0_real64 )) !#ifdef __NVCOMPILER !#else call stderr ( 'real128 :' , huge ( 0.0_real128 ), 0.0_real128 , & & 1234 5.6789_real128 , tiny ( 0.0_real128 )) !#endif call stderr ( 'complex :' , cmplx ( huge ( 0.0_real ), tiny ( 0.0_real ))) call stderr ( 'error: program will now stop' ) stop 1 end program demo_stderr","tags":"","url":"sourcefile/demo_stderr.f90.html"},{"title":"M_framework__msg.F90 – M_framework","text":"Source Code !----------------------------------------------------------------------------------------------------------------------------------- #define  __INTEL_COMP        1 #define  __GFORTRAN_COMP     2 #define  __NVIDIA_COMP       3 #define  __NAG_COMP          4 #define  __LLVM_FLANG_COMP   5 #define  __UNKNOWN_COMP   9999 #define FLOAT128 #ifdef __INTEL_COMPILER #   define __COMPILER__ __INTEL_COMP #elif __GFORTRAN__ == 1 #   define __COMPILER__ __GFORTRAN_COMP #elif __flang__ #   undef FLOAT128 #   warning  NOTE: REAL128 not supported #   define __COMPILER__ __LLVM_FLANG_COMP #elif __NVCOMPILER #   undef FLOAT128 #   warning  NOTE: REAL128 not supported #   define __COMPILER__ __NVIDIA_COMP #else #   define __COMPILER__ __UNKNOWN_COMP #   warning  NOTE: UNKNOWN COMPILER #endif !----------------------------------------------------------------------------------------------------------------------------------- module M_framework__msg use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none private !----------------------------------------------------------------------------------------------------------------------------------- ! USED SO FREQUENTLY IN OTHER MODULES PUT IN THIS ONE WITH NO DEPENDENCIES TO PREVENT CIRCULAR DEPENDENCY !----------------------------------------------------------------------------------------------------------------------------------- ! ident_1=\"@(#) M_framework__msg str(3f) {msg_scalar msg_one}\" public str public stderr public wrt public fmt public set public pdec public assert !!public :: a,i,f,g interface str module procedure msg_scalar , msg_one end interface str interface set module procedure set_scalar module procedure set_single end interface set type :: force_kwargs_hack ! force keywords, using @awvwgk method end type force_kwargs_hack ! so then any argument that comes after \"force_kwargs\" is a compile time error ! if not done with a keyword unless someone \"breaks\" it by passing something ! of this type: !    type(force_kwargs_hack), optional, intent(in) :: force_kwargs contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    str(3f) - [M_framework__msg] converts up to twenty standard scalar !!    type values to a string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!                      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if) !!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9 !!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!      logical,intent(in),optional          :: if !!      character(len=*),intent(in),optional :: sep !!      character,len=(:),allocatable        :: str !! !!##DESCRIPTION !!    str(3f) builds a space-separated string from up to twenty scalar values. !! !!##OPTIONS !!    g[0-9a-j]   Optional value to print the value of after the message. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !! !!                Optionally, all the generic values can be !!                single-dimensioned arrays. Currently, mixing scalar !!                arguments and array arguments is not supported. !! !!    sep         separator string used between values. Defaults to a space. !!                Must be specified with a keyword. !!    if          If false return a null string. !!                Must be specified with a keyword. !! !!##RETURNS !!    str     description to print !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_str !!    use M_framework__msg, only : str !!    implicit none !!    character(len=:),allocatable :: pr !!    character(len=:),allocatable :: frmt !!    integer                      :: biggest !! !!    pr=str('HUGE(3f) integers',huge(0),& !!    &'and real',huge(0.0),'and double',huge(0.0d0)) !!    write(*,'(a)')pr !!    pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) ) !!    write(*,'(a)')pr !!    pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) ) !!    write(*,'(a)')pr !!    pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) ) !!    write(*,'(a)')pr !! !!    ! create a format on the fly !!    biggest=huge(0) !!    ! +0 for gfortran-11 bug !!    frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='') !!    write(*,*)'format=',frmt !! !!    ! although it will often work, using str(3f) !!    ! in an I/O statement is not recommended !!    ! because if an error occurs str(3f) will try !!    ! to write while part of an I/O statement !!    ! which not all compilers can handle and is currently non-standard !!    write(*,*)str('program will now stop') !! !!    end program demo_str !! !!  Output !! !!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 ... !!    and double 1.7976931348623157E+308 !!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38 !!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ... !!    12345.678900000001 2.2250738585072014E-308 !!    complex         : (3.40282347E+38,1.17549435E-38) !!     format=(*(i9:,1x)) !!     program will now stop !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain pure function msg_scalar ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , & & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj , & & force_kwargs , sep , if ) implicit none ! ident_2=\"@(#) M_framework__msg msg_scalar(3fp) writes a message to a string composed of any standard scalar types\" class ( * ), intent ( in ), optional :: generic0 , generic1 , generic2 , generic3 , generic4 class ( * ), intent ( in ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 class ( * ), intent ( in ), optional :: generica , genericb , genericc , genericd , generice class ( * ), intent ( in ), optional :: genericf , genericg , generich , generici , genericj character ( len = :), allocatable :: msg_scalar type ( force_kwargs_hack ), optional , intent ( in ) :: force_kwargs character ( len =* ), intent ( in ), optional :: sep logical , intent ( in ), optional :: if character ( len = 4096 ) :: line integer :: istart integer :: increment character ( len = :), allocatable :: sep_local if ( present ( if )) then if (. not . if ) then msg_scalar = '' return endif endif if ( present ( sep )) then increment = len ( sep ) + 1 sep_local = sep else increment = 2 sep_local = ' ' endif istart = 1 line = '' if ( present ( generic0 )) call print_generic ( generic0 , line , istart , increment , sep_local ) if ( present ( generic1 )) call print_generic ( generic1 , line , istart , increment , sep_local ) if ( present ( generic2 )) call print_generic ( generic2 , line , istart , increment , sep_local ) if ( present ( generic3 )) call print_generic ( generic3 , line , istart , increment , sep_local ) if ( present ( generic4 )) call print_generic ( generic4 , line , istart , increment , sep_local ) if ( present ( generic5 )) call print_generic ( generic5 , line , istart , increment , sep_local ) if ( present ( generic6 )) call print_generic ( generic6 , line , istart , increment , sep_local ) if ( present ( generic7 )) call print_generic ( generic7 , line , istart , increment , sep_local ) if ( present ( generic8 )) call print_generic ( generic8 , line , istart , increment , sep_local ) if ( present ( generic9 )) call print_generic ( generic9 , line , istart , increment , sep_local ) if ( present ( generica )) call print_generic ( generica , line , istart , increment , sep_local ) if ( present ( genericb )) call print_generic ( genericb , line , istart , increment , sep_local ) if ( present ( genericc )) call print_generic ( genericc , line , istart , increment , sep_local ) if ( present ( genericd )) call print_generic ( genericd , line , istart , increment , sep_local ) if ( present ( generice )) call print_generic ( generice , line , istart , increment , sep_local ) if ( present ( genericf )) call print_generic ( genericf , line , istart , increment , sep_local ) if ( present ( genericg )) call print_generic ( genericg , line , istart , increment , sep_local ) if ( present ( generich )) call print_generic ( generich , line , istart , increment , sep_local ) if ( present ( generici )) call print_generic ( generici , line , istart , increment , sep_local ) if ( present ( genericj )) call print_generic ( genericj , line , istart , increment , sep_local ) msg_scalar = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 class ( * ), intent ( in ) :: generic character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line ( istart :), '(1pg0)' ) generic #endif type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep end subroutine print_generic !=================================================================================================================================== end function msg_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function msg_one ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 ,& & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj ,& & force_kwargs , sep , if ) implicit none ! ident_3=\"@(#) M_framework__msg msg_one(3fp) writes a message to a string composed of any standard one dimensional types\" class ( * ), intent ( in ) :: generic0 (:) class ( * ), intent ( in ), optional :: generic1 (:), generic2 (:), generic3 (:), generic4 (:), generic5 (:) class ( * ), intent ( in ), optional :: generic6 (:), generic7 (:), generic8 (:), generic9 (:) class ( * ), intent ( in ), optional :: generica (:), genericb (:), genericc (:), genericd (:), generice (:) class ( * ), intent ( in ), optional :: genericf (:), genericg (:), generich (:), generici (:), genericj (:) type ( force_kwargs_hack ), optional , intent ( in ) :: force_kwargs character ( len =* ), intent ( in ), optional :: sep logical , intent ( in ), optional :: if character ( len = :), allocatable :: sep_local character ( len = :), allocatable :: msg_one character ( len = 4096 ) :: line integer :: istart integer :: increment if ( present ( if )) then if (. not . if ) then msg_one = '' return endif endif if ( present ( sep )) then increment = 1 + len ( sep ) sep_local = sep else sep_local = ' ' increment = 2 endif istart = 1 line = ' ' call print_generic ( generic0 , line , istart , increment , sep_local ) if ( present ( generic1 )) call print_generic ( generic1 , line , istart , increment , sep_local ) if ( present ( generic2 )) call print_generic ( generic2 , line , istart , increment , sep_local ) if ( present ( generic3 )) call print_generic ( generic3 , line , istart , increment , sep_local ) if ( present ( generic4 )) call print_generic ( generic4 , line , istart , increment , sep_local ) if ( present ( generic5 )) call print_generic ( generic5 , line , istart , increment , sep_local ) if ( present ( generic6 )) call print_generic ( generic6 , line , istart , increment , sep_local ) if ( present ( generic7 )) call print_generic ( generic7 , line , istart , increment , sep_local ) if ( present ( generic8 )) call print_generic ( generic8 , line , istart , increment , sep_local ) if ( present ( generic9 )) call print_generic ( generic9 , line , istart , increment , sep_local ) if ( present ( generica )) call print_generic ( generica , line , istart , increment , sep_local ) if ( present ( genericb )) call print_generic ( genericb , line , istart , increment , sep_local ) if ( present ( genericc )) call print_generic ( genericc , line , istart , increment , sep_local ) if ( present ( genericd )) call print_generic ( genericd , line , istart , increment , sep_local ) if ( present ( generice )) call print_generic ( generice , line , istart , increment , sep_local ) if ( present ( genericf )) call print_generic ( genericf , line , istart , increment , sep_local ) if ( present ( genericg )) call print_generic ( genericg , line , istart , increment , sep_local ) if ( present ( generich )) call print_generic ( generich , line , istart , increment , sep_local ) if ( present ( generici )) call print_generic ( generici , line , istart , increment , sep_local ) if ( present ( genericj )) call print_generic ( genericj , line , istart , increment , sep_local ) msg_one = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 class ( * ), intent ( in ), optional :: generic (:) character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep integer :: i select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic #endif !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic type is ( logical ); write ( line ( istart :), '(\"[\",*(l1,1x))' ) generic type is ( character ( len =* )); write ( line ( istart :), '(\"[\",:*(\"\"\"\",a,\"\"\"\",:,1x))' ) ( trim ( generic ( i )), i = 1 , size ( generic )) type is ( complex ); write ( line ( istart :), '(\"[\",*(\"(\",1pg0,\",\",1pg0,\")\",1x))' ) generic class default !error_stop 'unknown type in *print_generic*' end select istart = len_trim ( line ) + increment + 1 line = trim ( line ) // ']' // sep_local end subroutine print_generic !=================================================================================================================================== end function msg_one !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fmt(3f) - [M_framework__msg] convert any intrinsic to a string using specified format !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function fmt(value,format) result(string) !! !!     class(*),intent(in),optional :: value !!     character(len=*),intent(in),optional :: format !!     character(len=:),allocatable :: string !!##DESCRIPTION !!    FMT(3f) converts any standard intrinsic value to a string using the specified !!    format. !!##OPTIONS !!    value    value to print the value of. May be of type INTEGER, LOGICAL, !!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER. !!    format   format to use to print value. It is up to the user to use an !!             appropriate format. The format does not require being !!             surrounded by parenthesis. If not present a default is selected !!             similar to what would be produced with free format, with !!             trailing zeros removed. !!##RETURNS !!    string   A string value !!##EXAMPLES !! !!   Sample program: !! !!     program demo_fmt !!     use :: M_framework__msg, only : fmt !!     implicit none !!     character(len=:),allocatable :: output !! !!        output=fmt(10,\"'[',i0,']'\") !!        write(*,*)'result is ',output !! !!        output=fmt(10.0/3.0,\"'[',g0.5,']'\") !!        write(*,*)'result is ',output !! !!        output=fmt(.true.,\"'The final answer is [',g0,']'\") !!        write(*,*)'result is ',output !! !!     end program demo_fmt !! !!   Results: !! !!     result is [10] !!     result is [3.3333] !!     result is The final answer is [T] !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain recursive function fmt ( generic , format ) result ( line ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 ! ident_4=\"@(#) M_framework__msg fmt(3f) convert any intrinsic to a string using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local character ( len = :), allocatable :: str_re , str_im integer :: iostat character ( len = 255 ) :: iomsg character ( len = 1 ), parameter :: nil = char ( 0 ) integer :: iilen logical :: trimit if ( present ( format )) then fmt_local = format trimit = . false . else fmt_local = '' trimit = . true . endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef FLOAT128 type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable iostat = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil #endif type is ( logical ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( character ( len =* )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil type is ( complex ); if ( trimit ) then str_re = fmt ( real ( generic )) ! nvfortran cannot yet do fmt(generic%re) str_im = fmt ( aimag ( generic )) ! nvfortran cannot yet do fmt(generic%im) call trimzeros_ ( str_re ) call trimzeros_ ( str_im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( str_re ), trim ( str_im ), nil trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , nil endif end select if ( iostat /= 0 ) then line = '<ERROR>' // trim ( iomsg ) else iilen = index ( line , nil , back = . true .) if ( iilen == 0 ) iilen = len ( line ) line = line (: iilen - 1 ) endif if ( index ( line , '.' ) /= 0 . and . trimit ) call trimzeros_ ( line ) end function fmt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    trimzeros_(3fp) - [M_framework__msg:TYPE] Delete trailing zeros from !!    numeric decimal string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine trimzeros_(str) !! !!     character(len=*)  :: str !! !!##DESCRIPTION !!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a !!    number. If the resulting string would end in a decimal point, one !!    trailing zero is added. !! !!##OPTIONS !!    str   input string will be assumed to be a numeric value and have !!          trailing zeros removed !!##EXAMPLES !! !!    Sample program: !! !!       program demo_trimzeros_ !!       !use M_framework__msg, only : trimzeros_ !!       character(len=:),allocatable :: string !!          string= '123.450000000000' !!          call trimzeros_(string) !!          write(*,*)string !!          string='12345' !!          call trimzeros_(string) !!          write(*,*)string !!          string='12345.' !!          call trimzeros_(string) !!          write(*,*)string !!          string='12345.00e3' !!          call trimzeros_(string) !!          write(*,*)string !!       end program demo_trimzeros_ !! !!   Results: !! !!     > 123.45 !!     > 12345 !!     > 12345 !!     > 12345e3 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine trimzeros_ ( string ) ! ident_5=\"@(#) M_framework__msg trimzeros_(3fp) Delete trailing zeros from numeric decimal string\" ! if zero needs added at end assumes input string has room character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: expnt ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found expnt = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ) == 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i <= 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select end do if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( expnt ) else string = str endif end subroutine trimzeros_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    stderr(3f) - [M_framework__msg] write message to stderr !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine stderr(msg,[generic(s)]) !! !!     class(*),intent(in),optional :: msg !!     class(*),intent(in),optional :: & !!                     & generic0,generic1,generic2,generic3,generic4 !!     class(*),intent(in),optional :: & !!                     & generic5,generic6,generic7,generic8,generic9 !!     class(*),intent(in),optional :: & !!                     & generica,genericb,genericc,genericd,generice !!     class(*),intent(in),optional :: & !!                     & genericf,genericg,generich,generici,genericj !!##DESCRIPTION !!    STDERR(3f) writes a message to standard error using a standard !!    f2003 method. Up to twenty generic options are available. !!##OPTIONS !!    msg           - description to print !!    generic[0-j]  - optional value to print the value of after the !!                    message. May be of type INTEGER, LOGICAL, REAL, !!                    DOUBLEPRECISION, COMPLEX, or CHARACTER. !!##EXAMPLES !! !!   Sample program: !! !!    program demo_stderr !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32 !!    use M_framework__msg, only: stderr !!    implicit none !! !!    call stderr('A simple message') !!    call stderr('error: RVALUE=',3.0/4.0) !!    call stderr('error: IVALUE=',123456789) !!    call stderr('error: LVALUE=',.true.) !! !!    SEVERAL: block !!    integer :: least=10, most=999, ival=-10 !!    call stderr('error: value',ival, & !!            & 'should be between',least,'and',most) !!    endblock SEVERAL !! !!    call stderr('real32  :',huge(0.0_real32),0.0_real32, & !!            & 12345.6789_real32,tiny(0.0_real32)) !!    call stderr('real64  :',huge(0.0_real64),0.0_real64, & !!            & 12345.6789_real64,tiny(0.0_real64)) !!    !#ifdef __NVCOMPILER !!    !#else !!    call stderr('real128 :',huge(0.0_real128),0.0_real128, & !!            & 12345.6789_real128,tiny(0.0_real128)) !!    !#endif !!    call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real))) !! !!    call stderr('error: program will now stop') !!    stop 1 !! !!    end program demo_stderr !! !!   Results: !!     A simple message !!     error: RVALUE= 0.750000000 !!     error: IVALUE= 123456789 !!     error: LVALUE= T !!     error: value -10 should be between 10 and 999 !!     real32  : 3.40282347E+38 ... !!               0.00000000 ... !!               12345.6787 ... !!               1.17549435E-38 !!     real64  : 1.7976931348623157E+308 ... !!               0.0000000000000000 ... !!               12345.678900000001 ... !!               2.2250738585072014E-308 !!     real128 : 1.18973149535723176508575932662800702E+4932 ... !!               0.00000000000000000000000000000000000  ... !!               12345.6789000000000000000000000000002 ... !!               3.36210314311209350626267781732175260E-4932 !!     complex : (3.40282347E+38,1.17549435E-38) !!     error: program will now stop !!     STOP 1 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine stderr ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_6=\"@(#) M_framework__msg stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    wrt(3f) - [M_framework__msg] write multiple scalar values to any !!    number of files !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine wrt(luns,generic(s),iostat) !! !!     integer,intent(in)           :: luns(:) !!     class(*),intent(in),optional :: & !!                     & generic0,generic1,generic2,generic3,generic4 !!     class(*),intent(in),optional :: & !!                     & generic5,generic6,generic7,generic8,generic9 !!     class(*),intent(in),optional :: & !!                     & generica,genericb,genericc,genericd,generice !!     class(*),intent(in),optional :: & !!                     & genericf,genericg,generich,generici,genericj !!     integer,intent(out),optional :: iostat !!     character(len=*),intent(in)  :: types(*) !!##DESCRIPTION !!    WRT(3f) writes a list of scalar values  to the list of unit numbers !!    in LUNS(:). !!##OPTIONS !!    LUNS            Unit numbers to write to. If of size zero no output !!                    is generated !!    generic[1-20]   optional value to print the value of after the !!                    message. May be of type INTEGER, LOGICAL, REAL, !!                    DOUBLEPRECISION, COMPLEX, or CHARACTER. !!    TYPES           one for each lun. '' for ASCII, 'CSV' for !!                    comma-separated. !!##RETURNS !!    IOSTAT          The value of the last non-zero IOSTAT value. Returns !!                    zero if no errors occurred. !!##EXAMPLES !! !!   Sample program: !! !!    program demo_wrt !!    use, intrinsic :: iso_fortran_env, only : & !!     & stdin=>input_unit, & !!     & stdout=>output_unit, & !!     & stderr=>error_unit !!    use M_framework__msg, only: wrt, fmt !!    implicit none !!    integer,allocatable :: luns(:) !!    integer :: iostat=0 !!    integer,parameter :: ints(3)=[1,2,3] !! !!    ! a null list allows for turning off verbose or debug mode output !!    luns=[integer ::] !!    call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat) !!    write(*,*)'IOSTAT=',iostat !! !!    ! multiple files can be used to create a log file, for example !!    luns=[stderr,stdout] !!    call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat) !!    write(*,*)'IOSTAT=',iostat !! !!    ! using fmt !!    call wrt([stdout,stdout,stdout],'USING FMT :', & !!     & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat) !! !! !!    end program demo_wrt !! !!##TWO FILES: 2147483647 PI= 3.1415926535897931 !!##TWO FILES: 2147483647 PI= 3.1415926535897931 !!  IOSTAT=           0 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!  IOSTAT=           0 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine wrt ( luns , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , iostat ) implicit none ! ident_7=\"@(#) M_framework__msg write(3f) writes a message to any number of open files with any scalar values\" integer , intent ( in ) :: luns (:) class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer , intent ( out ), optional :: iostat integer :: i integer :: ios , ios2 character ( len = 256 ) :: msg ios2 = 0 do i = 1 , size ( luns ) write ( luns ( i ), '(a)' , iostat = ios , iomsg = msg ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if ( ios /= 0 ) then ios2 = ios call stderr ( '<ERROR>*write*:' , msg ) if (. not . present ( iostat )) stop 1 endif enddo if ( present ( iostat )) iostat = ios2 end subroutine wrt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    set(3f) - [M_msg] set scalars from an array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, & !!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk) !!      class(*),intent(in)           :: g0 !!      class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga !!      class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk !! !!##DESCRIPTION !!    set(3f) sets up to twenty scalars to elements from an array. !! !!##OPTIONS !!    g0(:)       array to read values from. Can be of type INTEGER or REAL !!    g[1-9a-k]   optional values to set to an array element. Can !!                be of type INTEGER or REAL !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_set !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    use M_framework__msg, only : set !!    implicit none !!    real(kind=real32)    :: a; namelist /all/a !!    real(kind=real64)    :: b; namelist /all/b !!    real(kind=real128)   :: c; namelist /all/c !!    integer(kind=int8)   :: i; namelist /all/i !!    integer(kind=int16)  :: j; namelist /all/j !!    integer(kind=int32)  :: k; namelist /all/k !!    integer(kind=int64)  :: l; namelist /all/l !!       call set([1,2,3,4,5,6,7],a,b,c,i,j,k,l) !!       write(*,nml=all) !!       call set(10,a) !!       call set(100,l) !!       write(*,nml=all) !!    end program demo_set !! !!   Results: !! !!     &ALL !!     A       =   1.000000    , !!     B       =   2.00000000000000     , !!     C       =   3.00000000000000000000000000000000      , !!     I       =    4, !!     J       =      5, !!     K       =           6, !!     L       =                     7 !!     / !!     &ALL !!     A       =   10.00000    , !!     B       =   2.00000000000000     , !!     C       =   3.00000000000000000000000000000000      , !!     I       =    4, !!     J       =      5, !!     K       =           6, !!     L       =                   100 !!     / !! !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine set_single ( generic0 , generic1 ) implicit none class ( * ), intent ( in ) :: generic0 class ( * ), intent ( out ) :: generic1 call set_generic ( generic1 ) contains subroutine set_generic ( gen ) class ( * ), intent ( out ) :: gen select type ( generic0 ) type is ( integer ( kind = int8 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int16 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( real ( kind = real32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( real ( kind = real64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select #ifdef FLOAT128 type is ( real ( kind = real128 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 #endif end select #endif end select end subroutine set_generic end subroutine set_single subroutine set_scalar ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , & & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj , generick ) implicit none ! ident_7=\"@(#)M_framework__msg::set_scalar(3fp): set scalars from array elements\" class ( * ), intent ( in ) :: generic0 (:) class ( * ), intent ( out ), optional :: generic1 , generic2 , generic3 , generic4 class ( * ), intent ( out ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 class ( * ), intent ( out ), optional :: generica , genericb , genericc , genericd , generice class ( * ), intent ( out ), optional :: genericf , genericg , generich , generici , genericj class ( * ), intent ( out ), optional :: generick if ( present ( generic1 )) call set_generic ( generic1 , 1 ) if ( present ( generic2 )) call set_generic ( generic2 , 2 ) if ( present ( generic3 )) call set_generic ( generic3 , 3 ) if ( present ( generic4 )) call set_generic ( generic4 , 4 ) if ( present ( generic5 )) call set_generic ( generic5 , 5 ) if ( present ( generic6 )) call set_generic ( generic6 , 6 ) if ( present ( generic7 )) call set_generic ( generic7 , 7 ) if ( present ( generic8 )) call set_generic ( generic8 , 8 ) if ( present ( generic9 )) call set_generic ( generic9 , 9 ) if ( present ( generica )) call set_generic ( generica , 10 ) if ( present ( genericb )) call set_generic ( genericb , 11 ) if ( present ( genericc )) call set_generic ( genericc , 12 ) if ( present ( genericd )) call set_generic ( genericd , 13 ) if ( present ( generice )) call set_generic ( generice , 14 ) if ( present ( genericf )) call set_generic ( genericf , 15 ) if ( present ( genericg )) call set_generic ( genericg , 16 ) if ( present ( generich )) call set_generic ( generich , 17 ) if ( present ( generici )) call set_generic ( generici , 18 ) if ( present ( genericj )) call set_generic ( genericj , 19 ) if ( present ( generick )) call set_generic ( generick , 20 ) contains !=================================================================================================================================== subroutine set_generic ( gen , i ) class ( * ), intent ( out ) :: gen integer , intent ( in ) :: i if ( size ( generic0 ) < i ) then write ( ERROR_UNIT , '()' ) '<ERROR> i=' , i , ' is out of bounds (<' , size ( generic0 ), ')' stop 1 endif select type ( generic0 ) type is ( integer ( kind = int8 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int16 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( real ( kind = real32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( real ( kind = real64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select #ifdef FLOAT128 type is ( real ( kind = real128 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef FLOAT128 type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select #endif end select end subroutine set_generic !=================================================================================================================================== end subroutine set_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      pdec(3f) - [M_framework__msg] write out string with ASCII decimal !!      equivalent vertically under it !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    Usage: !! !!     subroutine pdec(string) !!     character(len=*),intent(in) :: string !! !!##DESCRIPTION !! !!    Given a string to print, PDEC() writes out the ASCII Decimal equivalent !!    of the string directly underneath it. This can help you to locate !!    unprintable characters or non-standard white-space such as a backspace !!    character or tab character in input strings that your program could !!    not interpret. On output, non-printable characters are replaced with !!    a space, and trailing spaces are ignored. !! !!    You read the numbers vertically. !! !!    1. ignore trailing spaces !!    2. print the character if it has an ADE of 32 on up !!    3. print a space if it has an ADE of less than 32 !!    4. underneath each character print the ADE value vertically !! !!##EXAMPLES !! !! !!    Sample program: !! !!       program demo_pdec !!       use M_framework__msg, only : pdec !!       call pdec(' ABCDEFG abcdefg    ') !!       end program demo_pdec !! !!    would produce (notice trailing space is trimmed): !! !!      > ABCDEFG abcdefg !!      >0000000000001111 !!      >3666667739990000 !!      >2567890127890123 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine pdec ( string ) ! ident_8=\"@(#) M_framework__msg pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string\" character ( len =* ), intent ( in ) :: string ! the string to print integer :: iilen ! number of characters in string to print integer :: i ! counter used to step thru string iilen = len_trim ( string (: len ( string ))) ! get trimmed length of input string write ( * , 101 )( char ( max ( 32 , ichar ( string ( i : i )))), i = 1 , iilen ) ! replace lower unprintable characters with spaces ! print ADE value of character underneath it write ( * , 202 ) ( ichar ( string ( i : i )) / 100 , i = 1 , iilen ) write ( * , 202 )( mod ( ichar ( string ( i : i )), 100 ) / 10 , i = 1 , iilen ) write ( * , 202 )( mod (( ichar ( string ( i : i ))), 10 ), i = 1 , iilen ) ! strings are assumed under 32767+1 characters in length because format integer constants > 32767+1 are not supported on HP-UX ! when newer compilers are available use unlimited !101   format(32767a1:)  ! format for printing string characters !202   format(32767i1:)  ! format for printing ADE values 101 format ( * ( a1 :)) ! format for printing string characters 202 format ( * ( i1 :)) ! format for printing ADE values end subroutine pdec !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    assert(3f) - [M_framework__msg] print filename, linenumber, and !!    message to stderr and stop program !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function assert(file,linenum,expr,g1,g2,g3,g4,g5,g6,g7,g8,g9, & !!                    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj) !! !!     character(len=*),intent(in)  :: file !!     character(len=*),intent(in)  :: linenum !!     logical,intent(in)           :: expr !!     class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !!     class(*),intent(in),optional :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!##DESCRIPTION !!    assert(3f) prints strings to stderr and then stops program with exit !!    code 1 It labels the first string as the filename, the next integer !!    parameter as the linenumber, and then up to twenty scalar values. !! !!    It is primarily intended for use by the prep(1) preprocessor $ASSERT !!    directive !! !!##OPTIONS !! !!    filename   a string assumed to be the current filename when compiling !!    linenum    assumed to be the line number of the source code the ASSERT(3f) !!               procedure was called at. !!    expr       logical value !!    g[1-9a-j]  optional value(s) to print as a message before stopping. May !!               be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!               or CHARACTER. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_assert !!    use M_framework__msg, only : assert !!    implicit none !!    real :: a, toobig=1024 !!    a=2000 !!    call assert('myroutine', 101, a > toobig, & !!            & 'The value is too large', a, ' > ', toobig) !!    end program demo_assert !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine assert ( filename , linen , expr , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_9=\"@(#) M_framework__msg assert(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: linen logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ! write message to standard error if (. not . expr ) then call stderr ( 'ERROR:filename:' , filename , ':line number:' , linen , ':' , & & str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) ) stop 1 endif end subroutine assert !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_framework__msg","tags":"","url":"sourcefile/m_framework__msg.f90.html"},{"title":"demo_unit_test_start.f90 – M_framework","text":"Source Code program demo_unit_test_start use M_framework , only : unit_test_start , unit_test , & & unit_test_end , unit_test_mode , unit_test_stop implicit none integer :: ival logical :: matched call unit_test_mode () call test_mysub1 () call test_mysub2 () call unit_test_stop () contains subroutine test_mysub1 () ! first test call unit_test_start ( 'mysub1' ) ! the example goodbad(1) command called here takes many options ! used to build an SQLite3 entry ival = 10 call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub1\"' ) end subroutine test_mysub1 subroutine test_mysub2 () ! second test call unit_test_start ( 'mysub1' , '' , matched = matched ) ival = 200 if (. not . matched ) return ! makes it skippable call unit_test ( 'mysub1' , ival > 3 , msg = ' if big enough' ) call unit_test ( 'mysub1' , ival < 100 , msg = ' if small enough' ) call unit_test_end ( 'mysub1' , msg = 'completed checks of \"mysub2\"' ) end subroutine test_mysub2 end program demo_unit_test_start","tags":"","url":"sourcefile/demo_unit_test_start.f90.html"},{"title":"demo_wrt.f90 – M_framework","text":"Source Code program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_framework__msg , only : wrt , fmt implicit none integer , allocatable :: luns (:) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , 'NULL LIST:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! multiple files can be used to create a log file, for example luns = [ stderr , stdout ] call wrt ( luns , 'TWO FILES:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], 'USING FMT :' , & & huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , fmt ( ints ( 2 ), 'i0.4' ), iostat = iostat ) end program demo_wrt","tags":"","url":"sourcefile/demo_wrt.f90.html"},{"title":"demo_unit_test_expected.f90 – M_framework","text":"Source Code program demo_unit_test_expected use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit use M_framework , only : & & unit_test_mode , & & start => unit_test_start , & & expected => unit_test_expected , & & stop => unit_test_stop , & & unit_test_level ! , unit_test_flags implicit none logical , parameter :: T = . true ., F = . false . ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stderr ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 ! unit tests for ABS(3f) intrinsic call start ( 'abs' ) ! integer call expected ( 'abs' , abs ( - 10 ), 10 ) call expected ( 'abs' , abs ( 10 ), 10 ) ! real and elemental call expected ( 'abs' , abs ( [ - 1 0.0 , 1 0.0 ]), 1 0.0 ) ! complex call expected ( 'abs' , abs (( 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , 4.0 )), 5.0 ) call expected ( 'abs' , abs (( - 3.0 , - 4.0 )), 5.0 ) call expected ( 'abs' , abs (( 3.0 , 4.0 )), 5.0 ) call stop ( 'abs' ) end program demo_unit_test_expected","tags":"","url":"sourcefile/demo_unit_test_expected.f90.html"},{"title":"test_suite_M_framework__msg.f90 – M_framework","text":"Source Code program runtest use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_framework , only : unit_test_start , unit_test , unit_test_msg use M_framework , only : unit_test_end , unit_test_stop , unit_test_mode use M_framework , only : unit_test_level ! unit_test_flags use M_framework , only : str !use M_xxxx implicit none logical , parameter :: T = . true ., F = . false . logical :: matched ! optional call to change default modes call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stderr ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 call test_suite_str () call test_suite_stderr () call test_suite_wrt () call test_suite_fmt () call test_suite_set () call test_suite_pdec () call test_suite_assert () call unit_test_stop ( 'M_framework_msg' ) contains subroutine test_suite_str () logical , allocatable :: tests (:) call unit_test_start ( 'str' , 'test building message strings' , matched = matched ) if (. not . matched ) return tests = [ logical :: ] call add ( 'INTEGER' , str ( 10 ), '10' , '10' ) call add ( 'LOGICAL' , str (. false .), 'F' , 'F' ) call add ( 'LOGICAL' , str (. true .), 'T' , 'T' ) call add ( 'REAL' , str ( 10 0.0 ), '100.000000' , '100.0000' ) call add ( 'COMPLEX' , str (( 1 1.0 , 2 2.0 )), '(11.0000000,22.0000000)' , '(11.00000,22.00000)' ) call add ( 'COMPOUND' , str ( 10 , 10 0.0 , \"string\" ,( 1 1.0 , 2 2.0 ),. false .), & & '10 100.000000 string (11.0000000,22.0000000) F' ,& & '10 100.0000 string (11.00000,22.00000) F' ) call unit_test_msg ( 'str' , 'tally is ' , str ( tests ) // '' ) ! //'' for gfortran-11 bug call unit_test_end ( \"str   \" , msg = \"\" ) end subroutine test_suite_str subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if ( passed ) then call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer , 'got' , question ) else passed = question . eq . answer2 call unit_test ( 'str' , passed , 'testing' , message , 'expected' , answer2 , 'got' , question ) endif end subroutine add subroutine test_suite_stderr () call unit_test_start ( \"stderr\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"stderr\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"stderr\" , msg = \"\" ) end subroutine test_suite_stderr subroutine test_suite_wrt () call unit_test_start ( \"wrt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"wrt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"wrt\" , msg = \"\" ) end subroutine test_suite_wrt subroutine test_suite_fmt () call unit_test_start ( \"fmt\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"fmt   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"fmt\" , msg = \"\" ) end subroutine test_suite_fmt subroutine test_suite_set () call unit_test_start ( \"set\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"set   \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"set\" , msg = \"\" ) end subroutine test_suite_set subroutine test_suite_pdec () call unit_test_start ( \"pdec\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"pdec  \", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"pdec\" , msg = \"\" ) end subroutine test_suite_pdec subroutine test_suite_assert () call unit_test_start ( \"assert\" , msg = \"\" , matched = matched ) if (. not . matched ) return !!call unit_test(\"assert\", 0 .eq. 0, \"checking\",100) call unit_test_end ( \"assert\" , msg = \"\" ) end subroutine test_suite_assert end program runtest","tags":"","url":"sourcefile/test_suite_m_framework__msg.f90.html"},{"title":"tryitagain.f90 – M_framework","text":"Source Code program M_test_suite_M_steam67 use M_framework , only : unit_test_start , unit_test , unit_test_done , & unit_test_mode , unit_test_stop !  unit_test_level !use M_steam67 implicit none double precision , allocatable :: expected (:), answers (:), input (:) call test_sqrt () call test_cos () call test_sin () call unit_test_stop () contains subroutine test_sqrt () integer :: i call unit_test_mode ( luns = [ 0 , 10 ]) call unit_test_start ( 'sqrt' , msg = '' ) call unit_test_mode ( luns = [ 0 , 10 ]) input = [ 1.0d0 , 4.0d0 , 9.0d0 ] expected = [ 1.0d0 , 2.0d0 , 3.0d0 ] answers = [( sqrt ( input ( i )), i = 1 , size ( input ))] call unit_test ( 'sqrt' , & all ( expected . eq . answers ), & 'check table of values' ) call unit_test ( 'sqrt' , & sqrt ( 2 5.0d0 ). eq . 5.0d0 , & 'got' , sqrt ( 2 5.0d0 ), 'expected' , 5.0d0 ) call unit_test_done ( 'sqrt' , msg = '' ) end subroutine test_sqrt subroutine test_sin () call unit_test_start ( 'sin' , msg = '' ) call unit_test_done ( 'sin' , msg = '' ) end subroutine test_sin subroutine test_cos () call unit_test_start ( 'cos' , msg = '' ) call unit_test_done ( 'cos' , msg = '' ) end subroutine test_cos end program M_test_suite_M_steam67","tags":"","url":"sourcefile/tryitagain.f90.html"},{"title":"demo_unit_test.f90 – M_framework","text":"Source Code program demo_unit_test use M_framework , only : & & unit_test_mode , & & unit_test_start , & & unit_test , & & unit_test_end , & & unit_test_stop use M_framework , only : almost implicit none integer :: i integer :: x integer , allocatable :: arr (:) real , allocatable :: arr1 (:) real , allocatable :: arr2 (:) call unit_test_mode ( keep_going = . true ., debug = . false ., command = '' ) x = 10 arr1 = [ 1.0 , 1 0.0 , 10 0.0 ] arr2 = [ 1.0001 , 1 0.001 , 10 0.01 ] call unit_test_start ( 'myroutine' ) call unit_test ( 'myroutine' , x > 3 , ' if big enough' ) call unit_test ( 'myroutine' , x < 100 , ' if small enough' ) do i = 1 , size ( arr1 ) call unit_test ( 'myroutine' , & & almost ( arr1 ( i ), arr2 ( i ), 3.9 , verbose = . true .) ) enddo arr = [ 10 , 20 , 30 ] call unit_test ( 'myroutine' , . not . any ( arr < 0 ) , & & 'fail if any negative values in array ARR' ) call unit_test ( 'myroutine' , all ( arr < 100 ) , & & 'fail unless all values are less than 100 in array ARR' ) call unit_test_end ( 'myroutine' , & & msg = 'checks on \"myroutine\" all passed' ) call unit_test_stop () end program demo_unit_test","tags":"","url":"sourcefile/demo_unit_test.f90.html"},{"title":"demo_accdig.f90 – M_framework","text":"Source Code program demo_accdig ! fortran 90 example use M_framework__approx , only : accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1.234680d0 , 1.2345378d0 , 2.2234568d0 , 1.2345678d0 , & & 1.2345679d0 , - 1.2345678d0 , 7 6.234567d0 , 2.4691356d0 , & & 0.0d0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i10 ) call accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0d0 b = a + 1.0d0 / ( 1 0.0d0 ** i20 ) call accdig ( a , b , dble ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call accdig ( 1.2345678d0 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ), 1.2345678d0 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig","tags":"","url":"sourcefile/demo_accdig.f90.html"},{"title":"bookkeeper.f90 – M_framework","text":"Source Code program bookkeeper ! example program that can parse arguments given to optional unit_test command !  o writing a CSV file to be read into spread sheets, SQLite3, .... !  o writing a HTML document !  o writing a NAMELIST group file for post-processing into formats like a TAP (Test Anything Protocol) document use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_framework , only : wrt , str ! put something here into namelist and it becomes an argument character ( len = :), allocatable :: type ; namelist / args / type , / long / type character ( len = :), allocatable :: name ; namelist / args / name , / long / name character ( len = :), allocatable :: passed ; namelist / args / passed , / long / passed character ( len = :), allocatable :: msg ; namelist / args / msg , / long / msg character ( len = 25 ) :: date ; namelist / args / date , / long / date integer ( kind = int64 ) :: clicks ; namelist / args / clicks , / long / clicks logical :: help ; namelist / long / help logical :: version ; namelist / long / version logical :: verbose ; namelist / long / verbose !integer                      :: level = -1         ; namelist /args/ level !integer,allocatable          :: flags(:)           ; namelist /args/ flags character ( len = :), allocatable :: html_header (:), html_footer (:) character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: g0 = '(*(g0))' character ( len = 1 ), parameter :: comma = ',' , quote = '\"' character ( len = :), allocatable :: color logical :: intable = . true . integer :: i integer :: htmlfile , csvfile , clicksfile , nmlfile interface exists ! for backward compatibility, accdig(3f) preferred procedure fileexists procedure unitexists end interface exists !SETUP ! This is an example program. A simple kludge is to pick scratch output or file output ! to work with just one output. Not something to do in production code. open ( newunit = htmlfile , file = 'bookkeeper.html' , position = 'append' ) !open(newunit=htmlfile,position='append',status='scratch') open ( newunit = csvfile , file = 'bookkeeper.csv' , position = 'append' , DELIM = 'quote' , form = 'formatted' ) !open(newunit=csvfile,position='append',DELIM='quote',form='formatted',status='scratch') open ( newunit = clicksfile , file = 'bookkeeper_clicks.csv' , position = 'append' ) !open(newunit=clicksfile,position='append',status='scratch') open ( newunit = nmlfile , file = 'bookkeeper.nml' , position = 'append' ) !open(newunit=nmlfile,position='append',status='scratch') call header () verbose = . false . type = repeat ( ' ' , 4096 ) name = repeat ( ' ' , 4096 ) passed = repeat ( ' ' , 4096 ) msg = repeat ( ' ' , 4096 ) !intable=.false. date = here_and_now () clicks =- 1 !   flags = [(-1, i=1, 1000)] !PARSE call cmdline_ () !TEARDOWN type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) !   flags = pack(flags, flags  /=  -1) !USE write ( nmlfile , nml = args ) ! cannot do advance='no' select case ( passed ) case ( \"untested\" ); color = 'yellow' case ( \"passed\" ) ; color = '#9F9' case ( \"failed\" ) ; color = 'red' case default ; color = 'white' end select select case ( type ) case ( \"start\" ) !intable=.true. write ( htmlfile , g0 ) '<table id=\"' , name , '\">' write ( htmlfile , g0 ) '<caption class=\"caption\" style=\"text-align:left\">' , name , str ( ' -' , if = msg . ne . '' ), ' ' , msg , '</caption>' write ( htmlfile , g0 ) '<tbody>' write ( htmlfile , g0 ) '<tr class=\"header\" class=\"odd\"><!-- start -->' write ( htmlfile , g0 ) ' <th style=\"width:25%;text-align:center;\"> name   </th>' write ( htmlfile , g0 ) ' <th style=\"width:10%;text-align:center;\"> passed </th>' write ( htmlfile , g0 ) ' <th style=\"width:40%;text-align:center;\"> msg    </th>' write ( htmlfile , g0 ) ' <th style=\"width:25%;text-align:center;\"> date   </th>' write ( htmlfile , g0 ) '</tr>' case ( \"check\" ) write ( csvfile , g0 ) quote , name , quote , comma , quote , here_and_now (), quote , comma , quote , passed , quote , comma , quote , msg , quote write ( htmlfile , g0 ) '<tr class=\"' , passed , '\" class=\"even\"><!-- check -->' write ( htmlfile , g0 ) ' <td >' , name , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\" bgcolor=\"' , color , '\">' , passed , ' </td>' write ( htmlfile , g0 ) ' <td >' , msg , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\">' , date , ' </td>' write ( htmlfile , g0 ) '</tr>' case ( \"message\" ) if ( intable ) then write ( htmlfile , g0 ) '<tr class=\"message\"><!-- message -->' write ( htmlfile , g0 ) '<td colspan=\"4\" bgcolor=\"#AAF\" style=\"text-align:center;\">' , msg , '</td>' write ( htmlfile , g0 ) '</tr>' else !write(htmlfile,g0)msg endif case ( \"end\" ) !intable=.false. if ( passed . eq . 'untested' ) then write ( csvfile , g0 ) quote , name , quote , comma , quote , here_and_now (), quote , comma , quote , passed , quote , comma , quote , msg , quote write ( htmlfile , g0 ) '<tr class=\"' , passed , '\" class=\"odd\"><!-- end -->' write ( htmlfile , g0 ) ' <td >' , name , ' </td>' write ( htmlfile , g0 ) ' <td bgcolor=\"' , color , '\" style=\"text-align:center;\">' , passed , ' </td>' write ( htmlfile , g0 ) ' <td >' , msg , ' </td>' write ( htmlfile , g0 ) ' <td style=\"text-align:center;\">' , date , ' </td>' write ( htmlfile , g0 ) '</tr>' endif if ( clicks . ne . 0 ) then write ( htmlfile , g0 ) '<tr class=\"clicks\" class=\"' , passed , '\"><!-- clicks -->' write ( htmlfile , g0 ) '<td colspan=\"4\" bgcolor=\"#AAF\" style=\"text-align:center;\"> clicks:' , clicks , ' for ' , name , '</td>' write ( htmlfile , g0 ) '</tr>' endif write ( htmlfile , g0 ) '</table>' write ( clicksfile , g0 ) quote , name , quote , comma , & quote , here_and_now (), quote , comma , & quote , clicks , quote , comma , & quote , msg , quote case ( \"stop\" ) !intable=.false. write ( htmlfile , g0 ) '<!-- STOP -->' end select contains subroutine cmdline_ () ! read arguments from command line as NAMELIST group input character ( len = 4096 ), save :: input ( 3 ) = [ character ( len = 4096 ) :: '&long' , '' , ' /' ], arg character ( len = 256 ) :: message1 , message2 integer :: i , j , ios , equal_pos , iend help = . false . version = . false . do i = 1 , command_argument_count () call get_command_argument ( i , arg ) do j = 1 , len_trim ( arg ) ! blank out leading - or / so \"--name=value\" or \"/name=value\" works if ( index ( '/- ' , arg ( j : j )) == 0 ) exit arg ( j : j ) = ' ' enddo arg = ' ' // adjustl ( arg ) if ( index ( arg , '=' ) == 0 ) arg = trim ( arg ) // '=T' ! if no equal sign add =T iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message1 ) if ( ios /= 0 ) then ! assume first failure might be because of missing quotes equal_pos = index ( arg , '=' ) ! find position of '=' if ( equal_pos /= 0 ) then ! requote and try again arg = arg (: equal_pos ) // '\"' // arg ( equal_pos + 1 : len_trim ( arg )) // '\"' iend = len_trim ( arg ) input ( 2 ) = arg if ( arg ( iend : iend ). ne . ',' ) input ( 2 ) = input ( 2 ) // ' ,' read ( input , nml = long , iostat = ios , iomsg = message2 ) if ( ios /= 0 ) then write ( stderr , g ) 'BOOKKEEPER:ERROR UNQUOTED:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) if ( message1 . ne . message2 ) write ( stderr , g ) 'BOOKKEEPER:ERROR QUOTED  :' , trim ( message2 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( * , nml = long , delim = 'quote' ) stop 2 endif else write ( stderr , g ) 'ERROR:' , trim ( message1 ), ': when reading ' , trim ( input ( 2 )) type = trim ( type ) name = trim ( name ) passed = trim ( passed ) msg = trim ( msg ) write ( stderr , nml = long , delim = 'quote' ) stop 4 endif endif enddo if ( help ) call printhelp () if ( version ) call printversion () end subroutine cmdline_ subroutine printhelp () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& 'NAME                                                                            ' ,& '    bookkeeper-(1f) - example filter program callable from the M_framework(3f)  ' ,& '    unit testing harness.                                                       ' ,& '    (LICENSE:PD)                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' commands:                                                                      ' ,& '                                                                                ' ,& '     bookkeeper [help| version]                                                 ' ,& '     bookkeeper type=\"start\" name=\"NAME\" msg=\"MESSAGE TEXT\" [opts]              ' ,& '     bookkeeper type=\"check\" name=\"NAME\" msg=\"MESSAGE TEXT\" ...                 ' ,& '                passed=\"passed|failed\"                                          ' ,& '     bookkeeper type=\"end\" name=\"NAME\" msg=\"MESSAGE TEXT\" clicks=N ...          ' ,& '                [passed=\"failed|passed|untested\"]                               ' ,& '     bookkeeper type=\"stop\" name=\"NAME\" msg=\"MESSAGE TEXT\"                      ' ,& '                [passed=\"failed|passed|untested\"] clicks=M                      ' ,& '     bookkeeper type=\"message\" name=\"NAME\" msg=\"MESSAGE TEXT\"                   ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& ' This is an example program that shows how to create an external program that   ' ,& ' can be called by the testing harness in the M_framework__verify(3f) module     ' ,& ' for custom processing. Data is based in the form of NAMELIST group data        ' ,& ' for the NAMELIST group                                                         ' ,& '                                                                                ' ,& '     character(len=:),allocatable :: type                                       ' ,& '     character(len=:),allocatable :: name                                       ' ,& '     character(len=:),allocatable :: passed                                     ' ,& '     character(len=:),allocatable :: msg                                        ' ,& '     character(len=25)            :: date                                       ' ,& '     integer(kind=int64)          :: clicks                                     ' ,& '     logical                      :: help                                       ' ,& '     logical                      :: version                                    ' ,& '                                                                                ' ,& ' The data conforms to the Fortran NAMELIST group input syntax with the          ' ,& ' delimiter set to a double-quote except extraneous spaces are not allowed,      ' ,& ' and names may optionally be preceded by \" --\" or \" /\" and if no equal          ' ,& ' appears after a keyword \"=T\" is assumed to appear more like typical            ' ,& ' Unix long options or MSWindows commands. So these would all be                 ' ,& ' equivalent:                                                                    ' ,& '                                                                                ' ,& '      bookkeeper type=\"end\" msg=\"message text\"                                  ' ,& '      bookkeeper /type=\"end\" /msg=\"message text\"                                ' ,& '      bookkeeper --type=\"end\" --msg=\"message text\"                              ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    type     \"start\",\"check\",\"end\",\"stop\",\"message\"                             ' ,& '    name     a label, typically the name of the procedure that was tested.      ' ,& '    passed   \"passed\",\"failed\",\"untested\"                                       ' ,& '    msg      a description of the test, or a descriptive message                ' ,& '    date     YYYY-MM-DDTHH:MM:SS-HH:MM                                          ' ,& '    clicks   for type=\"end\" assumed to be the time in clicks since the          ' ,& '             previous type=\"start\"                                              ' ,& '    silent|brief|verbose   silent produces no output from unit_check_* routines ' ,& '                           brief only shows failed tests, verbose shows all     ' ,& '                           messages including compiler and options.             ' ,& '    help     display this help and exit                                         ' ,& '    version  output version information and exit                                ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '    Sample commands                                                             ' ,& '                                                                                ' ,& '       fpm test -- command=bookkeeper                                           ' ,& '       fpm test --target=''time*'' -- command=bookkeeper luns=6                   ' ,& '                                                                                ' ,& '                                                                                ' ,& 'SEE ALSO                                                                        ' ,& '    M_framework(3f), unit_test(3f), unit_test_mode(3f)                          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printhelp subroutine printversion () implicit none character ( len =* ), parameter :: ident = \"@(#)printhelp(3f): prints help information\" character ( len = :), allocatable :: help_text (:) integer :: i help_text = [ CHARACTER ( LEN = 128 ) :: & !12345678901234567890123456789012345678901234567890123456789012345678901234567890',& '                                                                                ' ,& 'PRODUCT:        Fortran Unit Testing Harness                                    ' ,& 'PROGRAM:        bookkeeper(1)                                                   ' ,& 'DESCRIPTION:    filter data from M_framework(3f) Unit Testing Framework         ' ,& 'VERSION:        1.0, 20230507                                                   ' ,& 'AUTHOR:         John S. Urban                                                   ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                            ' ,& 'HOME PAGE:      https://github.com/urbanjost/M_framework                        ' ,& 'LICENSE:        Public Domain. This is free software: you are free to change    ' ,& '                and redistribute it. There is NO WARRANTY,                      ' ,& '                to the extent permitted by law.                                 ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop end subroutine printversion function here_and_now () ! 2023-05-01 23:05:12 UTC-0400 character :: date * ( 8 ), time * ( 10 ), zone * ( 5 ) character ( len = 25 ) :: here_and_now call date_and_time ( DATE = date , TIME = time , ZONE = zone ) !write(here_and_now,'(*(g0))')date(1:4),'-',date(5:6),'-',date(7:8),' ',time(1:2),':',time(3:4),':',time(5:6),' UTC',zone ! rfc-3339\"   ==> %Y-%M-%DT%h:%m:%s%z  2023-05-02T18:40:25-04:00; except ZONE is in write ( here_and_now , '(*(g0))' )& & date ( 1 : 4 ), '-' , date ( 5 : 6 ), '-' , date ( 7 : 8 ), 'T' , time ( 1 : 2 ), ':' , time ( 3 : 4 ), ':' , time ( 5 : 6 ), zone ( 1 : 3 ), ':' , zone ( 4 : 5 ) end function here_and_now logical function fileexists ( filename ) result ( r ) character ( len =* ), intent ( in ) :: filename integer :: size inquire ( file = filename , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function fileexists logical function unitexists ( lun ) result ( r ) integer , intent ( in ) :: lun integer :: size inquire ( unit = lun , exist = r , size = size ) if ( r ) then if ( size . le . 0 ) r = . false . endif end function unitexists subroutine header () if ( . not . exists ( 'bookkeeper.csv' ) ) then write ( csvfile , g0 ) '\"name\",\"date\",\"passed\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.html' ) ) then call get_html_header () write ( htmlfile , '(a)' )( trim ( html_header ( i )), i = 1 , size ( html_header )) endif if ( . not . exists ( 'bookkeeper_clicks.csv' ) ) then write ( clicksfile , g0 ) '\"name\",\"date\",\"clicks\",\"msg\"' endif if ( . not . exists ( 'bookkeeper.nml' ) ) then write ( nmlfile , g0 ) ' Fortran NAMELIST group file containing test results' write ( nmlfile , g0 ) ' that may be read with a simple program and used to' write ( nmlfile , g0 ) ' generate reports in other formats.' write ( nmlfile , g0 ) ' ' endif end subroutine header subroutine get_html_header () html_header = [ CHARACTER ( LEN = 128 ) :: & '<html>' ,& '<head>' ,& '<title>unit_test_results</title>' ,& '<style>        ' ,& 'body {xfont-style: italic}' ,& 'body {                    ' ,& 'background-color:#FFF; color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }' ,& 'a:visited { color:#666; }                                                                                                ' ,& 'h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }                                              ' ,& 'h1 { font-size:200%; }                                                                                                   ' ,& 'h2 { font-size:173%; }                                                                                                   ' ,& 'h3 { font-size:144%; }                                                                                                   ' ,& 'h4 { font-size:120%; }                                                                                                   ' ,& 'h5,h6 { font-size:100% }                                                                                                 ' ,& 'a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }                                                   ' ,& '/*                                                                                                                       ' ,& 'td { border:thin solid #888; word-break: break-all; width: 1em}                                                          ' ,& '*/                                                                                                                       ' ,& 'td { border:thin solid #888; overflow-wrap: break-word; }                                                                ' ,& 'li { margin-bottom:0.5em; }                                                                                              ' ,& 'blockquote { display:block; font-size:90%; font-style:italic; line-height:1.5em; margin:0 0 1.5em; padding:0 2.5em; }    ' ,& 'pre { background-color:#DDD; font-size:90%; overflow:auto; padding:1em; }                                                ' ,& 'a,li span { color:#000; }                                                                                                ' ,& 'a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }                                                ' ,& '#Container { margin:0 10px; text-align:center; }                                                                         ' ,& '#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:58em; }                   ' ,& 'span.webName { font-size:.5em; }                                                                                         ' ,& 'textarea#content { font-size: 1em; line-height: 1.125em; }                                                               ' ,& 'h1#pageName { line-height:1.4em; margin:0.2em 0 0.2em 0; padding:0; }                                                    ' ,& 'h2{ line-height:1.2em; margin:0.2em 0 0.2em 0; padding:0; color:blue;}                                                   ' ,& '.property { color:#666; font-size:80%; }                                                                                 ' ,& 'a.existingWikiWord[title]{ //border: 1px dashed #BBB; }                                                                  ' ,& '.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; }                           ' ,& '/* table takes its dimensions from the <table> element width and                                                         ' ,& 'the width of the first row of cells (or the <col> elements, if you have them).*/                                         ' ,& 'table { table-layout: fixed ; width: 100% ; border:double #000; border-collapse:collapse; }                              ' ,& 'td { width: 25% ; }                                                                                                      ' ,& 'table#unit_test { table-layout: fixed ; width: 100% ; border-collapse: collapse ; border: 1px black solid ; }            ' ,& 'table#unit_test td { width: 25% ; border: 1px black solid ; padding: 10px ; }                                            ' ,& 'table#unit_test caption { font-style: italic ; font-weight: 600; color: gray;}                                           ' ,& '/*                                                                                                                       ' ,& 'col:nth-child(even) {background: #FFF}                                                                                   ' ,& 'col:nth-child(odd) {background: #CCC}                                                                                    ' ,& '*/                                                                                                                       ' ,& 'tr:nth-child(even) {background: #CCC}                                                                                    ' ,& 'tr:nth-child(odd) {background: #FFF}                                                                                     ' ,& '</style>                                                                                                                 ' ,& '<script language=\"JavaScript1.1\" type=\"text/javascript\">                                                                 ' ,& '//<![CDATA[                                                                                                              ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of class                                                                                    ' ,& '   function toggleHiddenClass(objectClassName) {                                                                         ' ,& '                                                                                                                         ' ,& '      const collection = document.getElementsByClassName(objectClassName);                                               ' ,& '                                                                                                                         ' ,& '      for (let i = 0; i < collection.length; i++) {                                                                      ' ,& '         if(collection[i].style.display == \"none\" ) {                                                                    ' ,& '            collection[i].style.display = \"\";                                                                            ' ,& '         }else{                                                                                                          ' ,& '            collection[i].style.display = \"none\";                                                                        ' ,& '         }                                                                                                               ' ,& '      }                                                                                                                  ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   //alert(\"A1\");                                                                                                        ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '   // turn on/off visibility of id                                                                                       ' ,& '   function toggleHiddenId(objectIdName) {                                                                               ' ,& '      var TARGET = document.getElementById(objectIdName);                                                                ' ,& '      if(TARGET.style.display == \"none\" ) {                                                                              ' ,& '         TARGET.style.display = \"\";                                                                                      ' ,& '      }else{                                                                                                             ' ,& '         TARGET.style.display = \"none\";                                                                                  ' ,& '      }                                                                                                                  ' ,& '   //alert(TARGET.style.display);                                                                                        ' ,& '   }                                                                                                                     ' ,& '   //---------------------------------------------------------------------------                                         ' ,& '</script>                                                                                                                ' ,& '<p>                                                                                                                      ' ,& '   <form>                                                                                                                ' ,& '      <input  type=\"button\"  value=\"passed\"   onclick=\"toggleHiddenClass(''passed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"failed\"   onclick=\"toggleHiddenClass(''failed'');\" />                                ' ,& '      <input  type=\"button\"  value=\"untested\" onclick=\"toggleHiddenClass(''untested'');\" />                              ' ,& '      <input  type=\"button\"  value=\"clicks\"   onclick=\"toggleHiddenClass(''clicks'');\" />                                ' ,& '      <input  type=\"button\"  value=\"message\"  onclick=\"toggleHiddenClass(''message'');\" />                               ' ,& '      <input  type=\"button\"  value=\"caption\"  onclick=\"toggleHiddenClass(''caption'');\" />                               ' ,& '      <input  type=\"button\"  value=\"header\"   onclick=\"toggleHiddenClass(''header'');\" />                                ' ,& '  </form>                                                                                                                ' ,& '</p>                                                                                                                     ' ,& '</head>                                                                                                                  ' ,& '<body>                                                                                                                   ' ,& '<div id=\"Container\">                                                                                                     ' ,& '<div id=\"Content\">                                                                                                       ' ,& '' ] html_footer = [ CHARACTER ( LEN = 128 ) :: & '</div>' ,& '</div>' ,& '</body>' ,& '</html>' ,& '' ] end subroutine get_html_header end program bookkeeper","tags":"","url":"sourcefile/bookkeeper.f90.html"},{"title":"demo_compare_float.f90 – M_framework","text":"Source Code program demo_compare_float use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use M_framework__approx , only : compare_float use M_framework__approx , only : & & operator (. equalto .), operator (. greaterthan .), operator (. lessthan .) implicit none integer , parameter :: wp = int32 integer :: i character ( len = 80 ), save :: line = '10*0.1' real ( kind = wp ) :: a ( 10 ), x , y , ulp write ( * , * ) 'is 10*0.1 == 1.0?' ! sum up 0.1 ten times hopefully in a manner compiler does not ! optimize it and in the process make it equal a = 0.1_wp read ( line , * ) a x = sum ( a ) y = 1.0_wp write ( * , * ) merge ( '    EQUAL ' , 'NOT EQUAL!' , x . eq . y ) write ( * , '(*(g0,1x,z0,1x))' ) x , x , y , y ! show decimal and hexadecimal value write ( * , * ) 'regular' , x . eq . y , x . gt . y , x . lt . y ! standard operators ! For the default ULP=1.0, the relational operators can be used write ( * , * ) 'compare' , x . equalto . y , x . greaterthan . y , x . lessthan . y do i = 0 , 10 ulp = real ( i , kind = wp ) / 2.0 write ( * , * ) i , compare_float ( x , y , ulp = ulp ) , 'ULP=' , ulp enddo end program demo_compare_float","tags":"","url":"sourcefile/demo_compare_float.f90.html"},{"title":"demo_unit_test_mode.f90 – M_framework","text":"Source Code program demo_unit_test_mode use M_framework implicit none call unit_test_mode ( keep_going = . false ., luns = [ 6 ], & & brief = . true .) end program demo_unit_test_mode","tags":"","url":"sourcefile/demo_unit_test_mode.f90.html"}]}